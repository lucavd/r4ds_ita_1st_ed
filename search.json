[{"path":"index.html","id":"benvenuto","chapter":"Benvenuto","heading":"Benvenuto","text":" Questo è il sito della traduzione italiana del libro “R Data Science”. Questo libro vi insegnerà come fare data science con R: imparerete come importare vostri dati R, metterli nella struttura più utile, trasformarli, visualizzarli e modellarli. questo libro, troverete una serie di tecniche per la scienza dei dati. Proprio come un chimico impara pulire le provette e rifornire un laboratorio, voi imparerete pulire dati e disegnare grafici–e molte altre cose ancora. Queste sono le abilità che permettono alla scienza dei dati di realizzarsi, e qui troverete le migliori pratiche per fare ognuna di queste cose con R. Imparerete come usare la ‘gramamtica dei grafici’ (grammar graphics), la ‘programmazione letterale’ (literate programming) e la ‘ricerca riproducibile’ (reproducible research) per risparmiare tempo. Imparerete anche come gestire le risorse cognitive per facilitare le scoperte quando si maneggiano, si visualizzano e si esplorano datiQuesto sito è (e sempre sarà) gratuito, ed è licenziato sotto Creative Commons Attribution-NonCommercial-NoDerivs 3.0. Se volete una copia fisica del libro (inglese), potete ordinarlo da amazon; è stato pubblicato da O’Reilly nel gennaio 2017. Se vuoi invece donare qualcosa puoi fare una donazione alla Kākāpō Recovery: il kākāpō (che è riprodotto sulla copertina di R4DS) è un pappagallo nativo della Nuova Zelanda grave rischio di estinzione; ne sono rimasti solo 2131.Nel dicembre 2021 (inizio della traduzione) ne sono rimasti solo 201 (NdT)2R4DS usa un Contributor Code Conduct (versione italiano visionabile qui). Contribuendo questo libro, accetti di rispettare suoi termini.","code":""},{"path":"index.html","id":"nota-sulla-traduzione-italiana","chapter":"Benvenuto","heading":"Nota sulla traduzione italiana","text":"Ultimo Aggiornamento 27 July, 2023La traduzione italiana del libro R4DS è stata condotta da Luca Vedovelli su esplicita autorizzazione dell’autore (Hadley Wickam) e dell’editore O’Reilly che detiene diritti di traduzione.Il motivo che mi ha spinto alla traduzione di un testo fondamentale per chi si avvicina ’ambiente di R e della data science è la volontà di abbattere almeno uno scoglio (la lingua) lungo il loro apprendimento, per permettere al lettore (che io immagino essere una mia studentessa o studente) di concentrarsi sui concetti e tecniche.Ho cercato di cambiare il minimo possibile dal libro originale mantenendo termini inglesi dove corrispondenti italiani suonavano desueti o ridicoli. Anche link, autori, ringraziamenti sono rimasti inalterati. Anche il codice è rimasto inalterato (ho tradotto solo le note di testo interne al codice).La traduzione è stata effettuata sulla prima edizione (poi andata stampa) del libro, quindi non sulla versione aggiornata oggi (che è un seconda edizione fieri). Quando verrà pubblicata la seconda edizione del libro, ne farò una seconda traduzione daccapo.Potete segnalare errori o suggerimenti (molto apprezzati!) aprendo un pull-request alla repository GitHub della traduzione.","code":""},{"path":"index.html","id":"ringraziamenti","chapter":"Benvenuto","heading":"Ringraziamenti","text":"R4DS è uno sforzo collaborativo e molte persone hanno contribuito con correzioni e miglioramenti via pull request: adi pradhan (@adidoit), Andrea Gilardi (@agila5), Ajay Deonarine (@ajay-d), @AlanFeder, pete (@alonzi), Alex (@ALShum), Andrew Landgraf (@andland), @andrewmacfarland, Michael Henry (@aviast), Mara Averick (@batpigandme), Brent Brewington (@bbrewington), Bill Behrman (@behrman), Ben Herbertson (@benherbertson), Ben Marwick (@benmarwick), Ben Steinberg (@bensteinberg), Brandon Greenwell (@bgreenwell), Brett Klamer (@bklamer), Christian Mongeau (@chrMongeau), Cooper Morris (@coopermor), Colin Gillespie (@csgillespie), Rademeyer Vermaak (@csrvermaak), Abhinav Singh (@curious-abhinav), Curtis Alexander (@curtisalexander), Christian G. Warden (@cwarden), Kenny Darrell (@darrkj), David Rubinger (@davidrubinger), David Clark (@DDClark), Derwin McGeary (@derwinmcgeary), Daniel Gromer (@dgromer), @djbirke, Devin Pastoor (@dpastoor), Julian (@duju211), Dylan Cashman (@dylancashman), Dirk Eddelbuettel (@eddelbuettel), Edwin Thoen (@EdwinTh), Ahmed El-Gabbas (@elgabbas), Eric Watt (@ericwatt), Erik Erhardt (@erikerhardt), Etienne B. Racine (@etiennebr), Everett Robinson (@evjrob), Flemming Villalona (@flemingspace), Floris Vanderhaeghe (@florisvdh), Garrick Aden-Buie (@gadenbuie), Garrett Grolemund (@garrettgman), Josh Goldberg (@GoldbergData), bahadir cankardes (@gridgrad), Gustav W Delius (@gustavdelius), Hadley Wickham (@hadley), Hao Chen (@hao-trivago), Harris McGehee (@harrismcgehee), Hengni Cai (@hengnicai), Ian Sealy (@iansealy), Ian Lyttle (@ijlyttle), Ivan Krukov (@ivan-krukov), Jacob Kaplan (@jacobkap), Jazz Weisman (@jazzlw), John D. Storey (@jdstorey), Jeff Boichuk (@jeffboichuk), Gregory Jefferis (@jefferis), 蒋雨蒙 (@JeldorPKU), Jennifer (Jenny) Bryan (@jennybc), Jen Ren (@jenren), Jeroen Janssens (@jeroenjanssens), Jim Hester (@jimhester), JJ Chen (@jjchern), Joanne Jang (@joannejang), John Sears (@johnsears), @jonathanflint, Jon Calder (@jonmcalder), Jonathan Page (@jonpage), Justinas Petuchovas (@jpetuchovas), Jose Roberto Ayala Solares (@jroberayalas), Julia Stewart Lowndes (@jules32), Sonja (@kaetschap), Kara Woo (@karawoo), Katrin Leinweber (@katrinleinweber), Karandeep Singh (@kdpsingh), Kyle Humphrey (@khumph), Kirill Sevastyanenko (@kirillseva), @koalabearski, Kirill Müller (@krlmlr), Noah Landesberg (@landesbergn), @lindbrook, Mauro Lepore (@maurolepore), Mark Beveridge (@mbeveridge), Matt Herman (@mfherman), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), Matthew Hendrickson (@mjhendrickson), @MJMarshall, Mustafa Ascha (@mustafaascha), Nelson Areal (@nareal), Nate Olson (@nate-d-olson), Nathanael (@nateaff), Nick Clark (@nickclark1000), @nickelas, Nirmal Patel (@nirmalpatel), Nina Munkholt Jakobsen (@nmjakobsen), Jakub Nowosad (@Nowosad), Peter Hurford (@peterhurford), Patrick Kennedy (@pkq), Radu Grosu (@radugrosu), Ranae Dietzel (@Ranae), Robin Gertenbach (@rgertenbach), Richard Zijdeman (@rlzijdeman), Robin (@Robinlovelace), Emily Robinson (@robinsones), Rohan Alexander (@RohanAlexander), Romero Morais (@RomeroBarata), Albert Y. Kim (@rudeboybert), Saghir (@saghirb), Jonas (@sauercrowd), Robert Schuessler (@schuess), Seamus McKinsey (@seamus-mckinsey), @seanpwilliams, Luke Smith (@seasmith), Matthew Sedaghatfar (@sedaghatfar), Sebastian Kraus (@sekR4), Sam Firke (@sfirke), Shannon Ellis (@ShanEllis), @shoili, S’busiso Mkhondwane (@sibusiso16), @spirgel, Steven M. Mortimer (@StevenMMortimer), Stéphane Guillou (@stragu), Sergiusz Bleja (@svenski), Tal Galili (@talgalili), Tim Waterhouse (@timwaterhouse), TJ Mahr (@tjmahr), Thomas Klebel (@tklebel), Tom Prior (@tomjamesprior), Terence Teo (@tteo), Beasley (@wibeasley), @yahwes, Yihui Xie (@yihui), Yiming (Paul) Li (@yimingli), Hiroaki Yutani (@yutannihilation), @zeal626, Azza Ahmed (@zo0z)R4DS è ospitato da https://www.netlify.com come parte del loro supporto al software e alla comunità open source.","code":""},{"path":"introduzione.html","id":"introduzione","chapter":"1 Introduzione","heading":"1 Introduzione","text":"La scienza dei dati (data science) è una disciplina eccitante che permette di trasformare dati grezzi comprensione, intuizione e conoscenza. L’obiettivo di “R Data Science” è di aiutarvi imparare gli strumenti più importanti R che vi permetteranno di fare data science. Dopo aver letto questo libro, avrete gli strumenti per affrontare un’ampia varietà di sfide, usando le parti migliori di R.","code":""},{"path":"introduzione.html","id":"cosa-imparerai","chapter":"1 Introduzione","heading":"1.1 Cosa imparerai","text":"La data science è una disciplina enorme, e non c’è modo di padroneggiarla leggendo un solo libro. L’obiettivo di questo libro è di darvi una solida base negli strumenti più importanti. Il nostro modello degli strumenti necessari un tipico progetto di data science assomiglia questo:Per prima cosa devi importare tuoi dati R. Questo tipicamente significa che prendi dati memorizzati un file, database, o interfaccia di programmazione per applicazioni web (API, Application Programming Interface), e li carichi un data frame R. Se non puoi importare tuoi dati R, non puoi fare data science su di essi!Una volta che hai importato tuoi dati, è una buona idea metterli ordine ( tidy ). Riordinare tuoi dati significa memorizzarli una forma coerente che corrisponda alla semantica del dataset con il modo cui è memorizzato. breve, quando tuoi dati sono ordinati, ogni colonna è una variabile e ogni riga è un’osservazione. dati ordinati sono importanti perché la struttura coerente vi permette di concentrare la tua attenzione alle domande sui dati, senza lottare per mettere dati nella forma giusta per diverse funzioni.Una volta che si hanno dati ordinati, un primo passo comune è quello di trasformarli( transform ). La trasformazione include il concentrarsi sulle osservazioni di interesse (come tutte le persone una città, o tutti dati dell’ultimo anno), la creazione di nuove variabili che sono funzioni di variabili esistenti (come calcolare la velocità dalla distanza e dal tempo), e il calcolo di una serie di statistiche riassuntive (come conteggi o le medie). Insieme, il riordino e la trasformazione sono chiamati “lotta” ( wrangling ), perché ottenere che tuoi dati abbiano una forma che sia naturale per lavorarci spesso sembra una lotta!Una volta che hai dati ordinati con le variabili di cui hai bisogno, ci sono due motori principali di generazione della conoscenza: visualizzazione e modellazione. Questi hanno punti di forza e di debolezza complementari, quindi ogni vera analisi itererà tra loro molte volte.La visualizzazione ( visualisation ) è un’attività fondamentalmente umana. Una buona visualizzazione ti mostrerà cose che non ti aspettavi, o solleverà nuove domande sui dati. Una buona visualizzazione potrebbe anche suggerirti che ti stavi facendo la domanda sbagliata, o che hai bisogno di raccogliere dati diversi. Le visualizzazioni possono sorprendere, ma non sono particolarmente adatte perché richiedono un umano che le interpreti.modelli ( models ) sono strumenti complementari alla visualizzazione. Una volta che hai reso le tue domande sufficientemente precise, puoi usare un modello per rispondere. modelli sono uno strumento fondamentalmente matematico o computazionale, quindi generalmente sono ben scalabili. Anche quando non lo fanno, di solito è più economico comprare più computer che comprare più cervelli! Ma ogni modello fa delle ipotesi, e per sua natura un modello non può mettere discussione le proprie ipotesi. Ciò significa che un modello non può fondamentalmente sorprenderti.L’ultimo passo della scienza dei dati è la comunicazione ( communication ), una parte assolutamente critica di qualsiasi progetto di analisi di dati. Non importa quanto bene tuoi modelli e la visualizzazione ti abbiano portato capire dati se non puoi anche comunicare tuoi risultati ad altri.Attorno tutti questi strumenti c’è la programmazione ( programming ). La programmazione è uno strumento trasversale che si usa ogni parte del progetto. Non c’è bisogno di essere un programmatore esperto per essere uno scienziato dei dati, ma imparare di più sulla programmazione ripaga perché diventare un programmatore migliore permette di automatizzare compiti comuni e risolvere nuovi problemi con maggiore facilità.Userai questi strumenti ogni progetto di data science, ma per la maggior parte dei progetti non sono sufficienti. C’è una regola approssimativa 80-20 gioco; potete affrontare circa l’80% di ogni progetto usando gli strumenti che imparerete questo libro, ma avrete bisogno di altri strumenti per affrontare il restante 20%. tutto questo libro ti indicheremo le risorse dove puoi imparare di più.","code":""},{"path":"introduzione.html","id":"come-è-organizzato-questo-libro","chapter":"1 Introduzione","heading":"1.2 Come è organizzato questo libro","text":"La precedente descrizione degli strumenti della data science è organizzata ’incirca secondo l’ordine cui li userai un’analisi (anche se naturalmente li ripasserai più volte). Nella nostra esperienza, tuttavia, questo non è il modo migliore per impararli:Iniziare con l’inserimento e il riordino dei dati è sub-ottimale perché l’80% del tempo\nè di routine e noioso, e il restante 20% del tempo è strano e\nfrustrante. Questo è un brutto posto per iniziare imparare una nuova materia! Invece,\ninizieremo con la visualizzazione e la trasformazione di dati che sono già stati\nimportati e riordinati. questo modo, quando importerai e riordinerai tuoi dati, la tua\nmotivazione rimarrà alta perché saprai che la frustrazione inziale ne varrà la pena.Iniziare con l’inserimento e il riordino dei dati è sub-ottimale perché l’80% del tempo\nè di routine e noioso, e il restante 20% del tempo è strano e\nfrustrante. Questo è un brutto posto per iniziare imparare una nuova materia! Invece,\ninizieremo con la visualizzazione e la trasformazione di dati che sono già stati\nimportati e riordinati. questo modo, quando importerai e riordinerai tuoi dati, la tua\nmotivazione rimarrà alta perché saprai che la frustrazione inziale ne varrà la pena.Alcuni argomenti sono spiegati meglio con altri strumenti. Per esempio, crediamo che\nsia più facile capire come funzionano modelli se si conoscono già\nvisualizzazione, dati ordinati e programmazione.Alcuni argomenti sono spiegati meglio con altri strumenti. Per esempio, crediamo che\nsia più facile capire come funzionano modelli se si conoscono già\nvisualizzazione, dati ordinati e programmazione.Gli strumenti di programmazione non sono necessariamente interessanti di per sé,\nma ti permettono di affrontare problemi molto più impegnativi. Noi ti daremo\nuna selezione di strumenti di programmazione metà del libro, e\npoi vedrai come possono combinarsi con gli strumenti di data science per affrontare\ninteressanti problemi di modellazione.Gli strumenti di programmazione non sono necessariamente interessanti di per sé,\nma ti permettono di affrontare problemi molto più impegnativi. Noi ti daremo\nuna selezione di strumenti di programmazione metà del libro, e\npoi vedrai come possono combinarsi con gli strumenti di data science per affrontare\ninteressanti problemi di modellazione.’interno di ogni capitolo, cerchiamo di attenerci uno schema simile: iniziamo con alcuni esempi motivanti modo che tu possa vedere il quadro generale, e poi ci immergiamo nei dettagli. Ogni sezione del libro è accompagnata da esercizi per aiutarti mettere pratica ciò che hai imparato. Anche se si è tentati di saltare gli esercizi, non c’è modo migliore per imparare che fare pratica su problemi reali.","code":""},{"path":"introduzione.html","id":"cosa-non-imparerai","chapter":"1 Introduzione","heading":"1.3 Cosa non imparerai","text":"Ci sono alcuni argomenti importanti che questo libro non tratta. Crediamo che sia importante rimanere spietatamente concentrati sull’essenziale modo da poter essere operativi il più velocemente possibile. Ciò significa che questo libro non può coprire tutti gli argomenti importanti.","code":""},{"path":"introduzione.html","id":"big-data","chapter":"1 Introduzione","heading":"1.3.1 Big data","text":"Questo libro si concentra orgogliosamente su piccoli set di dati che stanno nella memoria di un normale PC. Questo è il posto giusto per iniziare perché non si possono affrontare big data se non si ha esperienza con piccoli dati. Gli strumenti che imparerai questo libro saranno utili gestire facilmente centinaia di megabyte di dati, e con un po’ di attenzione potrai usarli per lavorare con 1-2 Gb di dati. Se lavori abitualmente con dati più grandi (10-100 Gb, diciamo), dovresti imparare di più su data.table. Questo libro non insegna data.table perché ha un’interfaccia molto concisa che lo rende più difficile da imparare poiché offre meno spunti linguistici. Ma se stai lavorando con grandi dati, il guadagno termini di prestazioni vale lo sforzo extra richiesto per impararlo.Se tuoi dati sono ancora più grandi, valuta attentamente se il tuo problema di big data possa essere realtà un problema di small data sotto mentite spoglie. Mentre dati completi potrebbero essere grandi, spesso dati necessari per rispondere una domanda specifica sono piccoli. Potresti essere grado di trovare un sottoinsieme, un sottocampione o un riassunto che si adatti alla memoria del tuo PC e che ti permetta comunque di rispondere alla domanda che ti interessa. La sfida questo caso è trovare piccoli dati giusti, il che spesso richiede un sacco di prove.Un’altra possibilità è che il tuo problema di grandi dati sia realtà un gran numero di problemi di piccoli dati. Ogni singolo problema potrebbe adattarsi alla memoria, ma ne hai milioni. Per esempio, potresti voler adattare un modello ogni persona nel tuo set di dati. Questo sarebbe banale se tu avessi solo 10 o 100 persone, ma invece ne hai un milione. Fortunatamente ogni problema è indipendente dagli altri (una configurazione che volte viene chiamata “imbarazzantemente parallela” ( embarrassingly parallel )), quindi hai solo bisogno di un sistema (come Hadoop o Spark) che ti permetta di inviare diversi set di dati diversi computer per l’elaborazione. Una volta che hai capito come rispondere alla domanda per un singolo sottoinsieme usando gli strumenti descritti questo libro, impari nuovi strumenti come sparklyr, rhipe e ddr per risolverla per l’intero set di dati.","code":""},{"path":"introduzione.html","id":"python-julia-e-amici","chapter":"1 Introduzione","heading":"1.3.2 Python, Julia e amici","text":"questo libro, non imparerai nulla su Python, Julia, o qualsiasi altro linguaggio di programmazione utile per la scienza dei dati. Questo non perché pensiamo che questi strumenti siano terribili. Non lo sono! E pratica, la maggior parte dei team di data science usa un mix di linguaggi, spesso almeno R e Python.Tuttavia, crediamo fortemente che sia meglio padroneggiare uno strumento alla volta. Migliorerai più velocemente se ti immergerai profondità, piuttosto che sparpagliarti su molti argomenti. Questo non significa che dovrai sapere solo una cosa, solo che genere imparerai più velocemente se ti atterrai una cosa alla volta. Dovresti sforzarti di imparare nuove cose durante la tua carriera, ma assicurati che la tua comprensione sia solida prima di passare alla prossima cosa interessante.Pensiamo che R sia un ottimo posto per iniziare il tuo viaggio nella scienza dei dati perché è un ambiente progettato da zero per supportarela. R non è solo un linguaggio di programmazione, ma è anche un ambiente interattivo. Per supportare l’interazione, R è un linguaggio molto più flessibile di molti dei suoi colleghi. Questa flessibilità ha suoi lati negativi, ma il grande vantaggio è quanto sia facile evolvere grammatiche su misura per parti specifiche del processo di data science. Questi mini linguaggi ti aiutano pensare ai problemi come uno scienziato dei dati, mentre supportano un’interazione fluida tra il tuo cervello e il computer.","code":""},{"path":"introduzione.html","id":"dati-non-rettangolari","chapter":"1 Introduzione","heading":"1.3.3 Dati non rettangolari","text":"Questo libro si concentra esclusivamente su dati rettangolari: collezioni di valori che sono ciascuno associato una variabile e un’osservazione. Ci sono molti insiemi di dati che non rientrano naturalmente questo paradigma, comprese le immagini, suoni, gli alberi e il testo. Ma data frame rettangolari sono estremamente comuni nella scienza e nell’industria, e noi crediamo che siano un ottimo punto di partenza per il tuo viaggio.","code":""},{"path":"introduzione.html","id":"conferma-delle-ipotesi","chapter":"1 Introduzione","heading":"1.3.4 Conferma delle ipotesi","text":"È possibile dividere l’analisi dei dati due campi: la generazione di ipotesi e la conferma di ipotesi (volte chiamata analisi confermativa). Il focus di questo libro è apertamente sulla generazione di ipotesi, o esplorazione dei dati. Qui guarderai profondamente dati e, combinazione con la tua conoscenza della materia, genererai molte ipotesi interessanti per aiutare spiegare perché dati si comportino quel modo. Valuterai le ipotesi modo informale, usando il tuo scetticismo per sfidare dati vari modi.Il complemento della generazione di ipotesi è la conferma delle ipotesi. La conferma delle ipotesi è difficile per due motivi:Ha bisogno di un modello matematico preciso per generare previsioni falsificabili.\nQuesto spesso richiede una notevole sofisticazione statistica.Ha bisogno di un modello matematico preciso per generare previsioni falsificabili.\nQuesto spesso richiede una notevole sofisticazione statistica.Si può usare un’osservazione solo una volta per confermare un’ipotesi. Non appena\nla si usa più di una volta si torna fare analisi esplorative.\nQuesto significa che per fare la conferma dell’ipotesi hai bisogno di “pre-registrare”\n(scrivere anticipo) il tuo piano di analisi, e non deviare da esso\nneanche dopo aver visto dati. Parleremo un po’ di alcune\nstrategie che puoi usare per rendere questo più facile modelling.Si può usare un’osservazione solo una volta per confermare un’ipotesi. Non appena\nla si usa più di una volta si torna fare analisi esplorative.\nQuesto significa che per fare la conferma dell’ipotesi hai bisogno di “pre-registrare”\n(scrivere anticipo) il tuo piano di analisi, e non deviare da esso\nneanche dopo aver visto dati. Parleremo un po’ di alcune\nstrategie che puoi usare per rendere questo più facile modelling.È comune pensare alla modellazione ( modelling ) come uno strumento per la conferma delle ipotesi, e alla visualizzazione come uno strumento per la generazione di ipotesi. Ma questa è una falsa dicotomia: modelli sono spesso usati per l’esplorazione, e con un po’ di attenzione si può usare la visualizzazione per la conferma. La differenza chiave è quanto spesso si guarda ogni osservazione: se si guarda solo una volta, è conferma; se si guarda più di una volta, è esplorazione.","code":""},{"path":"introduzione.html","id":"prerequisiti","chapter":"1 Introduzione","heading":"1.4 Prerequisiti","text":"Abbiamo fatto alcune supposizioni su ciò che già sai per ottenere il massimo da questo libro. Dovresti essere generalmente alfabetizzato dal punto di vista numerico, ed è utile tu abbia già qualche esperienza di programmazione. Se non hai mai programmato prima, potresti trovare Hands Programming R di Garrett come utile complemento questo libro.Ci sono quattro cose di cui avrai bisogno per eseguire il codice questo libro: R, RStudio, una collezione di pacchetti di R chiamata tidyverse, e una manciata di altri pacchetti. pacchetti sono le unità fondamentali del codice R riproducibile. Includono funzioni riutilizzabili, la documentazione che descrive come usarle, e dati di esempio.","code":""},{"path":"introduzione.html","id":"rstudio","chapter":"1 Introduzione","heading":"1.4.1 RStudio","text":"RStudio è un ambiente di sviluppo integrato, o IDE (Integrated Development Environment), per la programmazione R. Scaricalo e installalo da http://www.rstudio.com/download. RStudio viene aggiornato un paio di volte ’anno. Quando una nuova versione è disponibile, RStudio te lo farà sapere. È una buona idea aggiornare regolarmente modo da poter trarre vantaggio dalle ultime e più grandi caratteristiche. Per questo libro, assicuratevi di avere almeno RStudio 1.0.0.Quando avvierai RStudio, vedrai due regioni chiave nell’interfaccia:Per ora, tutto quello che devi sapere è che digiti il codice R nel pannello della console e premi invio per eseguirlo. Imparerai di più andando avanti!","code":""},{"path":"introduzione.html","id":"il-tidyverse","chapter":"1 Introduzione","heading":"1.4.2 Il tidyverse","text":"Avrai anche bisogno di installare alcuni pacchetti R. Un pacchetto (‘package’) di R è una collezione di funzioni, dati e documentazione che estende le capacità di R di base. L’uso dei pacchetti è la chiave per un uso efficace di R. La maggior parte dei pacchetti che imparerai questo libro fanno parte del cosiddetto tidyverse. pacchetti del tidyverse condividono una comune filosofia dei dati e della programmazione R, e sono progettati per lavorare insieme modo naturale.Puoi installare l’intero tidyverse con una sola linea di codice:Sul tuo computer, digita questa linea di codice nella console, e poi premi invio per eseguirla. R scaricherà pacchetti da CRAN e li installerà sul tuo computer. Se hai problemi nell’installazione, assicurati di avere attiva la connessione internet e che https://cloud.r-project.org/ non sia bloccato da firewall o proxy.Non sarai grado di usare le funzioni, gli oggetti e file di aiuto di un pacchetto finché non lo caricherai con library(). Una volta che hai installato un pacchetto, puoi caricarlo con la funzione library():Questo ti dice che tidyverse sta caricando pacchetti ggplot2, tibble, tidyr, readr, purrr e dplyr. Questi sono considerati il core (‘nucleo’) del tidyverse perché li userai quasi tutte le analisi.pacchetti del tidyverse cambiano abbastanza frequentemente. Puoi vedere se sono disponibili aggiornamenti, e opzionalmente installarli, eseguendo tidyverse_update().","code":"\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n#> ✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n#> ✔ tibble  3.1.8     ✔ dplyr   1.1.0\n#> ✔ tidyr   1.3.0     ✔ stringr 1.5.0\n#> ✔ readr   2.1.4     ✔ forcats 1.0.0\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()"},{"path":"introduzione.html","id":"altri-pacchetti","chapter":"1 Introduzione","heading":"1.4.3 Altri pacchetti","text":"Ci sono molti altri eccellenti pacchetti che non fanno parte del tidyverse, perché risolvono problemi un dominio diverso, o sono progettati con un diverso insieme di principi di base. Questo non li rende migliori o peggiori, solo diversi. altre parole, il complemento al tidyverse non è il messyverse3, ma molti altri universi di pacchetti interconnessi. Man mano che affronterai più progetti di scienza dei dati con R, imparerai nuovi pacchetti e nuovi modi di pensare ai dati.questo libro useremo tre pacchetti di dati al di fuori del tidyverse:Questi pacchetti forniscono dati sui voli aerei, sullo sviluppo mondiale e sul baseball che useremo per illustrare le idee chiave della scienza dei dati.","code":"\ninstall.packages(c(\"nycflights13\", \"gapminder\", \"Lahman\"))"},{"path":"introduzione.html","id":"eseguire-il-codice-r","chapter":"1 Introduzione","heading":"1.5 Eseguire il codice R","text":"La sezione precedente ti ha mostrato un paio di esempi di esecuzione del codice R. Il codice nel libro assomiglia questo:Se esegui lo stesso codice nella tua console locale, apparirà così:Ci sono due differenze principali. Nella tua console, digiti dopo il >, chiamato prompt; nel libro non mostriamo il prompt. Nel libro, l’output è commentato con #>>; nella tua console appare direttamente dopo il tuo codice. Queste due differenze sono utili se stai lavorando con una versione elettronica del libro, e puoi facilmente copiare il codice dal libro alla console.tutto il libro usiamo un insieme coerente di convenzioni per riferirci al codice:Le funzioni sono un carattere di codice e seguite da parentesi, come sum(),\no mean().Le funzioni sono un carattere di codice e seguite da parentesi, come sum(),\no mean().Altri oggetti R (come dati o argomenti di funzioni) sono un font di codice,\nsenza parentesi, come flights o x.Altri oggetti R (come dati o argomenti di funzioni) sono un font di codice,\nsenza parentesi, come flights o x.Se vogliamo rendere chiaro da quale pacchetto proviene un oggetto, useremo\nil nome del pacchetto seguito da due punti, come dplyr::mutate(), onycflights13::flights. Anche questo è un codice R valido.Se vogliamo rendere chiaro da quale pacchetto proviene un oggetto, useremo\nil nome del pacchetto seguito da due punti, come dplyr::mutate(), onycflights13::flights. Anche questo è un codice R valido.","code":"\n1 + 2\n#> [1] 3> 1 + 2\n[1] 3"},{"path":"introduzione.html","id":"ottenere-aiuto-e-imparare-di-più","chapter":"1 Introduzione","heading":"1.6 Ottenere aiuto e imparare di più","text":"Questo libro non è un’isola; non c’è una singola risorsa che ti permetterà di padroneggiare R. Quando inizierai ad applicare le tecniche descritte questo libro ai tuoi dati, troverai presto delle domande cui non abbiamo risposto. Questa sezione descrive alcuni suggerimenti su come ottenere aiuto, e per aiutarti continuare imparare.Se ci si blocca, si iniza con Google. Di solito l’aggiunta di “R” una ricerca è sufficiente limitarla ai soli risultati pertinenti: se la ricerca non è utile, spesso significa che non ci sono risultati specifici per R disponibili. Google è particolarmente utile per messaggi di errore. Se ricevi un messaggio di errore e non hai idea di cosa significhi, prova cercarlo su Google! È probabile che qualcun altro sia stato confuso da questo messaggio passato, e ci sarà un aiuto da qualche parte sul web. (Se il messaggio di errore non è italiano, esegui Sys.setenv(LANGUAGE = \"\") e riesegui il codice; è più probabile trovare aiuto italiano per messaggi di errore italiano).Se Google non aiuta, prova stackoverflow. Inizia dedicare un po’ di tempo alla ricerca di una risposta esistente, includendo [R] per limitare la ricerca domande e risposte che usano R. Se non trovi nulla di utile, prepara un esempio minimo riproducibile o reprex. Un buon reprex rende più facile per le altre persone aiutarti, e spesso risolverai il problema autonomia nel corso della sua realizzazione.Ci sono tre cose che dovresti includere per rendere il tuo esempio riproducibile: pacchetti necessari, dati e il codice.Pacchetti dovrebbero essere caricati ’inizio dello script, così è facile\nvedere di quali l’esempio ha bisogno. Questo è un buon momento per controllare che si stia\nusando l’ultima versione di ogni pacchetto; è possibile che tu abbia scoperto\nun bug che sia stato risolto da quando hai installato il pacchetto. Per pacchetti\nnel tidyverse, il modo più semplice per controllare è eseguire tidyverse_update().Pacchetti dovrebbero essere caricati ’inizio dello script, così è facile\nvedere di quali l’esempio ha bisogno. Questo è un buon momento per controllare che si stia\nusando l’ultima versione di ogni pacchetto; è possibile che tu abbia scoperto\nun bug che sia stato risolto da quando hai installato il pacchetto. Per pacchetti\nnel tidyverse, il modo più semplice per controllare è eseguire tidyverse_update().Il modo più semplice per includere dati una domanda è usare dput() per\ngenerare il codice R per ricrearlo. Per esempio, per ricreare il dataset `mtcars\nR, esegui seguenti passi:\nEsegui dput(mtcars) R\nCopia l’output\nNel tuo script riproducibile, scrivi mtcars <- e poi incolla.\nProva trovare il più piccolo sottoinsieme dei tuoi dati che rivela ancora\nil problema.Il modo più semplice per includere dati una domanda è usare dput() per\ngenerare il codice R per ricrearlo. Per esempio, per ricreare il dataset `mtcars\nR, esegui seguenti passi:Esegui dput(mtcars) RCopia l’outputNel tuo script riproducibile, scrivi mtcars <- e poi incolla.Prova trovare il più piccolo sottoinsieme dei tuoi dati che rivela ancora\nil problema.Spendi un po’ di tempo per assicurarti che il tuo codice sia facile da\nleggere:\nAssicurati di aver usato spazi e che nomi delle tue variabili siano concisi, ma\ninformativi.\nUsa commenti (testo preceduto da #) per indicare dove sta il tuo problema.\nFai del tuo meglio per rimuovere tutto ciò che non è collegato al problema.\nPiù corto e più facile è da capire è il tuo codice, e più facile sarà da correggere.\nSpendi un po’ di tempo per assicurarti che il tuo codice sia facile da\nleggere:Assicurati di aver usato spazi e che nomi delle tue variabili siano concisi, ma\ninformativi.Assicurati di aver usato spazi e che nomi delle tue variabili siano concisi, ma\ninformativi.Usa commenti (testo preceduto da #) per indicare dove sta il tuo problema.Usa commenti (testo preceduto da #) per indicare dove sta il tuo problema.Fai del tuo meglio per rimuovere tutto ciò che non è collegato al problema.\nPiù corto e più facile è da capire è il tuo codice, e più facile sarà da correggere.Fai del tuo meglio per rimuovere tutto ciò che non è collegato al problema.\nPiù corto e più facile è da capire è il tuo codice, e più facile sarà da correggere.Finisci controllando che hai effettivamente fatto un esempio riproducibile iniziando una nuova sessione di R e copiando e incollando il tuo script.Dovresti anche spendere un po’ di tempo per prepararti risolvere problemi prima che si presentino. Investire un po’ di tempo per imparare R ogni giorno ti ripagherà ampiamente nel lungo periodo. Un modo è quello di seguire quello che Hadley, Garrett, e tutti gli altri RStudio stanno facendo sul RStudio blog. Qui è dove pubblichiamo annunci su nuovi pacchetti, nuove caratteristiche dell’IDE, e corsi di persona. Potresti anche seguire Hadley (@hadleywickham) o Garrett (@statgarrett) su Twitter, o seguire @rstudiotips per essere aggiornati sulle nuove funzionalità dell’IDE.Per stare al passo con la comunità R più generale, ti consigliamo di leggere http://www.r-bloggers.com: aggrega oltre 500 blog su R da tutto il mondo. Se sei un utente attivo di Twitter, segui l’hashtag (#rstats). Twitter è uno degli strumenti chiave che Hadley usa per stare al passo con nuovi sviluppi della comunità.","code":""},{"path":"introduzione.html","id":"ringraziamenti-1","chapter":"1 Introduzione","heading":"1.7 Ringraziamenti","text":"Questo libro non è solo il prodotto di Hadley e Garrett, ma è il risultato di molte conversazioni (di persona e online) che abbiamo avuto con molte persone nella comunità R. Ci sono alcune persone che vorremmo ringraziare particolare, perché hanno passato molte ore rispondere alle nostre stupide domande e ci hanno aiutato pensare meglio alla scienza dei dati:Jenny Bryan e Lionel Henry per molte utili discussioni sul lavoro\ncon liste e colonne di liste.Jenny Bryan e Lionel Henry per molte utili discussioni sul lavoro\ncon liste e colonne di liste.tre capitoli sul workflow (‘flusso di lavoro’) sono stati adattati (con permesso) da\nhttp://stat545.com/block002_hello-r-workspace-wd-project.html da\nJenny Bryan.tre capitoli sul workflow (‘flusso di lavoro’) sono stati adattati (con permesso) da\nhttp://stat545.com/block002_hello-r-workspace-wd-project.html da\nJenny Bryan.Genevera Allen per le discussioni sui modelli, la modellazione, la\nprospettiva di apprendimento statistico, e la differenza tra generazione di ipotesi e\nconferma delle ipotesi.Genevera Allen per le discussioni sui modelli, la modellazione, la\nprospettiva di apprendimento statistico, e la differenza tra generazione di ipotesi e\nconferma delle ipotesi.Yihui Xie per il suo lavoro sul pacchetto bookdown\ne per aver risposto instancabilmente alle nostre richieste di funzionalità.Yihui Xie per il suo lavoro sul pacchetto bookdown\ne per aver risposto instancabilmente alle nostre richieste di funzionalità.Bill Behrman per la sua attenta lettura dell’intero libro, e per averlo provato\ncon la sua classe di data science Stanford.Bill Behrman per la sua attenta lettura dell’intero libro, e per averlo provato\ncon la sua classe di data science Stanford.La comunità di twitter di #rstats che ha rivisto tutte le bozze dei capitoli\ne ha fornito tonnellate di feedback utili.La comunità di twitter di #rstats che ha rivisto tutte le bozze dei capitoli\ne ha fornito tonnellate di feedback utili.Tal Galili per aver migliorato il suo pacchetto dendextend per supportare una sezione sul clustering che non è stata inserita nella bozza finale.Tal Galili per aver migliorato il suo pacchetto dendextend per supportare una sezione sul clustering che non è stata inserita nella bozza finale.Questo libro è stato scritto modo aperto, e molte persone hanno contribuito con pull request per risolvere problemi minori. Un ringraziamento speciale va tutti coloro che hanno contribuito tramite GitHub:Grazie tutti collaboratori ordine alfabetico: . s, Abhinav Singh, Ahmed ElGabbas, Ajay Deonarine, @AlanFeder, Albert Y. Kim, @Alex, Andrea Gilardi, Andrew Landgraf, Angela Li, Azza Ahmed, Ben Herbertson, Ben Marwick, Ben Steinberg, Benjamin Yeh, Bianca Peterson, Bill Behrman, @BirgerNi, Brandon Greenwell, Brent Brewington, Brett Klamer, Brian G. Barkley, Charlotte Wickham, Christian G. Warden, Christian Heinrich, Christian Mongeau, Colin Gillespie, Cooper Morris, Curtis Alexander, @DSGeoff, Daniel Gromer, David Clark, David Rubinger, Derwin McGeary, Devin Pastoor, Dirk Eddelbuettel, Dylan Cashman, Earl Brown, Edwin Thoen, Eric Watt, Erik Erhardt, Etienne B. Racine, Everett Robinson, Flemming Villalona, Floris Vanderhaeghe, Garrick Aden-Buie, George Wang, Gregory Jefferis, Gustav W Delius, Hao Chen, Hengni Cai, Hiroaki Yutani, Hojjat Salmasian, Ian Lyttle, Ian Sealy, Ivan Krukov, Jacek Kolacz, Jacob Kaplan, Jakub Nowosad, Jazz Weisman, Jeff Boichuk, Jeffrey Arnold, Jen Ren, Jennifer (Jenny) Bryan, Jeroen Janssens, Jim Hester, Joanne Jang, Johannes Gruber, John Blischak, John D. Storey, John Sears, Jon Calder, @Jonas, Jonathan Page, Jose Roberto Ayala Solares, Josh Goldberg, Julia Stewart Lowndes, Julian , Justinas Petuchovas, Kara Woo, Kara de la Marck, Katrin Leinweber, Kenny Darrell, Kirill Müller, Kirill Sevastyanenko, Kunal Marwaha, @KyleHumphrey, Lawrence Wu, Luke Smith, Luke W Johnston, @MJMarshall, Mara Averick, Maria Paula Caldas, Mark Beveridge, Matt Herman, @MattWittbrodt, Matthew Hendrickson, Matthew Sedaghatfar, Mauro Lepore, Michael Henry, Mine Cetinkaya-Rundel, Mustafa Ascha, Nelson Areal, Nicholas Tierney, Nick Clark, Nina Munkholt Jakobsen, Nirmal Patel, Nischal Shrestha, Noah Landesberg, @OaCantona, Pablo E, Patrick Kennedy, @Paul, Peter Hurford, Rademeyer Vermaak, Radu Grosu, Ranae Dietzel, Riva Quiroga, Rob Tenorio, Robert Schuessler, Robin Gertenbach, Rohan Alexander, @RomeroBarata, S’busiso Mkhondwane, @Saghir, Sam Firke, Seamus McKinsey, Sebastian Kraus, Shannon Ellis, @Sophiazj, Steve Mortimer, Stéphane Guillou, TJ Mahr, Tal Galili, Terence Teo, Thomas Klebel, Tim Waterhouse, Tom Prior, Ulrik Lyngs, Beasley, Yihui Xie, Yiming (Paul) Li, Yu Yu Aung, Zach Bogart, Zhuoer Dong, @-rosenberg, adi pradhan, @andrewmacfarland, bahadir cankardes, @batpigandme, @behrman, @boardtc, @djbirke, @harrismcgehee, @jennybc, @jjchern, @jonathanflint, @juandering, @kaetschap, @kdpsingh, @koalabearski, @lindbrook, @nate-d-olson, @nattalides, @nickelas, @nwaff, @pete, @rlzijdeman, @robertchu03, @robinlovelace, @robinsones, @seamus-mckinsey, @seanpwilliams, @shoili, @sibusiso16, @spirgel, @svenski, @twgardner2, @yahwes, @zeal626, @蒋雨蒙.","code":""},{"path":"introduzione.html","id":"colophon","chapter":"1 Introduzione","heading":"1.8 Colophon","text":"Una versione online (inglese) di questo libro è disponibile su http://r4ds..co.nz. Continuerà evolversi tra una ristampa e l’altra del libro fisico. Il sorgente del libro è disponibile su https://github.com/hadley/r4ds o su https://github.com/lucavd/r4ds_ita_1st_ed per l’edizione italiana. Il libro è costruito su https://bookdown.org che rende facile trasformare file markdown di R HTML, PDF ed EPUB.Questo libro è stato costruito con:","code":"\nsessioninfo::session_info(c(\"tidyverse\"))\n#> ─ Session info ───────────────────────────────────────────────────────────────\n#>  setting  value\n#>  version  R version 4.2.2 (2022-10-31)\n#>  os       Ubuntu 22.04.1 LTS\n#>  system   x86_64, linux-gnu\n#>  ui       X11\n#>  language (EN)\n#>  collate  C.UTF-8\n#>  ctype    C.UTF-8\n#>  tz       UTC\n#>  date     2023-02-17\n#>  pandoc   2.19.2 @ /usr/bin/ (via rmarkdown)\n#> \n#> ─ Packages ───────────────────────────────────────────────────────────────────\n#>  package       * version    date (UTC) lib source\n#>  askpass         1.1        2019-01-13 [1] CRAN (R 4.2.2)\n#>  assertthat      0.2.1      2019-03-21 [1] CRAN (R 4.2.2)\n#>  backports       1.4.1      2021-12-13 [1] CRAN (R 4.2.2)\n#>  base64enc       0.1-3      2015-07-28 [1] CRAN (R 4.2.2)\n#>  bit             4.0.5      2022-11-15 [1] CRAN (R 4.2.2)\n#>  bit64           4.0.5      2020-08-30 [1] CRAN (R 4.2.2)\n#>  blob            1.2.3      2022-04-10 [1] CRAN (R 4.2.2)\n#>  broom           1.0.3      2023-01-25 [1] CRAN (R 4.2.2)\n#>  bslib           0.4.2.9000 2023-02-17 [1] Github (rstudio/bslib@fe41d6d)\n#>  cachem          1.0.6      2021-08-19 [1] CRAN (R 4.2.2)\n#>  callr           3.7.3      2022-11-02 [1] CRAN (R 4.2.2)\n#>  cellranger      1.1.0      2016-07-27 [1] CRAN (R 4.2.2)\n#>  cli             3.6.0      2023-01-09 [1] CRAN (R 4.2.2)\n#>  clipr           0.8.0      2022-02-22 [1] CRAN (R 4.2.2)\n#>  colorspace      2.1-0      2023-01-23 [1] CRAN (R 4.2.2)\n#>  cpp11           0.4.3      2022-10-12 [1] CRAN (R 4.2.2)\n#>  crayon          1.5.2      2022-09-29 [1] CRAN (R 4.2.2)\n#>  curl            5.0.0      2023-01-12 [1] CRAN (R 4.2.2)\n#>  data.table      1.14.8     2023-02-17 [1] CRAN (R 4.2.2)\n#>  DBI             1.1.3      2022-06-18 [1] CRAN (R 4.2.2)\n#>  dbplyr          2.3.0      2023-01-16 [1] CRAN (R 4.2.2)\n#>  digest          0.6.31     2022-12-11 [1] CRAN (R 4.2.2)\n#>  dplyr         * 1.1.0      2023-01-29 [1] CRAN (R 4.2.2)\n#>  dtplyr          1.2.2      2022-08-20 [1] CRAN (R 4.2.2)\n#>  ellipsis        0.3.2      2021-04-29 [1] CRAN (R 4.2.2)\n#>  evaluate        0.20       2023-01-17 [1] CRAN (R 4.2.2)\n#>  fansi           1.0.4      2023-01-22 [1] CRAN (R 4.2.2)\n#>  farver          2.1.1      2022-07-06 [1] CRAN (R 4.2.2)\n#>  fastmap         1.1.0      2021-01-25 [1] CRAN (R 4.2.2)\n#>  forcats       * 1.0.0      2023-01-29 [1] CRAN (R 4.2.2)\n#>  fs              1.6.1      2023-02-06 [1] CRAN (R 4.2.2)\n#>  gargle          1.3.0      2023-01-30 [1] CRAN (R 4.2.2)\n#>  generics        0.1.3      2022-07-05 [1] CRAN (R 4.2.2)\n#>  ggplot2       * 3.4.1      2023-02-10 [1] CRAN (R 4.2.2)\n#>  glue            1.6.2      2022-02-24 [1] CRAN (R 4.2.2)\n#>  googledrive     2.0.0      2021-07-08 [1] CRAN (R 4.2.2)\n#>  googlesheets4   1.0.1      2022-08-13 [1] CRAN (R 4.2.2)\n#>  gtable          0.3.1      2022-09-01 [1] CRAN (R 4.2.2)\n#>  haven           2.5.1      2022-08-22 [1] CRAN (R 4.2.2)\n#>  highr           0.10       2022-12-22 [1] CRAN (R 4.2.2)\n#>  hms             1.1.2      2022-08-19 [1] CRAN (R 4.2.2)\n#>  htmltools       0.5.4      2022-12-07 [1] CRAN (R 4.2.2)\n#>  httr            1.4.4      2022-08-17 [1] CRAN (R 4.2.2)\n#>  ids             1.0.1      2017-05-31 [1] CRAN (R 4.2.2)\n#>  isoband         0.2.7      2022-12-20 [1] CRAN (R 4.2.2)\n#>  jquerylib       0.1.4      2021-04-26 [1] CRAN (R 4.2.2)\n#>  jsonlite        1.8.4      2022-12-06 [1] CRAN (R 4.2.2)\n#>  knitr           1.42       2023-01-25 [1] CRAN (R 4.2.2)\n#>  labeling        0.4.2      2020-10-20 [1] CRAN (R 4.2.2)\n#>  lattice         0.20-45    2021-09-22 [2] CRAN (R 4.2.2)\n#>  lifecycle       1.0.3      2022-10-07 [1] CRAN (R 4.2.2)\n#>  lubridate       1.9.2      2023-02-10 [1] CRAN (R 4.2.2)\n#>  magrittr        2.0.3      2022-03-30 [1] CRAN (R 4.2.2)\n#>  MASS            7.3-58.2   2023-01-23 [1] CRAN (R 4.2.2)\n#>  Matrix          1.5-3      2022-11-11 [1] CRAN (R 4.2.2)\n#>  memoise         2.0.1      2021-11-26 [1] CRAN (R 4.2.2)\n#>  mgcv            1.8-41     2022-10-21 [2] CRAN (R 4.2.2)\n#>  mime            0.12       2021-09-28 [1] CRAN (R 4.2.2)\n#>  modelr          0.1.10     2022-11-11 [1] CRAN (R 4.2.2)\n#>  munsell         0.5.0      2018-06-12 [1] CRAN (R 4.2.2)\n#>  nlme            3.1-162    2023-01-31 [1] CRAN (R 4.2.2)\n#>  openssl         2.0.5      2022-12-06 [1] CRAN (R 4.2.2)\n#>  pillar          1.8.1      2022-08-19 [1] CRAN (R 4.2.2)\n#>  pkgconfig       2.0.3      2019-09-22 [1] CRAN (R 4.2.2)\n#>  prettyunits     1.1.1      2020-01-24 [1] CRAN (R 4.2.2)\n#>  processx        3.8.0      2022-10-26 [1] CRAN (R 4.2.2)\n#>  progress        1.2.2      2019-05-16 [1] CRAN (R 4.2.2)\n#>  ps              1.7.2      2022-10-26 [1] CRAN (R 4.2.2)\n#>  purrr         * 1.0.1      2023-01-10 [1] CRAN (R 4.2.2)\n#>  R6              2.5.1      2021-08-19 [1] CRAN (R 4.2.2)\n#>  rappdirs        0.3.3      2021-01-31 [1] CRAN (R 4.2.2)\n#>  RColorBrewer    1.1-3      2022-04-03 [1] CRAN (R 4.2.2)\n#>  readr         * 2.1.4      2023-02-10 [1] CRAN (R 4.2.2)\n#>  readxl          1.4.2      2023-02-09 [1] CRAN (R 4.2.2)\n#>  rematch         1.0.1      2016-04-21 [1] CRAN (R 4.2.2)\n#>  rematch2        2.1.2      2020-05-01 [1] CRAN (R 4.2.2)\n#>  reprex          2.0.2      2022-08-17 [1] CRAN (R 4.2.2)\n#>  rlang           1.0.6      2022-09-24 [1] CRAN (R 4.2.2)\n#>  rmarkdown       2.20       2023-01-19 [1] CRAN (R 4.2.2)\n#>  rstudioapi      0.14       2022-08-22 [1] CRAN (R 4.2.2)\n#>  rvest           1.0.3      2022-08-19 [1] CRAN (R 4.2.2)\n#>  sass            0.4.5      2023-01-24 [1] CRAN (R 4.2.2)\n#>  scales          1.2.1      2022-08-20 [1] CRAN (R 4.2.2)\n#>  selectr         0.4-2      2019-11-20 [1] CRAN (R 4.2.2)\n#>  stringi         1.7.12     2023-01-11 [1] CRAN (R 4.2.2)\n#>  stringr       * 1.5.0      2022-12-02 [1] CRAN (R 4.2.2)\n#>  sys             3.4.1      2022-10-18 [1] CRAN (R 4.2.2)\n#>  tibble        * 3.1.8      2022-07-22 [1] CRAN (R 4.2.2)\n#>  tidyr         * 1.3.0      2023-01-24 [1] CRAN (R 4.2.2)\n#>  tidyselect      1.2.0      2022-10-10 [1] CRAN (R 4.2.2)\n#>  tidyverse     * 1.3.2      2022-07-18 [1] CRAN (R 4.2.2)\n#>  timechange      0.2.0      2023-01-11 [1] CRAN (R 4.2.2)\n#>  tinytex         0.44       2023-02-01 [1] CRAN (R 4.2.2)\n#>  tzdb            0.3.0      2022-03-28 [1] CRAN (R 4.2.2)\n#>  utf8            1.2.3      2023-01-31 [1] CRAN (R 4.2.2)\n#>  uuid            1.1-0      2022-04-19 [1] CRAN (R 4.2.2)\n#>  vctrs           0.5.2      2023-01-23 [1] CRAN (R 4.2.2)\n#>  viridisLite     0.4.1      2022-08-22 [1] CRAN (R 4.2.2)\n#>  vroom           1.6.1      2023-01-22 [1] CRAN (R 4.2.2)\n#>  withr           2.5.0      2022-03-03 [1] CRAN (R 4.2.2)\n#>  xfun            0.37       2023-01-31 [1] CRAN (R 4.2.2)\n#>  xml2            1.3.3      2021-11-30 [1] CRAN (R 4.2.2)\n#>  yaml            2.3.7      2023-01-23 [1] CRAN (R 4.2.2)\n#> \n#>  [1] /home/runner/.cache/R/renv/library/r4ds_ita_1st_ed-2aac1073/R-4.2/x86_64-pc-linux-gnu\n#>  [2] /opt/R/4.2.2/lib/R/library\n#> \n#> ──────────────────────────────────────────────────────────────────────────────"},{"path":"explore-intro.html","id":"explore-intro","chapter":"2 Introduzione","heading":"2 Introduzione","text":"L’obiettivo della prima parte di questo libro è quello di farvi prendere velocità con gli strumenti di base dell’ esplorazione dei dati il più velocemente possibile. L’esplorazione dei dati è l’arte di guardare vostri dati, generare rapidamente delle ipotesi, testarle rapidamente e poi ripetere ancora e ancora e ancora. L’obiettivo dell’esplorazione dei dati è quello di generare molte piste promettenti che si possono poi esplorare più profondità.questa parte del libro imparerai alcuni strumenti utili che hanno un ritorno immediato:La visualizzazione è un ottimo punto di partenza per la programmazione R, perché il guadagno è palese: si possono fare grafici eleganti e informativi che aiutano capire dati. visualizzazione vi immergerete nella visualizzazione, imparando la struttura di base di una trama ggplot2, e potenti tecniche per trasformare dati grafici.La visualizzazione è un ottimo punto di partenza per la programmazione R, perché il guadagno è palese: si possono fare grafici eleganti e informativi che aiutano capire dati. visualizzazione vi immergerete nella visualizzazione, imparando la struttura di base di una trama ggplot2, e potenti tecniche per trasformare dati grafici.La sola visualizzazione di solito non è sufficiente, quindi trasformazione imparerete verbi chiave che vi permettono di selezionare le variabili importanti, filtrare le osservazioni chiave, creare nuove variabili e calcolare le sintesi.La sola visualizzazione di solito non è sufficiente, quindi trasformazione imparerete verbi chiave che vi permettono di selezionare le variabili importanti, filtrare le osservazioni chiave, creare nuove variabili e calcolare le sintesi.Infine, analisi esplorativa, combinerai la visualizzazione e la trasformazione con la tua curiosità e il tuo scetticismo per chiedere e rispondere domande interessanti sui dati.Infine, analisi esplorativa, combinerai la visualizzazione e la trasformazione con la tua curiosità e il tuo scetticismo per chiedere e rispondere domande interessanti sui dati.La modellazione è una parte importante del processo esplorativo, ma non hai ancora le competenze per impararla o applicarla efficacemente. Ci torneremo modelling, una volta che sarete meglio equipaggiati con più strumenti di programmazione e gestione dei dati.Nascosti tra questi tre capitoli che vi insegnano gli strumenti di esplorazione ci sono tre capitoli che si concentrano sul vostro flusso di lavoro R. workflow: basi, workflow: script, e workflow: progetti imparerete le buone pratiche per scrivere e organizzare il vostro codice R. Queste vi porteranno al successo nel lungo periodo, dato che vi daranno gli strumenti per rimanere organizzati quando affronterete progetti reali.","code":""},{"path":"visualizzazione.html","id":"visualizzazione","chapter":"3 Visualizzazione","heading":"3 Visualizzazione","text":"","code":""},{"path":"visualizzazione.html","id":"introduzione-1","chapter":"3 Visualizzazione","heading":"3.1 Introduzione","text":"“simple graph brought information data analyst’s mind\ndevice.”“Un semplice grafico ha portato alla mente dell’analista di dati più informazioni\nche qualsiasi altro strumento.” — John TukeyQuesto capitolo vi insegnerà come visualizzare vostri dati usando ggplot2. R ha diversi sistemi per creare grafici, ma ggplot2 è uno dei più eleganti e versatili. ggplot2 implementa la grammatica della grafica, un sistema coerente per descrivere e costruire grafici. Con ggplot2, si può fare di più e più velocemente imparando un sistema e applicandolo molti contesti.Se volete saperne di più sui fondamenti teorici di ggplot2 prima di iniziare, vi consiglio di leggere “Layered Grammar Graphics”, http://vita..co.nz/papers/layered-grammar.pdf.","code":""},{"path":"visualizzazione.html","id":"prerequisiti-1","chapter":"3 Visualizzazione","heading":"3.1.1 Prerequisiti","text":"Questo capitolo si concentra su ggplot2, uno dei membri principali del tidyverse. Per accedere ai set di dati, alle pagine di aiuto e alle funzioni che useremo questo capitolo, caricate il tidyverse eseguendo questo codice:Questa linea di codice carica il nucleo del tidyverse; pacchetti che userete quasi tutte le analisi dei dati. Vi dice anche quali funzioni del tidyverse sono conflitto con le funzioni R base (o da altri pacchetti che potreste aver caricato).Se eseguite questo codice e ottenete il messaggio di errore “package called ‘tidyverse’” (oppure italiano, “non c’è nessun pacchetto chiamato ‘tiduverse’”), dovrete prima installarlo, poi eseguire library() ancora una volta.È necessario installare un pacchetto solo una volta, ma è necessario ricaricarlo ogni volta che si avvia una nuova sessione.Se abbiamo bisogno di essere espliciti sulla provenienza di una funzione (o di un set di dati), useremo la forma speciale package::function(). Per esempio, ggplot2::ggplot() dice esplicitamente che stiamo usando la funzione ggplot() del pacchetto ggplot2.","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n#> ✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n#> ✔ tibble  3.1.8     ✔ dplyr   1.1.0\n#> ✔ tidyr   1.3.0     ✔ stringr 1.5.0\n#> ✔ readr   2.1.4     ✔ forcats 1.0.0\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)"},{"path":"visualizzazione.html","id":"primi-passi","chapter":"3 Visualizzazione","heading":"3.2 Primi passi","text":"Usiamo il nostro primo grafico per rispondere ad una domanda: Le auto con grandi motori usano più carburante delle auto con piccoli motori? Probabilmente avete già una risposta, ma cercate di rendere la vostra risposta precisa. Com’è la relazione tra la dimensione del motore e l’efficienza del carburante? È positiva? Negativa? Lineare? Non lineare?","code":""},{"path":"visualizzazione.html","id":"il-data-frame-mpg","chapter":"3 Visualizzazione","heading":"3.2.1 Il data frame mpg","text":"Puoi testare la tua risposta con il data frame di mpg che si trova ggplot2 (cioè ggplot2::mpg). Un data frame è una collezione rettangolare di variabili (nelle colonne) e osservazioni (nelle righe). mpg contiene osservazioni raccolte dalla US Environmental Protection Agency su 38 modelli di auto.Tra le variabili mpg ci sono:displ, la dimensione del motore di un’auto, litri.displ, la dimensione del motore di un’auto, litri.hwy, l’efficienza del carburante di un’auto autostrada, miglia per gallone (mpg).\nUn’auto con un basso rendimento del carburante consuma più carburante di un’auto con un alto\nefficienza del carburante quando percorrono la stessa distanza.hwy, l’efficienza del carburante di un’auto autostrada, miglia per gallone (mpg).\nUn’auto con un basso rendimento del carburante consuma più carburante di un’auto con un alto\nefficienza del carburante quando percorrono la stessa distanza.Per saperne di più su mpg, apri la sua pagina di aiuto eseguendo ?mpg.","code":"\nmpg\n#> # A tibble: 234 × 11\n#>   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n#>   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> \n#> 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n#> 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n#> 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n#> 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n#> 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n#> 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n#> # … with 228 more rows"},{"path":"visualizzazione.html","id":"creazione-di-un-ggplot","chapter":"3 Visualizzazione","heading":"3.2.2 Creazione di un ggplot","text":"Per tracciare mpg, esegui questo codice per mettere displ sull’asse x e hwy sull’asse y:Il grafico mostra una associazione negativa tra la dimensione del motore (displ) e l’efficienza del carburante (hwy). altre parole, le auto con grandi motori usano più carburante. Questo conferma o confuta la tua ipotesi sull’efficienza del carburante e la dimensione del motore?Con ggplot2, si inizia un grafico con la funzione ggplot(). La funzione ggplot() crea un sistema di coordinate cui è possibile aggiungere dei livelli. Il primo argomento di ggplot() è il set di dati da usare nel grafico. Quindi ggplot(data = mpg) crea un grafico vuoto, ma non è molto interessante quindi non lo mostrerò qui.Completate il vostro grafico aggiungendo uno o più livelli ggplot(). La funzione geom_point() aggiunge un livello di punti al vostro grafico, che crea uno scatterplot. ggplot2 è dotato di molte funzioni geom che aggiungono ciascuna un diverso tipo di livello ad un grafico. Ne impareremo un bel po’ questo capitolo.Ogni funzione geom ggplot2 prende un argomento mapping. Questo definisce come le variabili del tuo set di dati sono mappate alle proprietà visive. L’argomento mapping è sempre abbinato aes(), e gli argomenti x e y di aes() specificano quali variabili mappare sugli assi x e y. ggplot2 cerca le variabili mappate nell’argomento data, questo caso, mpg.","code":"\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))"},{"path":"visualizzazione.html","id":"un-modello-di-grafico","chapter":"3 Visualizzazione","heading":"3.2.3 Un modello di grafico","text":"Trasformiamo questo codice un template riutilizzabile per fare grafici con ggplot2. Per fare un grafico, sostituire le sezioni tra parentesi nel codice qui sotto con un set di dati, una funzione geom, o un insieme di mappature.Il resto di questo capitolo vi mostrerà come completare ed estendere questo modello per fare diversi tipi di grafici. Inizieremo con il componente <MAPPINGS>.","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))"},{"path":"visualizzazione.html","id":"esercizi","chapter":"3 Visualizzazione","heading":"3.2.4 Esercizi","text":"Esegui ggplot(data = mpg). Cosa vedi?Esegui ggplot(data = mpg). Cosa vedi?Quante righe ci sono mpg? Quante colonne?Quante righe ci sono mpg? Quante colonne?Cosa descrive la variabile drv? Leggete l’aiuto per ?mpg per scoprirlo\nscoprire.Cosa descrive la variabile drv? Leggete l’aiuto per ?mpg per scoprirlo\nscoprire.Fai un grafico di dispersione di hwy rispetto cyl.Fai un grafico di dispersione di hwy rispetto cyl.Cosa succede se fai un grafico di dispersione di class vs drv? Perché è\nil grafico non è utile?Cosa succede se fai un grafico di dispersione di class vs drv? Perché è\nil grafico non è utile?","code":""},{"path":"visualizzazione.html","id":"mappature-estetiche","chapter":"3 Visualizzazione","heading":"3.3 Mappature estetiche","text":"“greatest value picture forces us notice \nnever expected see.” — John Tukey“Il più grande valore di un’immagine è che ci forza notare quello che non\nci aspettavamo di vedere.” — John TukeyNel grafico qui sotto, un gruppo di punti (evidenziato rosso) sembra cadere al di fuori della tendenza lineare. Queste auto hanno un chilometraggio superiore quello che ci si potrebbe aspettare. Come puoi spiegare queste auto?Ipotizziamo che le auto siano ibride. Un modo per verificare questa ipotesi è guardare il valore di “classe” per ogni auto. La variabile class del dataset mpg classifica le auto gruppi come compatte, medie e SUV. Se punti eccesso sono auto ibride, dovrebbero essere classificati come auto compatte o, forse, auto subcompatte (tieni presente che questi dati sono stati raccolti prima che camion e SUV ibridi diventassero popolari).Si può aggiungere una terza variabile, come “classe”, ad uno scatterplot bidimensionale mappandola ad una estetica (‘aestetics’, come aes, NdT). Un’estetica è una proprietà visiva degli oggetti nel vostro grafico. Le estetiche includono cose come la dimensione, la forma o il colore dei tuoi punti. Puoi visualizzare un punto (come quello sotto) modi diversi cambiando valori delle sue proprietà estetiche. Dato che abbiamo già usato la parola “valore” per descrivere dati, usiamo la parola “livello” per descrivere le proprietà estetiche. Qui cambiamo livelli di dimensione, forma e colore di un punto per renderlo piccolo, triangolare o blu:Puoi trasmettere informazioni sui tuoi dati mappando l’estetica del tuo grafico alle variabili del tuo set di dati. Per esempio, puoi mappare colori dei tuoi punti sulla variabile class per rivelare la classe di ogni auto.(Se preferite l’inglese britannico, come Hadley, potete usare colour invece di color).Per mappare un’estetica ad una variabile, bisogna associare il nome dell’estetica al nome della variabile ’interno di aes(). ggplot2 assegnerà automaticamente un livello unico dell’estetica (qui un colore unico) ad ogni valore unico della variabile, un processo noto come scaling. ggplot2 aggiungerà anche una legenda che spiega quali livelli corrispondono quali valori.colori rivelano che molti dei punti insoliti sono auto due posti. Queste auto non sembrano ibride, e sono, infatti, auto sportive! Le auto sportive hanno grandi motori come SUV e pick-, ma corpi piccoli come le auto medie e compatte, il che migliora il loro consumo di carburante. Con il senno di poi, è improbabile che queste auto siano ibride, dato che hanno grandi motori.Nell’esempio precedente, abbiamo mappato la “classe” ’estetica del colore, ma avremmo potuto mappare la “classe” ’estetica delle dimensioni allo stesso modo. questo caso, la dimensione esatta di ogni punto rivelerebbe la sua appartenenza di classe. Abbiamo un warning (‘avviso’) qui, perché mappare una variabile non ordinata (class) ad un’estetica ordinata (size) non è una buona idea.Oppure avremmo potuto mappare class ’estetica alpha, che controlla la trasparenza dei punti, o ’estetica shape, che controlla la forma dei punti.Cosa è successo ai SUV? ggplot2 userà solo sei forme alla volta. Per impostazione predefinita, gruppi aggiuntivi non saranno tracciati quando si usa l’estetica delle forme.Per ogni estetica, si usa aes() per associare il nome dell’estetica ad una variabile da visualizzare. La funzione aes() raccoglie tutte le mappature estetiche utilizzate da un livello e le passa ’argomento di mappatura del livello. La sintassi evidenzia un’utile intuizione su x e y: le posizioni x e y di un punto sono esse stesse estetiche, proprietà visive che si possono mappare su variabili per visualizzare informazioni sui dati.Una volta mappata un’estetica, ggplot2 si occupa del resto. Seleziona una scala ragionevole da usare con l’estetica, e costruisce una legenda che spiega la mappatura tra livelli e valori. Per le estetiche x e y, ggplot2 non crea una legenda, ma crea una linea d’asse con segni di spunta e un’etichetta. La linea dell’asse funge da legenda; spiega la mappatura tra livelli e valori.Potete anche impostare manualmente le proprietà estetiche del vostro geom. Per esempio, possiamo rendere blu tutti punti del nostro grafico:Qui, il colore non trasmette informazioni su una variabile, ma cambia solo l’aspetto del grafico. Per impostare un’estetica manualmente, impostate l’estetica per nome come argomento della vostra funzione geom; cioè va fuori da aes(). Dovrete scegliere un livello che abbia senso per quell’estetica:Il nome di un colore come stringa di caratteri.Il nome di un colore come stringa di caratteri.La dimensione di un punto mm.La dimensione di un punto mm.La forma di un punto come numero, come mostrato nella figura 3.1.La forma di un punto come numero, come mostrato nella figura 3.1.\nFigure 3.1: R ha 25 forme costruite che sono identificate da numeri. Ci sono alcuni apparentemente duplicati: per esempio, 0, 15 e 22 sono tutti quadrati. La differenza deriva dall’interazione dell’estetica del colore e del riempimento. Le forme vuote (0–14) hanno un bordo determinato dal colore; le forme piene (15–20) sono riempite di colore; le forme piene (21–24) hanno un bordo di colore e sono riempite di fill.\n","code":"\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, color = class))\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, size = class))\n#> Warning: Using size for a discrete variable is not advised.\n# Sinistra\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))\n\n# Destra\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, shape = class))\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")"},{"path":"visualizzazione.html","id":"esercizi-1","chapter":"3 Visualizzazione","heading":"3.3.1 Esercizi","text":"Cosa è andato storto questo codice? Perché punti non sono blu?\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\nCosa è andato storto questo codice? Perché punti non sono blu?Quali variabili mpg sono categoriche? Quali variabili sono continue?\n(Suggerimento: digita ?mpg per leggere la documentazione del dataset). Come\npuoi vedere queste informazioni quando esegui mpg?Quali variabili mpg sono categoriche? Quali variabili sono continue?\n(Suggerimento: digita ?mpg per leggere la documentazione del dataset). Come\npuoi vedere queste informazioni quando esegui mpg?Mappate una variabile continua color, size e shape. Come si comportano\nqueste estetiche si comportano diversamente per le variabili categoriche rispetto quelle continue?\ncontinue?Mappate una variabile continua color, size e shape. Come si comportano\nqueste estetiche si comportano diversamente per le variabili categoriche rispetto quelle continue?\ncontinue?Cosa succede se si mappa la stessa variabile più estetiche?Cosa succede se si mappa la stessa variabile più estetiche?Cosa fa l’estetica stroke? Con quali forme funziona?\n(Suggerimento: usa ?geom_point)Cosa fa l’estetica stroke? Con quali forme funziona?\n(Suggerimento: usa ?geom_point)Cosa succede se si mappa un’estetica qualcosa di diverso da un\nvariabile, come aes(colour = displ < 5)? Nota, dovrai anche specificare x e y.Cosa succede se si mappa un’estetica qualcosa di diverso da un\nvariabile, come aes(colour = displ < 5)? Nota, dovrai anche specificare x e y.","code":"\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))"},{"path":"visualizzazione.html","id":"problemi-comuni","chapter":"3 Visualizzazione","heading":"3.4 Problemi comuni","text":"Man mano che iniziate ad eseguire il codice R, è probabile che vi imbattiate problemi. Non preoccupatevi, succede tutti. Ho scritto codice R per anni, e ogni giorno scrivo ancora codice che non funziona!Inizia confrontando attentamente il codice che stai eseguendo con quello del libro. R è estremamente esigente, e un carattere fuori posto può fare la differenza. Assicuratevi che ogni ( è abbinato ad un ) e ogni \" è abbinato ad un altro \". volte eseguirai il codice e non succede nulla. Controllate la parte sinistra della vostra console: se è un +, significa che R non pensa che abbiate digitato un’espressione completa e sta aspettando che la finiate. questo caso, di solito è facile ricominciare da zero premendo ESCAPE per interrompere l’elaborazione del comando corrente.Un problema comune quando si creano grafici di ggplot2 è quello di mettere il + nel posto sbagliato: deve arrivare alla fine della linea, non ’inizio. altre parole, assicuratevi di non aver accidentalmente scritto codice come questo:Se sei ancora bloccato, prova l’aiuto. Puoi ottenere aiuto su qualsiasi funzione di R eseguendo ?function_name nella console, o selezionando il nome della funzione e premendo F1 RStudio. Non preoccupatevi se l’aiuto non sembra molto utile - invece saltate giù agli esempi e cercate il codice che corrisponde quello che state cercando di fare.Se questo non aiuta, leggete attentamente il messaggio di errore. volte la risposta sarà sepolta lì! Ma quando si è nuovi di R, la risposta potrebbe essere nel messaggio di errore ma non si sa ancora come capirlo. Un altro ottimo strumento è Google: provate cercare su Google il messaggio di errore, perché è probabile che qualcun altro abbia avuto lo stesso problema e abbia trovato aiuto online.","code":"\nggplot(data = mpg) \n+ geom_point(mapping = aes(x = displ, y = hwy))"},{"path":"visualizzazione.html","id":"sfaccettature-facet","chapter":"3 Visualizzazione","heading":"3.5 Sfaccettature (‘facet’)","text":"Un modo per aggiungere variabili aggiuntive è l’estetica. Un altro modo, particolarmente utile per le variabili categoriche, è quello di dividere il vostro grafico facet, sotto-grafici che mostrano ciascuna un sottoinsieme dei dati.Per sfaccettare il vostro grafico base una singola variabile, usate facet_wrap(). Il primo argomento di facet_wrap() dovrebbe essere una formula, creata con ~ seguita da un nome di variabile (qui “formula” è il nome di una struttura dati R, non un sinonimo di “equazione”). La variabile che passate facet_wrap() dovrebbe essere discreta.Per sfaccettare il tuo grafico sulla combinazione di due variabili, aggiungi facet_grid() alla tua chiamata plot. Il primo argomento di facet_grid() è anch’esso una formula. Questa volta la formula dovrebbe contenere due nomi di variabili separati da una ~.Se preferite non fare la sfaccettatura nella dimensione delle righe o delle colonne, usate un . al posto del nome della variabile, per esempio + facet_grid(. ~ cyl).","code":"\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  facet_grid(drv ~ cyl)"},{"path":"visualizzazione.html","id":"esercizi-2","chapter":"3 Visualizzazione","heading":"3.5.1 Esercizi","text":"Cosa succede se si effettua la sfaccettatura su una variabile continua?Cosa succede se si effettua la sfaccettatura su una variabile continua?Cosa significano le celle vuote nel grafico con facet_grid(drv ~ cyl)?\nCome si riferiscono questo grafico?\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = drv, y = cyl))Cosa significano le celle vuote nel grafico con facet_grid(drv ~ cyl)?\nCome si riferiscono questo grafico?Che grafici produce il seguente codice? Cosa fa .?\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)Che grafici produce il seguente codice? Cosa fa .?Prendiamo il primo grafico sfaccettato di questa sezione:\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)\nQuali sono vantaggi di usare la sfaccettatura invece dell’estetica del colore?\nQuali sono gli svantaggi? Come potrebbe cambiare l’equilibrio se aveste un\nset di dati più grande?Prendiamo il primo grafico sfaccettato di questa sezione:Quali sono vantaggi di usare la sfaccettatura invece dell’estetica del colore?\nQuali sono gli svantaggi? Come potrebbe cambiare l’equilibrio se aveste un\nset di dati più grande?Leggi ?facet_wrap. Cosa fa nrow? Cosa fa ncol? Quali altre opzioni\nopzioni controllano la disposizione dei singoli pannelli? Perché non\nfacet_grid()ha argomenti nrow e ncol?Leggi ?facet_wrap. Cosa fa nrow? Cosa fa ncol? Quali altre opzioni\nopzioni controllano la disposizione dei singoli pannelli? Perché non\nfacet_grid()ha argomenti nrow e ncol?Quando si usa facet_grid() di solito si dovrebbe mettere la variabile con più\nlivelli unici nelle colonne. Perché?Quando si usa facet_grid() di solito si dovrebbe mettere la variabile con più\nlivelli unici nelle colonne. Perché?","code":"\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = drv, y = cyl))\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)"},{"path":"visualizzazione.html","id":"oggetti-geometrici","chapter":"3 Visualizzazione","heading":"3.6 Oggetti geometrici","text":"che modo sono simili questi due grafici?Entrambi grafici contengono la stessa variabile x, la stessa variabile y, ed entrambi descrivono gli stessi dati. Ma grafici non sono identici. Ogni grafico usa un oggetto visivo diverso per rappresentare dati. Nella sintassi di ggplot2, diciamo che usano diversi geom.Un geom è l’oggetto geometrico che un grafico usa per rappresentare dati. Le persone spesso descrivono grafici base al tipo di geom che il grafico usa. Per esempio, grafici barre usano geometrie barre, grafici linee usano geometrie linee, boxplot usano geometrie boxplot, e così via. Gli scatterplot rompono la tendenza; usano la geometria punti. Come si vede sopra, si possono usare diverse geometrie per tracciare gli stessi dati. Il grafico sinistra usa la geometria punti, mentre il grafico destra usa la geometria ‘smooth’, una linea continua adattata ai dati.Per cambiare la geometria nel vostro grafico, cambiate la funzione geom_ che aggiungete ggplot(). Per esempio, per fare grafici di cui sopra, potete usare questo codice:Ogni funzione geom ggplot2 prende un argomento mapping. Tuttavia, non ogni estetica funziona con ogni geom. Potresti impostare la forma di un punto, ma non potresti impostare la “forma” di una linea. D’altra parte, si potrebbe impostare il tipo di linea ad una linea. geom_smooth() disegnerà una linea diversa, con un diverso tipo di linea, per ogni valore unico della variabile che mappate ‘linetype’.Qui geom_smooth() separa le auto tre linee basate sul loro valore drv, che descrive la trasmissione dell’auto. Una linea descrive tutti punti con un valore 4, una linea descrive tutti punti con un valore f e una linea descrive tutti punti con un valore r. Qui, 4 sta per quattro ruote motrici, f per la trazione anteriore e r per la trazione posteriore.Se questo sembra strano, possiamo renderlo più chiaro sovrapponendo le linee ai dati grezzi e colorando il tutto secondo il drv.Notate che questo grafico contiene due geometrie nello stesso grafico! Se questo vi fa entusiasmare, allacciate le cinture. Impareremo molto presto come mettere più geom nello stesso grafico.ggplot2 fornisce oltre 40 geom, e pacchetti di estensione ne forniscono ancora di più (vedi https://exts.ggplot2.tidyverse.org/gallery/ per qualche esempio). Il modo migliore per avere una panoramica completa è il cheatsheet di ggplot2, che potete trovare http://rstudio.com/resources/cheatsheets. Per saperne di più su ogni singolo geom, usa lo strumento help: ?geom_smooth.Molti geom, come geom_smooth(), usano un singolo oggetto geometrico per visualizzare più righe di dati. Per questi geom, si può impostare l’estetica group su una variabile categorica per disegnare oggetti multipli. ggplot2 disegnerà un oggetto separato per ogni valore unico della variabile di raggruppamento. pratica, ggplot2 raggrupperà automaticamente dati per questi geom ogni volta che si mappa un’estetica ad una variabile discreta (come nell’esempio linetype). È conveniente fare affidamento su questa caratteristica perché l’estetica del gruppo da sola non aggiunge una legenda o caratteristiche distintive ai geom.Per visualizzare più geom uno stesso grafico, aggiungete più funzioni geom ggplot():Questo, tuttavia, introduce qualche duplicazione nel nostro codice. Immaginate di voler cambiare l’asse y per visualizzare cty invece di hwy. Avreste bisogno di cambiare la variabile due posti, e potreste dimenticare di aggiornarne uno. Potete evitare questo tipo di ripetizioni passando un insieme di mappature ggplot(). ggplot2 tratterà queste mappature come mappature globali che si applicano ad ogni geom nel grafico. altre parole, questo codice produrrà lo stesso grafico del codice precedente:Se si inseriscono mappature una funzione geom, ggplot2 le tratterà come mappature locali per il livello. Userà queste mappature per estendere o sovrascrivere le mappature globali per quel solo livello. Questo rende possibile la visualizzazione di diverse estetiche diversi livelli.Puoi usare la stessa idea per specificare diversi dati per ogni livello. Qui, la nostra linea continua mostra solo un sottoinsieme del dataset mpg, le auto subcompatte. L’argomento dei dati locali geom_smooth() sovrascrive l’argomento dei dati globali ggplot() solo per quel livello.(Imparerai come funziona il filter() nel capitolo sulle trasformazioni dei dati: per ora, sappi che questo comando seleziona solo le auto subcompatte).","code":"\n# left\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\n# right\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy))\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n              \nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))\n    \nggplot(data = mpg) +\n  geom_smooth(\n    mapping = aes(x = displ, y = hwy, color = drv),\n    show.legend = FALSE\n  )\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth()\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(color = class)) + \n  geom_smooth()\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(mapping = aes(color = class)) + \n  geom_smooth(data = filter(mpg, class == \"subcompact\"), se = FALSE)"},{"path":"visualizzazione.html","id":"esercizi-3","chapter":"3 Visualizzazione","heading":"3.6.1 Esercizi","text":"Quale geom. useresti per disegnare un grafico linee? Un boxplot?\nUn istogramma? Un grafico ad area?Quale geom. useresti per disegnare un grafico linee? Un boxplot?\nUn istogramma? Un grafico ad area?Eseguite questo codice nella vostra testa e prevedete come sarà l’output.\nPoi, esegui il codice R e controlla le tue previsioni.\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + \n  geom_point() + \n  geom_smooth(se = FALSE)Eseguite questo codice nella vostra testa e prevedete come sarà l’output.\nPoi, esegui il codice R e controlla le tue previsioni.Cosa fa show.legend = FALSE? Cosa succede se lo rimuovi?\nPerché pensate che l’abbia usato ’inizio del capitolo?Cosa fa show.legend = FALSE? Cosa succede se lo rimuovi?\nPerché pensate che l’abbia usato ’inizio del capitolo?Cosa fa l’argomento se di geom_smooth()?Cosa fa l’argomento se di geom_smooth()?Questi due grafici avranno un aspetto diverso? Perché/perché ?\n\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth()\n\nggplot() + \n  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))Questi due grafici avranno un aspetto diverso? Perché/perché ?Ricrea il codice R necessario per generare seguenti grafici.\nRicrea il codice R necessario per generare seguenti grafici.","code":"\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth()\n\nggplot() + \n  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))"},{"path":"visualizzazione.html","id":"trasformazioni-statistiche","chapter":"3 Visualizzazione","heading":"3.7 Trasformazioni statistiche","text":"Diamo un’occhiata un grafico barre. grafici barre sembrano semplici, ma sono interessanti perché rivelano qualcosa di sottile sui grafici. Considerate un grafico barre di base, disegnato con geom_bar(). Il seguente grafico mostra il numero totale di diamanti nel dataset diamonds, raggruppati per cut. Il dataset diamonds viene fornito ggplot2 e contiene informazioni su ~54.000 diamanti, inclusi il prezzo (‘price’), la caratura (‘carat’), il colore (‘color’), la chiarezza (‘clarity’) e il taglio (‘cut’) di ogni diamante. Il grafico mostra che sono disponibili più diamanti con tagli di alta qualità che con tagli di bassa qualità.Sull’asse x, il grafico mostra cut, una variabile di diamonds. Sull’asse y, mostra il conteggio, ma il conteggio non è una variabile diamonds! Da dove viene il conteggio? Molti grafici, come gli scatterplot, tracciano valori grezzi del tuo set di dati. Altri grafici, come grafici barre, calcolano nuovi valori da tracciare:grafici barre, gli istogrammi e poligoni di frequenza classificano tuoi dati\ne poi tracciano conteggi dei bin (‘contenitore’), il numero di punti che rientrano ogni bin.grafici barre, gli istogrammi e poligoni di frequenza classificano tuoi dati\ne poi tracciano conteggi dei bin (‘contenitore’), il numero di punti che rientrano ogni bin.Gli smoothers adattano un modello ai tuoi dati e poi tracciano le previsioni del\nmodello.Gli smoothers adattano un modello ai tuoi dati e poi tracciano le previsioni del\nmodello.boxplot calcolano un robusto riassunto della distribuzione e poi mostrano un\nriquadro appositamente formattato.boxplot calcolano un robusto riassunto della distribuzione e poi mostrano un\nriquadro appositamente formattato.L’algoritmo usato per calcolare nuovi valori per un grafico è chiamato stat, abbreviazione di trasformazione statistica. La figura sottostante descrive come funziona questo processo con geom_bar().Puoi sapere quale stat usa un geom ispezionando il valore di default per l’argomento stat. Per esempio, ?geom_bar mostra che il valore di default per stat è “count”, il che significa che geom_bar() usa stat_count(). stat_count() è documentato nella stessa pagina di geom_bar(), e se scorri basso puoi trovare una sezione chiamata “Computed variables”. Questa descrive come calcola due nuove variabili: count e prop.Generalmente puoi usare geom e stats modo intercambiabile. Per esempio, puoi ricreare il grafico precedente usando stat_count() invece di geom_bar():Questo funziona perché ogni geom ha una stat predefinita; e ogni stat ha una geom predefinita. Questo significa che genere si possono usare geom senza preoccuparsi della trasformazione statistica sottostante. Ci sono tre ragioni per cui potreste aver bisogno di usare una stat esplicitamente:Si potrebbe voler sovrascrivere la stat di default. Nel codice qui sotto, cambio\nla stat di geom_bar() da count (il default) identity. Questo mi permette di\nQuesto mi permette di mappare l’altezza delle barre ai valori grezzi di una variabile \\(y\\).\nSfortunatamente quando la gente parla di grafici barre, potrebbe\nriferirsi questo tipo di grafico barre, dove l’altezza della barra è già\npresente nei dati, o al precedente grafico barre dove l’altezza della barra\nè generata dal conteggio delle righe.\n\ndemo <- tribble(\n  ~cut,         ~freq,\n  \"Fair\",       1610,\n  \"Good\",       4906,\n  \"Good\",  12082,\n  \"Premium\",    13791,\n  \"Ideal\",      21551\n)\n\nggplot(data = demo) +\n  geom_bar(mapping = aes(x = cut, y = freq), stat = \"identity\")\n\n(Non preoccupatevi di non aver visto <- o tribble() prima. Potresti\nindovinare il loro significato dal contesto, e presto imparerai esattamente\ncosa fanno!)Si potrebbe voler sovrascrivere la stat di default. Nel codice qui sotto, cambio\nla stat di geom_bar() da count (il default) identity. Questo mi permette di\nQuesto mi permette di mappare l’altezza delle barre ai valori grezzi di una variabile \\(y\\).\nSfortunatamente quando la gente parla di grafici barre, potrebbe\nriferirsi questo tipo di grafico barre, dove l’altezza della barra è già\npresente nei dati, o al precedente grafico barre dove l’altezza della barra\nè generata dal conteggio delle righe.(Non preoccupatevi di non aver visto <- o tribble() prima. Potresti\nindovinare il loro significato dal contesto, e presto imparerai esattamente\ncosa fanno!)Potreste voler sovrascrivere la mappatura predefinita dalle variabili trasformate\n’estetica. Per esempio, potreste voler visualizzare un grafico barre di\nproporzioni, piuttosto che il conteggio:\n\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))\n#> Warning: `stat(prop)` deprecated ggplot2 3.4.0.\n#> ℹ Please use `after_stat(prop)` instead.\n\nPer trovare le variabili calcolate dalla stat, cercate la sezione di aiuto\nintitolata “computed variables”.Potreste voler sovrascrivere la mappatura predefinita dalle variabili trasformate\n’estetica. Per esempio, potreste voler visualizzare un grafico barre di\nproporzioni, piuttosto che il conteggio:Per trovare le variabili calcolate dalla stat, cercate la sezione di aiuto\nintitolata “computed variables”.Potreste voler prestare maggiore attenzione alla trasformazione statistica\nnel vostro codice. Per esempio, potreste usare stat_summary(), che\nriassume valori y per ogni unico valore x, per attirare\nl’attenzione sul sommario che state calcolando:\n\nggplot(data = diamonds) + \n  stat_summary(\n    mapping = aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )\nPotreste voler prestare maggiore attenzione alla trasformazione statistica\nnel vostro codice. Per esempio, potreste usare stat_summary(), che\nriassume valori y per ogni unico valore x, per attirare\nl’attenzione sul sommario che state calcolando:ggplot2 fornisce oltre 20 statistiche da usare. Ogni stat è una funzione, quindi si può ottenere aiuto nel solito modo, ad esempio ?stat_bin. Per vedere l’elenco completo delle statistiche, provate il cheatsheet di ggplot2.","code":"\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut))\nggplot(data = diamonds) + \n  stat_count(mapping = aes(x = cut))\ndemo <- tribble(\n  ~cut,         ~freq,\n  \"Fair\",       1610,\n  \"Good\",       4906,\n  \"Very Good\",  12082,\n  \"Premium\",    13791,\n  \"Ideal\",      21551\n)\n\nggplot(data = demo) +\n  geom_bar(mapping = aes(x = cut, y = freq), stat = \"identity\")\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))\n#> Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `after_stat(prop)` instead.\nggplot(data = diamonds) + \n  stat_summary(\n    mapping = aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )"},{"path":"visualizzazione.html","id":"esercizi-4","chapter":"3 Visualizzazione","heading":"3.7.1 Esercizi","text":"Qual è il geom di default associato stat_summary()? Come potreste\nriscrivere il grafico precedente per usare quella funzione geom al posto della funzione\nfunzione stat?Qual è il geom di default associato stat_summary()? Come potreste\nriscrivere il grafico precedente per usare quella funzione geom al posto della funzione\nfunzione stat?Cosa fa geom_col()? che modo è diverso da geom_bar()?Cosa fa geom_col()? che modo è diverso da geom_bar()?La maggior parte dei geom e delle statistiche sono coppia e vengono quasi sempre usati \nconcerto. Leggete la documentazione e fate una lista di tutte le\ncoppie. Cosa hanno comune?La maggior parte dei geom e delle statistiche sono coppia e vengono quasi sempre usati \nconcerto. Leggete la documentazione e fate una lista di tutte le\ncoppie. Cosa hanno comune?Quali variabili calcola stat_smooth()? Quali parametri controllano\nil suo comportamento?Quali variabili calcola stat_smooth()? Quali parametri controllano\nil suo comportamento?Nel nostro grafico barre proporzionali, dobbiamo impostare group = 1. Perché? altre\naltre parole, qual è il problema di questi due grafici?\n\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))Nel nostro grafico barre proporzionali, dobbiamo impostare group = 1. Perché? altre\naltre parole, qual è il problema di questi due grafici?","code":"\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = after_stat(prop)))\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = color, y = after_stat(prop)))"},{"path":"visualizzazione.html","id":"regolazioni-di-posizione","chapter":"3 Visualizzazione","heading":"3.8 Regolazioni di posizione","text":"C’è un altro pezzo di magia associato ai grafici barre. Puoi colorare un grafico barre usando l’estetica colour o, più utilmente, fill:Notate cosa succede se si mappa l’estetica di riempimento ad un’altra variabile, come clarity: le barre sono automaticamente impilate. Ogni rettangolo colorato rappresenta una combinazione di cut e clarity.L’impilamento viene eseguito automaticamente dalla regolazione della posizione specificata dall’argomento position. Se non vuoi un grafico barre impilate, puoi usare una delle altre tre opzioni: \"identity\", \"dodge\" o \"fill\".position = \"identity\" posizionerà ogni oggetto esattamente dove cade nel\ncontesto del grafico. Questo non è molto utile per le barre, perché\nle sovrappone. Per vedere la sovrapposizione dobbiamo rendere le barre\nleggermente trasparenti impostando alpha ad un piccolo valore, o completamente\ntrasparente impostando fill = NA.\n\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\nggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + \n  geom_bar(fill = NA, position = \"identity\")\n\nLa regolazione della posizione dell’identità è più utile per geom 2d, come punti,\ndove è il default.position = \"identity\" posizionerà ogni oggetto esattamente dove cade nel\ncontesto del grafico. Questo non è molto utile per le barre, perché\nle sovrappone. Per vedere la sovrapposizione dobbiamo rendere le barre\nleggermente trasparenti impostando alpha ad un piccolo valore, o completamente\ntrasparente impostando fill = NA.La regolazione della posizione dell’identità è più utile per geom 2d, come punti,\ndove è il default.position = \"fill\" funziona come l’impilamento, ma rende ogni serie di barre impilate\ndella stessa altezza. Questo rende più facile confrontare le proporzioni tra\ngruppi.\n\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\")\nposition = \"fill\" funziona come l’impilamento, ma rende ogni serie di barre impilate\ndella stessa altezza. Questo rende più facile confrontare le proporzioni tra\ngruppi.position = \"dodge\" posiziona gli oggetti sovrapposti direttamente fianco, uno accanto ’altro. Questo rende più facile confrontare valori individuali.\n\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\")\nposition = \"dodge\" posiziona gli oggetti sovrapposti direttamente fianco, uno accanto ’altro. Questo rende più facile confrontare valori individuali.C’è un altro tipo di regolazione che non è utile per grafici barre, ma può essere molto utile per gli scatterplot. Ricordate il nostro primo grafico di dispersione. Avete notato che il grafico mostra solo 126 punti, anche se ci sono 234 osservazioni nel set di dati?valori di hwy e displ sono arrotondati così punti appaiono su una griglia e molti punti si sovrappongono l’un l’altro. Questo problema è noto come overplotting. Questa disposizione rende difficile vedere dove si trova la massa dei dati. punti dei dati sono distribuiti equamente tutto il grafico, o c’è una combinazione speciale di hwy e displ che contiene 109 valori?Puoi evitare questa sovrapposizione impostando la regolazione della posizione su “jitter”. position = \"jitter\" aggiunge una piccola quantità di rumore casuale ad ogni punto. Questo disperde punti perché non è probabile che due punti ricevano la stessa quantità di rumore casuale.L’aggiunta di casualità sembra uno strano modo per migliorare il vostro grafico, ma mentre rende il vostro grafico meno accurato piccole scale, lo rende più rivelatore grandi scale. Poiché questa è un’operazione così utile, ggplot2 ha un’abbreviazione per geom_point(position = \"jitter\"): geom_jitter().Per saperne di più su una regolazione di posizione, guarda la pagina di aiuto associata ad ogni regolazione: ?position_dodge, ?position_fill, ?position_identity, ?position_jitter, e ?position_stack.","code":"\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, colour = cut))\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = cut))\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity))\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + \n  geom_bar(alpha = 1/5, position = \"identity\")\nggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + \n  geom_bar(fill = NA, position = \"identity\")\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\")\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\")\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\")"},{"path":"visualizzazione.html","id":"esercizi-5","chapter":"3 Visualizzazione","heading":"3.8.1 Esercizi","text":"Qual è il problema di questo grafico? Come potresti migliorarlo?\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + \n  geom_point()\nQual è il problema di questo grafico? Come potresti migliorarlo?Quali parametri di geom_jitter() controllano la quantità di jittering?Quali parametri di geom_jitter() controllano la quantità di jittering?Confrontate e contrastate geom_jitter() con geom_count().Confrontate e contrastate geom_jitter() con geom_count().Qual è la regolazione predefinita della posizione per geom_boxplot()? Create\nuna visualizzazione del dataset mpg che lo dimostri.\nQual è la regolazione predefinita della posizione per geom_boxplot()? Create\nuna visualizzazione del dataset mpg che lo dimostri.","code":"\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + \n  geom_point()"},{"path":"visualizzazione.html","id":"sistemi-di-coordinate","chapter":"3 Visualizzazione","heading":"3.9 Sistemi di coordinate","text":"sistemi di coordinate sono probabilmente la parte più complicata di ggplot2. Il sistema di coordinate predefinito è il sistema di coordinate cartesiane dove le posizioni x e y agiscono indipendentemente per determinare la posizione di ogni punto. Ci sono un certo numero di altri sistemi di coordinate che sono occasionalmente utili.coord_flip() commuta gli assi x e y. Questo è utile (per esempio),\nse volete dei boxplot orizzontali. È anche utile per le etichette lunghe: è\ndifficile farle entrare senza sovrapporle sull’asse x.\n\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot() +\n  coord_flip()\ncoord_flip() commuta gli assi x e y. Questo è utile (per esempio),\nse volete dei boxplot orizzontali. È anche utile per le etichette lunghe: è\ndifficile farle entrare senza sovrapporle sull’asse x.coord_quickmap() imposta correttamente il rapporto di aspetto per le mappe. Questo è molto\nimportante se state tracciando dati spaziali con ggplot2 (che purtroppo\nnon abbiamo lo spazio per trattare questo libro).\n\nnz <- map_data(\"nz\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\ncoord_quickmap() imposta correttamente il rapporto di aspetto per le mappe. Questo è molto\nimportante se state tracciando dati spaziali con ggplot2 (che purtroppo\nnon abbiamo lo spazio per trattare questo libro).coord_polar() usa coordinate polari. Le coordinate polari rivelano un’interessante\ninteressante connessione tra un grafico barre e un grafico Coxcomb.\n\nbar <- ggplot(data = diamonds) + \n  geom_bar(\n    mapping = aes(x = cut, fill = cut), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()\nbar + coord_polar()\ncoord_polar() usa coordinate polari. Le coordinate polari rivelano un’interessante\ninteressante connessione tra un grafico barre e un grafico Coxcomb.","code":"\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot() +\n  coord_flip()\nnz <- map_data(\"nz\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\nggplot(nz, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\nbar <- ggplot(data = diamonds) + \n  geom_bar(\n    mapping = aes(x = cut, fill = cut), \n    show.legend = FALSE,\n    width = 1\n  ) + \n  theme(aspect.ratio = 1) +\n  labs(x = NULL, y = NULL)\n\nbar + coord_flip()\nbar + coord_polar()"},{"path":"visualizzazione.html","id":"esercizi-6","chapter":"3 Visualizzazione","heading":"3.9.1 Esercizi","text":"Trasformare un grafico barre impilato un grafico torta usando coord_polar().Trasformare un grafico barre impilato un grafico torta usando coord_polar().Cosa fa labs()? Leggete la documentazione.Cosa fa labs()? Leggete la documentazione.Qual è la differenza tra coord_quickmap() e coord_map()?Qual è la differenza tra coord_quickmap() e coord_map()?Cosa vi dice il grafico qui sotto sulla relazione tra città\ne autostrada? Perché è importante la funzione coord_fixed()? Che cosa fa\ngeom_abline() fa?\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()\nCosa vi dice il grafico qui sotto sulla relazione tra città\ne autostrada? Perché è importante la funzione coord_fixed()? Che cosa fa\ngeom_abline() fa?","code":"\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()"},{"path":"visualizzazione.html","id":"la-grammatica-a-strati-dei-grafici","chapter":"3 Visualizzazione","heading":"3.10 La grammatica a strati dei grafici","text":"Nelle sezioni precedenti, si è imparato molto di più che come fare scatterplot, grafici barre e boxplot. Avete imparato una base che potete usare per fare qualsiasi tipo di grafico con ggplot2. Per vedere questo, aggiungiamo regolazioni di posizione, statistiche, sistemi di coordinate e sfaccettature al nostro modello di codice:Il nostro nuovo modello richiede sette parametri, le parole tra parentesi che appaiono nel modello. pratica, raramente avrete bisogno di fornire tutti e sette parametri per fare un grafico, perché ggplot2 fornirà utili impostazioni predefinite per tutto tranne che per dati, le mappature e la funzione geom.sette parametri nel modello compongono la grammatica dei grafici, un sistema formale per costruire grafici. La grammatica della grafica si basa sull’intuizione che è possibile descrivere modo univoco qualsiasi grafico come una combinazione di un insieme di dati, un geom, un insieme di mappature, uno stat, una regolazione della posizione, un sistema di coordinate e uno schema di sfaccettatura.Per vedere come funziona, considerate come potreste costruire una grafico di base da zero: potreste iniziare con un set di dati e poi trasformarlo nelle informazioni che volete visualizzare (con una stat).Poi, potreste scegliere un oggetto geometrico per rappresentare ogni osservazione nei dati trasformati. Potreste poi usare le proprietà estetiche dei geom. per rappresentare le variabili nei dati. Dovreste mappare valori di ogni variabile ai livelli di un’estetica.Poi si seleziona un sistema di coordinate cui posizionare geom. Useresti la posizione degli oggetti (che è di per sé una proprietà estetica) per visualizzare valori delle variabili x e y. quel punto, avreste un grafico completo, ma potreste regolare ulteriormente le posizioni dei geom ’interno del sistema di coordinate (un aggiustamento di posizione) o dividere il grafico sottografici (faceting). Potreste anche estendere il grafico aggiungendo uno o più livelli aggiuntivi, dove ogni livello aggiuntivo utilizza un set di dati, un geom, un set di mappature, una statistica e una regolazione della posizione.Potreste usare questo metodo per costruire qualsiasi grafico che immaginiate. altre parole, potete usare il modello di codice che avete imparato questo capitolo per costruire centinaia di migliaia di grafici uniche.","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <COORDINATE_FUNCTION> +\n  <FACET_FUNCTION>"},{"path":"workflow-basi.html","id":"workflow-basi","chapter":"4 Workflow: basi","heading":"4 Workflow: basi","text":"Ora hai un po’ di esperienza nell’esecuzione del codice R. Non vi abbiamo dato molti dettagli, ma ovviamente avete capito le basi, o avreste buttato via questo libro per la frustrazione! La frustrazione è naturale quando si inizia programmare R, perché è così pignolo per la punteggiatura, e anche un solo carattere fuori posto causerà una lamentela. Ma mentre dovreste aspettarvi di essere un po’ frustrati, consolatevi con il fatto che è sia tipico che temporaneo: succede tutti, e l’unico modo per superarlo è continuare provare.Prima di andare avanti, assicuriamoci che abbiate una solida base nell’esecuzione del codice R, e che conosciate alcune delle caratteristiche più utili di RStudio.","code":""},{"path":"workflow-basi.html","id":"basi-di-codifica","chapter":"4 Workflow: basi","heading":"4.1 Basi di codifica","text":"Rivediamo alcune nozioni di base che abbiamo finora omesso nell’interesse di farvi tracciare grafici il più velocemente possibile. Potete usare R come una calcolatrice:Puoi creare nuovi oggetti con <-:Tutte le istruzioni di R cui si creano oggetti, le istruzioni di assegnazione, hanno la stessa forma:Quando leggete quel codice dite “il nome dell’oggetto ottiene il valore” nella vostra testa.Farete molte assegnazioni e <- è un dolore da digitare. Non siate pigri e usate =: funzionerà, ma causerà confusione seguito. Invece, usa la scorciatoia da tastiera di RStudio: Alt + - (il segno meno). Notate che RStudio circonda automaticamente <- con spazi, che è una buona pratica di formattazione del codice. Il codice è penoso da leggere una buona giornata, quindi datevi tregua e usate gli spazi.","code":"\n1 / 200 * 30\n#> [1] 0.15\n(59 + 73 + 2) / 3\n#> [1] 44.66667\nsin(pi / 2)\n#> [1] 1\nx <- 3 * 4\nobject_name <- value"},{"path":"workflow-basi.html","id":"cosa-cè-in-un-nome","chapter":"4 Workflow: basi","heading":"4.2 Cosa c’è in un nome?","text":"nomi degli oggetti devono iniziare con una lettera e possono contenere solo lettere, numeri, _ e .. Vuoi che nomi dei tuoi oggetti siano descrittivi, quindi avrai bisogno di una convenzione per le parole multiple. Noi raccomandiamo snake_case dove separi le parole minuscole con _.Torneremo sullo stile del codice più tardi, funzioni.Si può ispezionare un oggetto digitando il suo nome:Facciamo un’altra assegnazione:Per ispezionare questo oggetto, provate la funzione di completamento di RStudio: digitate “”, premete TAB, aggiungete caratteri fino ad avere un prefisso unico, poi premete return.Ooops, hai fatto un errore! this_is_a_really_long_name dovrebbe avere valore 3.5 non 2.5. Usa un’altra scorciatoia da tastiera per aiutarti correggerlo. Digita “” e poi premi Cmd/Ctrl + ↑. Questo elencherà tutti comandi che hai digitato che iniziano con quelle lettere. Usa tasti freccia per navigare, poi premi enter per ridigitare il comando. Cambia 2.5 3.5 e rilancia.Facciamo un’altra assegnazione:Proviamo ad ispezionarlo:C’è un contratto implicito tra voi e R: esso farà il noioso calcolo per voi, ma cambio voi dovete essere completamente precisi nelle vostre istruzioni. Gli errori di battitura contano. Le maiuscole contano.","code":"\nio_uso_lo_snake_case\naltrePersoneUsanoIlCamelCase\nalcune.persone.usano.i.punti\nE_poche.Persone_RINUNCIANO.Alle_convenzioni\nx\n#> [1] 12\nthis_is_a_really_long_name <- 2.5\nr_rocks <- 2 ^ 3\nr_rock\n#> Error: object 'r_rock' not found\nR_rocks\n#> Error: object 'R_rocks' not found"},{"path":"workflow-basi.html","id":"chiamare-le-funzioni","chapter":"4 Workflow: basi","heading":"4.3 Chiamare le funzioni","text":"R ha una vasta collezione di funzioni integrate che vengono chiamate questo modo:Proviamo ad usare seq() che fa regolari sequenze di numeri e, mentre ci siamo, impariamo altre utili caratteristiche di RStudio. Digitate se e premete TAB. Un popup vi mostra possibili completamenti. Specificate seq() digitando più (una “q”) per disambiguare, o usando le frecce ↑/↓ per selezionare. Notate il tooltip galleggiante che appare, ricordandovi gli argomenti e lo scopo della funzione. Se volete più aiuto, premete F1 per ottenere tutti dettagli nella scheda Aiuto (‘Help’) nel pannello basso destra.Premete ancora una volta TAB quando avete selezionato la funzione che volete. RStudio aggiungerà le corrispondenti parentesi di apertura (() e di chiusura ()) per voi. Digitate gli argomenti 1, 10 e premete invio.Digitate questo codice e notate che ottenete un’assistenza simile con le virgolette accoppiate:Le virgolette e le parentesi devono sempre essere coppia. RStudio fa del suo meglio per aiutarvi, ma è ancora possibile sbagliare e finire con una mancata corrispondenza. Se questo accade, R vi mostrerà il carattere di continuazione “+”:Il + vi dice che R sta aspettando altri input; non pensa che abbiate già finito. Di solito significa che avete dimenticato un \" o un ). O aggiungi la coppia mancante, o premi ESC per interrompere l’espressione e riprovare.Se fai un’assegnazione, non puoi vedere il valore. Sei quindi tentato di ricontrollare immediatamente il risultato:Questa azione comune può essere abbreviata circondando l’assegnazione con delle parentesi, il che provoca l’assegnazione e la “stampa schermo”.Ora guarda il tuo environment (‘ambiente di lavoro’) nel riquadro alto destra:Qui puoi vedere tutti gli oggetti che hai creato.","code":"\nfunction_name(arg1 = val1, arg2 = val2, ...)\nseq(1, 10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nx <- \"hello world\"> x <- \"hello\n+\ny <- seq(1, 10, length.out = 5)\ny\n#> [1]  1.00  3.25  5.50  7.75 10.00\n(y <- seq(1, 10, length.out = 5))\n#> [1]  1.00  3.25  5.50  7.75 10.00"},{"path":"workflow-basi.html","id":"esercizi-7","chapter":"4 Workflow: basi","heading":"4.4 Esercizi","text":"Perché questo codice non funziona?4\n\nmy_variable <- 10\nmy_varıable\n#> Error eval(expr, envir, enclos): object 'my_varıable' foundPerché questo codice non funziona?4Guardate attentamente! (Questo può sembrare un esercizio inutile, ma\nallenare il vostro cervello notare anche la più piccola differenza vi ripagherà\nquando si programma).Modificate ciascuno dei seguenti comandi R modo che vengano eseguiti correttamente:\n\nlibrary(tidyverse)\n\nggplot(dota = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\nfliter(mpg, cyl = 8)\nfilter(diamond, carat > 3)Modificate ciascuno dei seguenti comandi R modo che vengano eseguiti correttamente:Premi Alt + Shift + K. Cosa succede? Come puoi arrivare allo stesso punto\nusando menu?Premi Alt + Shift + K. Cosa succede? Come puoi arrivare allo stesso punto\nusando menu?","code":"\nmy_variable <- 10\nmy_varıable\n#> Error in eval(expr, envir, enclos): object 'my_varıable' not found\nlibrary(tidyverse)\n\nggplot(dota = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\nfliter(mpg, cyl = 8)\nfilter(diamond, carat > 3)"},{"path":"transform.html","id":"transform","chapter":"5 Trasformazione","heading":"5 Trasformazione","text":"","code":""},{"path":"transform.html","id":"introduzione-2","chapter":"5 Trasformazione","heading":"5.1 Introduzione","text":"La visualizzazione è uno strumento importante per la generare intuizioni, ma è raro che si ottengano dati esattamente nella forma giusta di cui si ha bisogno. Spesso avrete bisogno di creare nuove variabili o sommari, o forse volete solo rinominare le variabili o riordinare le osservazioni per rendere dati un po’ più facili da lavorare. Imparerete come fare tutto questo (e molto di più!) questo capitolo, che vi insegnerà come trasformare vostri dati usando il pacchetto dplyr e un nuovo set di dati sui voli partenza da New York City nel 2013.","code":""},{"path":"transform.html","id":"prerequisiti-2","chapter":"5 Trasformazione","heading":"5.1.1 Prerequisiti","text":"questo capitolo ci concentreremo su come utilizzare il pacchetto dplyr, un altro membro fondamentale del tidyverse. Illustreremo le idee chiave usando dati del pacchetto nycflights13 e useremo ggplot2 per aiutarci capire dati.Fai attenzione al messaggio di conflitto che viene stampato quando carichi il tidyverse. Ti dice che dplyr sovrascrive alcune funzioni R base. Se vuoi usare la versione base di queste funzioni dopo aver caricato dplyr, dovrai usare loro nomi completi: stats::filter() e stats::lag().","code":"\nlibrary(nycflights13)\nlibrary(tidyverse)"},{"path":"transform.html","id":"nycflights13","chapter":"5 Trasformazione","heading":"5.1.2 nycflights13","text":"Per esplorare verbi di base di manipolazione dei dati di dplyr, useremo nycflights13::flights. Questo data frame contiene tutti voli 336,776 che sono partiti da New York City nel 2013. dati provengono dall’US Bureau Transportation Statistics, ed è documentato ?flights.Potreste notare che questo data frame viene visualizzato console modo un po’ diverso da altri data frame che potreste aver usato passato: mostra solo le prime righe e tutte le colonne che stanno uno schermo. (Per vedere l’intero dataset, potete eseguire View(flights) che aprirà il dataset nel visualizzatore di RStudio). Si ‘stampa’ (video) modo diverso perché è un tibble. tibble sono data frame, ma leggermente modificati per funzionare meglio nel tidyverse. Per ora, non dovete preoccuparvi delle differenze; torneremo sui tibble modo più dettagliato wrangle.Potreste anche aver notato la fila di abbreviazioni di tre (o quattro) lettere sotto nomi delle colonne. Queste descrivono il tipo di ogni variabile:int sta per gli interi.int sta per gli interi.dbl sta per doppi, o numeri reali.dbl sta per doppi, o numeri reali.chr sta per vettori di caratteri, o stringhe.chr sta per vettori di caratteri, o stringhe.dttm sta per data-ora (una data + un’ora).dttm sta per data-ora (una data + un’ora).Ci sono altri tre tipi comuni di variabili che non sono usati questo set di dati ma che incontrerete più avanti nel libro:lgl sta per logico, vettori che contengono solo TRUE o FALSE.lgl sta per logico, vettori che contengono solo TRUE o FALSE.fctr sta per fattori, che R usa per rappresentare variabili categoriche\ncon possibili valori fissi.fctr sta per fattori, che R usa per rappresentare variabili categoriche\ncon possibili valori fissi.date sta per le date.date sta per le date.","code":"\nflights\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay"},{"path":"transform.html","id":"basi-del-dplyr","chapter":"5 Trasformazione","heading":"5.1.3 Basi del dplyr","text":"questo capitolo imparerete le cinque funzioni chiave di dplyr che vi permettono di risolvere la maggior parte delle vostre sfide di manipolazione dei dati:Scegliere le osservazioni base ai loro valori (filter()).Riordinare le righe (arrange()).Scegliere le variabili base ai loro nomi (select()).Creare nuove variabili con funzioni di variabili esistenti (mutate()).Collassare molti valori un singolo sommario (summarise()).Tutte queste funzioni possono essere usate insieme group_by() che cambia lo scopo di ogni funzione dall’operare sull’intero set di dati ’operare su di esso gruppo per gruppo. Queste sei funzioni forniscono verbi per un linguaggio di manipolazione dei dati.Tutti verbi funzionano modo simile:Il primo argomento è un data frame.Il primo argomento è un data frame.Gli argomenti successivi descrivono cosa fare con il data frame,\nusando nomi delle variabili (senza virgolette).Gli argomenti successivi descrivono cosa fare con il data frame,\nusando nomi delle variabili (senza virgolette).Il risultato è un nuovo data frame.Il risultato è un nuovo data frame.Insieme queste proprietà rendono facile concatenare più passi semplici per ottenere un risultato complesso. Immergiamoci e vediamo come funzionano questi verbi.","code":""},{"path":"transform.html","id":"filtrare-le-righe-con-filter","chapter":"5 Trasformazione","heading":"5.2 Filtrare le righe con filter()","text":"La funzione filter() permette di selezionare le osservazioni base ai loro valori. Il primo argomento è il nome del data frame. Il secondo e successivi argomenti sono le espressioni che filtrano il data frame. Per esempio, possiamo selezionare tutti voli del 1° gennaio con:Quando esegui quella linea di codice, dplyr esegue l’operazione di filtraggio e restituisce un nuovo data frame. Le funzioni dplyr non modificano mai loro input, quindi se vuoi salvare il risultato, dovrai usare l’operatore di assegnazione, <-:R stampa risultati o li salva una variabile. Se volete fare entrambe le cose, potete avvolgere l’assegnazione tra parentesi:","code":"\nfilter(flights, month == 1, day == 1)\n#> # A tibble: 842 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … with 836 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\njan1 <- filter(flights, month == 1, day == 1)\n(dec25 <- filter(flights, month == 12, day == 25))\n#> # A tibble: 719 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013    12    25      456         500      -4     649     651      -2 US     \n#> 2  2013    12    25      524         515       9     805     814      -9 UA     \n#> 3  2013    12    25      542         540       2     832     850     -18 AA     \n#> 4  2013    12    25      546         550      -4    1022    1027      -5 B6     \n#> 5  2013    12    25      556         600      -4     730     745     -15 AA     \n#> 6  2013    12    25      557         600      -3     743     752      -9 DL     \n#> # … with 713 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay"},{"path":"transform.html","id":"confronti","chapter":"5 Trasformazione","heading":"5.2.1 Confronti","text":"Per usare efficacemente il filtraggio, dovete sapere come selezionare le osservazioni che volete usando gli operatori di confronto. R fornisce la serie standard: >, >=, <, <=, != (non uguale), e == (uguale).Quando sei agli inizi con R, l’errore più facile da fare è usare = invece di == quando si verifica l’uguaglianza. Quando questo accade otterrete un errore informativo:C’è un altro problema comune che potresti incontrare quando usi ==: numeri virgola mobile. Questi risultati potrebbero sorprenderti!computer usano l’aritmetica precisione finita (ovviamente non possono memorizzare un numero infinito di cifre!) quindi ricordate che ogni numero che vedete è un’approssimazione. Invece di fare affidamento su ==, usa near():","code":"\nfilter(flights, month = 1)\n#> Error in `filter()`:\n#> ! We detected a named input.\n#> ℹ This usually means that you've used `=` instead of `==`.\n#> ℹ Did you mean `month == 1`?\nsqrt(2) ^ 2 == 2\n#> [1] FALSE\n1 / 49 * 49 == 1\n#> [1] FALSE\nnear(sqrt(2) ^ 2,  2)\n#> [1] TRUE\nnear(1 / 49 * 49, 1)\n#> [1] TRUE"},{"path":"transform.html","id":"operatori-logici","chapter":"5 Trasformazione","heading":"5.2.2 Operatori logici","text":"Gli argomenti multipli di filter() sono combinati con “”: ogni espressione deve essere vera perché una riga sia inclusa nell’output. Per altri tipi di combinazioni, dovrai usare tu stesso gli operatori booleani: & è “”, | è “”, e ! è “”. La figura 5.1 mostra l’insieme completo delle operazioni booleane.\nFigure 5.1: Set completo di operazioni booleane. x è il cerchio di sinistra, y è il cerchio di destra, e la regione ombreggiata mostra quali parti ogni operatore seleziona.\nIl seguente codice trova tutti voli che sono partiti novembre o dicembre:L’ordine delle operazioni non funziona come l’italiano. Non potete scrivere filter(flights, month == (11 | 12)), che potreste tradurre letteralmente “trova tutti voli che sono partiti novembre o dicembre”. Invece trova tutti mesi che sono uguali 11 | 12, un’espressione che valuta TRUE. un contesto numerico (come qui), TRUE diventa uno, quindi questo comando trova tutti voli gennaio, non novembre o dicembre. Il tutto è abbastanza confondente!Un’utile abbreviazione per questo problema è x %% y. Questo selezionerà ogni riga dove x è uno dei valori y. Potremmo usarla per riscrivere il codice sopra:volte puoi semplificare sottoinsiemi complicati ricordando la legge di De Morgan: !(x & y) è uguale !x | !y, e !(x | y) è uguale !x & !y. Per esempio, se vuoi trovare voli che non sono stati ritardo (’arrivo o alla partenza) di più di due ore, puoi usare uno dei due filtri seguenti:Oltre & e |, R ha anche && e ||. Non usateli qui! Imparerete quando dovreste usarli esecuzione condizionale.Ogni volta che iniziate ad usare espressioni complicate e composte da più parti filter(), considerate invece di renderle variabili esplicite. Questo rende molto più facile controllare il vostro lavoro. Imparerai breve come creare nuove variabili.","code":"\nfilter(flights, month == 11 | month == 12)\nnov_dec <- filter(flights, month %in% c(11, 12))\nfilter(flights, !(arr_delay > 120 | dep_delay > 120))\nfilter(flights, arr_delay <= 120, dep_delay <= 120)"},{"path":"transform.html","id":"valori-mancanti","chapter":"5 Trasformazione","heading":"5.2.3 Valori mancanti","text":"Una caratteristica importante di R che può rendere difficile il confronto sono valori mancanti, o NAs (“availables”). NA rappresenta un valore sconosciuto quindi valori mancanti sono “contagiosi”: quasi ogni operazione che coinvolge un valore sconosciuto sarà anch’essa sconosciuta.Il risultato più disorientante è questo:È più facile capire perché questo è vero con un po’ più di contesto:Se volete determinare se un valore è mancante, usate .na():filter() include solo le righe cui la condizione è TRUE; esclude sia valori FALSE che NA. Se vuoi conservare valori mancanti, chiedili esplicitamente:","code":"\nNA > 5\n#> [1] NA\n10 == NA\n#> [1] NA\nNA + 10\n#> [1] NA\nNA / 2\n#> [1] NA\nNA == NA\n#> [1] NA\n# Sia x l'età di Mary. Non sappiamo quanti anni ha.\nx <- NA\n\n# Sia y l'età di John. Non sappiamo quanti anni ha.\ny <- NA\n\n# John e Mary hanno la stessa età?\nx == y\n#> [1] NA\n# Non lo sappiamo!\nis.na(x)\n#> [1] TRUE\ndf <- tibble(x = c(1, NA, 3))\nfilter(df, x > 1)\n#> # A tibble: 1 × 1\n#>       x\n#>   <dbl>\n#> 1     3\nfilter(df, is.na(x) | x > 1)\n#> # A tibble: 2 × 1\n#>       x\n#>   <dbl>\n#> 1    NA\n#> 2     3"},{"path":"transform.html","id":"esercizi-8","chapter":"5 Trasformazione","heading":"5.2.4 Esercizi","text":"Trovi tutti voli che\nHanno avuto un ritardo ’arrivo di due o più ore\nHanno volato Houston (IAH o HOU)\nSono stati operati da United, American o Delta\nSono partiti estate (luglio, agosto e settembre)\nSono arrivati con più di due ore di ritardo, ma non sono partiti ritardo\nHanno subito un ritardo di almeno un’ora, ma hanno recuperato più di 30 minuti di volo\nSono partiti tra mezzanotte e le 6 del mattino (compreso)\nTrovi tutti voli cheHanno avuto un ritardo ’arrivo di due o più oreHanno volato Houston (IAH o HOU)Sono stati operati da United, American o DeltaSono partiti estate (luglio, agosto e settembre)Sono arrivati con più di due ore di ritardo, ma non sono partiti ritardoHanno subito un ritardo di almeno un’ora, ma hanno recuperato più di 30 minuti di voloSono partiti tra mezzanotte e le 6 del mattino (compreso)Un altro utile helper di filtraggio di dplyr è (). Cosa fa?\nPuoi usarlo per semplificare il codice necessario per rispondere alle\nsfide precedenti?Un altro utile helper di filtraggio di dplyr è (). Cosa fa?\nPuoi usarlo per semplificare il codice necessario per rispondere alle\nsfide precedenti?Quanti voli hanno un dep_time mancante? Quali altre variabili sono\nmancanti? Cosa potrebbero rappresentare queste righe?Quanti voli hanno un dep_time mancante? Quali altre variabili sono\nmancanti? Cosa potrebbero rappresentare queste righe?Perché la variabile NA ^ 0 non è mancante? 2. Perché NA | TRUE non è mancante?\nPerché FALSE & NA non è mancante? Puoi capire la\nregola generale? (NA * 0 è un controesempio insidioso!)\nPerché la variabile NA ^ 0 non è mancante? 2. Perché NA | TRUE non è mancante?Perché FALSE & NA non è mancante? Puoi capire la\nregola generale? (NA * 0 è un controesempio insidioso!)","code":""},{"path":"transform.html","id":"organizzare-le-righe-con-arrange","chapter":"5 Trasformazione","heading":"5.3 Organizzare le righe con arrange()","text":"Arrange()funziona modo simile afilter()` tranne che invece di selezionare le righe, cambia il loro ordine. Prende un frame di dati e un insieme di nomi di colonne (o espressioni più complicate) da ordinare. Se fornite più di un nome di colonna, ogni colonna aggiuntiva sarà usata per rompere legami nei valori delle colonne precedenti:Usa desc() per riordinare una colonna ordine decrescente:valori mancanti sono sempre ordinati alla fine:","code":"\narrange(flights, year, month, day)\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\narrange(flights, desc(dep_delay))\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     9      641         900    1301    1242    1530    1272 HA     \n#> 2  2013     6    15     1432        1935    1137    1607    2120    1127 MQ     \n#> 3  2013     1    10     1121        1635    1126    1239    1810    1109 MQ     \n#> 4  2013     9    20     1139        1845    1014    1457    2210    1007 AA     \n#> 5  2013     7    22      845        1600    1005    1044    1815     989 MQ     \n#> 6  2013     4    10     1100        1900     960    1342    2211     931 DL     \n#> # … with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\ndf <- tibble(x = c(5, 2, NA))\narrange(df, x)\n#> # A tibble: 3 × 1\n#>       x\n#>   <dbl>\n#> 1     2\n#> 2     5\n#> 3    NA\narrange(df, desc(x))\n#> # A tibble: 3 × 1\n#>       x\n#>   <dbl>\n#> 1     5\n#> 2     2\n#> 3    NA"},{"path":"transform.html","id":"esercizi-9","chapter":"5 Trasformazione","heading":"5.3.1 Esercizi","text":"Come potreste usare arrange() per ordinare tutti valori mancanti ’inizio?\n(Suggerimento: usate .na()).Come potreste usare arrange() per ordinare tutti valori mancanti ’inizio?\n(Suggerimento: usate .na()).Ordina flights per trovare voli più ritardo. Trova voli che\nsono partiti prima.Ordina flights per trovare voli più ritardo. Trova voli che\nsono partiti prima.Ordina voli per trovare voli più veloci.Ordina voli per trovare voli più veloci.Quali voli hanno viaggiato più lontano? Quali hanno viaggiato più brevemente?Quali voli hanno viaggiato più lontano? Quali hanno viaggiato più brevemente?","code":""},{"path":"transform.html","id":"select","chapter":"5 Trasformazione","heading":"5.4 Seleziona le colonne con select()","text":"Non è raro avere serie di dati con centinaia o addirittura migliaia di variabili. questo caso, la prima sfida è spesso quella di restringere le variabili cui si è effettivamente interessati. La funzione select() permette di zoomare rapidamente su un sottoinsieme utile usando operazioni basate sui nomi delle variabili.La funzione select() non è estremamente utile con dati dei voli perché abbiamo solo 19 variabili, ma potete comunque farvi un’idea generale:Ci sono un certo numero di funzioni di aiuto che potete usare ’interno di select():starts_with(\"abc\"): corrisponde ai nomi che iniziano con “abc”.starts_with(\"abc\"): corrisponde ai nomi che iniziano con “abc”.ends_with(\"xyz\"): corrisponde ai nomi che finiscono con “xyz”.ends_with(\"xyz\"): corrisponde ai nomi che finiscono con “xyz”.contains(\"ijk\"): corrisponde ai nomi che contengono “ijk”.contains(\"ijk\"): corrisponde ai nomi che contengono “ijk”.matches(\"(.)\\1\"): seleziona le variabili che corrispondono un’espressione regolare.\nQuesto corrisponde tutte le variabili che contengono caratteri ripetuti. Imparerete\nimparerete di più sulle espressioni regolari stringhe.matches(\"(.)\\1\"): seleziona le variabili che corrispondono un’espressione regolare.\nQuesto corrisponde tutte le variabili che contengono caratteri ripetuti. Imparerete\nimparerete di più sulle espressioni regolari stringhe.num_range(\"x\", 1:3): corrisponde x1, x2 e x3.num_range(\"x\", 1:3): corrisponde x1, x2 e x3.Vedi ?select per maggiori dettagli.select() può essere usato per rinominare le variabili, ma è raramente utile perché elimina tutte le variabili non esplicitamente menzionate. Usate invece rename(), che è una variante di select() che mantiene tutte le variabili che non sono esplicitamente menzionate:Un’altra opzione è quella di usare select() insieme ’helper everything(). Questo è utile se hai una manciata di variabili che vorresti spostare ’inizio del data frame.","code":"\n# Seleziona le colonne per nome\nselect(flights, year, month, day)\n#> # A tibble: 336,776 × 3\n#>    year month   day\n#>   <int> <int> <int>\n#> 1  2013     1     1\n#> 2  2013     1     1\n#> 3  2013     1     1\n#> 4  2013     1     1\n#> 5  2013     1     1\n#> 6  2013     1     1\n#> # … with 336,770 more rows\n# Seleziona tutte le colonne tra l'anno e il giorno (incluso)\nselect(flights, year:day)\n#> # A tibble: 336,776 × 3\n#>    year month   day\n#>   <int> <int> <int>\n#> 1  2013     1     1\n#> 2  2013     1     1\n#> 3  2013     1     1\n#> 4  2013     1     1\n#> 5  2013     1     1\n#> 6  2013     1     1\n#> # … with 336,770 more rows\n# Seleziona tutte le colonne tranne quelle dall'anno al giorno (incluso)\nselect(flights, -(year:day))\n#> # A tibble: 336,776 × 16\n#>   dep_time sched…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier flight tailnum origin\n#>      <int>   <int>   <dbl>   <int>   <int>   <dbl> <chr>    <int> <chr>   <chr> \n#> 1      517     515       2     830     819      11 UA        1545 N14228  EWR   \n#> 2      533     529       4     850     830      20 UA        1714 N24211  LGA   \n#> 3      542     540       2     923     850      33 AA        1141 N619AA  JFK   \n#> 4      544     545      -1    1004    1022     -18 B6         725 N804JB  JFK   \n#> 5      554     600      -6     812     837     -25 DL         461 N668DN  LGA   \n#> 6      554     558      -4     740     728      12 UA        1696 N39463  EWR   \n#> # … with 336,770 more rows, 6 more variables: dest <chr>, air_time <dbl>,\n#> #   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, and abbreviated\n#> #   variable names ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time,\n#> #   ⁵​arr_delay\nrename(flights, tail_num = tailnum)\n#> # A tibble: 336,776 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … with 336,770 more rows, 9 more variables: flight <int>, tail_num <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\nselect(flights, time_hour, air_time, everything())\n#> # A tibble: 336,776 × 19\n#>   time_hour           air_time  year month   day dep_t…¹ sched…² dep_d…³ arr_t…⁴\n#>   <dttm>                 <dbl> <int> <int> <int>   <int>   <int>   <dbl>   <int>\n#> 1 2013-01-01 05:00:00      227  2013     1     1     517     515       2     830\n#> 2 2013-01-01 05:00:00      227  2013     1     1     533     529       4     850\n#> 3 2013-01-01 05:00:00      160  2013     1     1     542     540       2     923\n#> 4 2013-01-01 05:00:00      183  2013     1     1     544     545      -1    1004\n#> 5 2013-01-01 06:00:00      116  2013     1     1     554     600      -6     812\n#> 6 2013-01-01 05:00:00      150  2013     1     1     554     558      -4     740\n#> # … with 336,770 more rows, 10 more variables: sched_arr_time <int>,\n#> #   arr_delay <dbl>, carrier <chr>, flight <int>, tailnum <chr>, origin <chr>,\n#> #   dest <chr>, distance <dbl>, hour <dbl>, minute <dbl>, and abbreviated\n#> #   variable names ¹​dep_time, ²​sched_dep_time, ³​dep_delay, ⁴​arr_time"},{"path":"transform.html","id":"esercizi-10","chapter":"5 Trasformazione","heading":"5.4.1 Esercizi","text":"Cerca il maggior numero possibile di modi per selezionare dep_time, dep_delay,\narr_time e arr_delay da flights.Cerca il maggior numero possibile di modi per selezionare dep_time, dep_delay,\narr_time e arr_delay da flights.Cosa succede se includi il nome di una variabile più volte \nuna chiamata select()?Cosa succede se includi il nome di una variabile più volte \nuna chiamata select()?Cosa fa la funzione any_of()? Perché potrebbe essere utile congiunzione\ncon questo vettore?\n\nvars <- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")Cosa fa la funzione any_of()? Perché potrebbe essere utile congiunzione\ncon questo vettore?Il risultato dell’esecuzione del seguente codice vi sorprende? Come trattano le maiuscole le funzioni di aiuto di\nselect modo predefinito? Come si può cambiare questo default?\n\nselect(flights, contains(\"TIME\"))Il risultato dell’esecuzione del seguente codice vi sorprende? Come trattano le maiuscole le funzioni di aiuto di\nselect modo predefinito? Come si può cambiare questo default?","code":"\nvars <- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\nselect(flights, contains(\"TIME\"))"},{"path":"transform.html","id":"aggiungere-nuove-variabili-con-mutate","chapter":"5 Trasformazione","heading":"5.5 Aggiungere nuove variabili con mutate()","text":"Oltre selezionare insiemi di colonne esistenti, è spesso utile aggiungere nuove colonne che sono funzioni di colonne esistenti. Questo è il compito di mutate().La funzione mutate() aggiunge sempre nuove colonne alla fine del vostro dataset, quindi inizieremo creando un dataset più piccolo modo da poter vedere le nuove variabili. Ricordate che quando siete RStudio, il modo più semplice per vedere tutte le colonne è View().Nota che puoi fare riferimento alle colonne che hai appena creato:Se volete mantenere solo le nuove variabili, usate transmute():","code":"\nflights_sml <- select(flights, \n  year:day, \n  ends_with(\"delay\"), \n  distance, \n  air_time\n)\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  speed = distance / air_time * 60\n)\n#> # A tibble: 336,776 × 9\n#>    year month   day dep_delay arr_delay distance air_time  gain speed\n#>   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>\n#> 1  2013     1     1         2        11     1400      227    -9  370.\n#> 2  2013     1     1         4        20     1416      227   -16  374.\n#> 3  2013     1     1         2        33     1089      160   -31  408.\n#> 4  2013     1     1        -1       -18     1576      183    17  517.\n#> 5  2013     1     1        -6       -25      762      116    19  394.\n#> 6  2013     1     1        -4        12      719      150   -16  288.\n#> # … with 336,770 more rows\nmutate(flights_sml,\n  gain = dep_delay - arr_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n#> # A tibble: 336,776 × 10\n#>    year month   day dep_delay arr_delay distance air_time  gain hours gain_per…¹\n#>   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>      <dbl>\n#> 1  2013     1     1         2        11     1400      227    -9  3.78      -2.38\n#> 2  2013     1     1         4        20     1416      227   -16  3.78      -4.23\n#> 3  2013     1     1         2        33     1089      160   -31  2.67     -11.6 \n#> 4  2013     1     1        -1       -18     1576      183    17  3.05       5.57\n#> 5  2013     1     1        -6       -25      762      116    19  1.93       9.83\n#> 6  2013     1     1        -4        12      719      150   -16  2.5       -6.4 \n#> # … with 336,770 more rows, and abbreviated variable name ¹​gain_per_hour\ntransmute(flights,\n  gain = dep_delay - arr_delay,\n  hours = air_time / 60,\n  gain_per_hour = gain / hours\n)\n#> # A tibble: 336,776 × 3\n#>    gain hours gain_per_hour\n#>   <dbl> <dbl>         <dbl>\n#> 1    -9  3.78         -2.38\n#> 2   -16  3.78         -4.23\n#> 3   -31  2.67        -11.6 \n#> 4    17  3.05          5.57\n#> 5    19  1.93          9.83\n#> 6   -16  2.5          -6.4 \n#> # … with 336,770 more rows"},{"path":"transform.html","id":"mutate-funs","chapter":"5 Trasformazione","heading":"5.5.1 Funzioni utili per creare variabili","text":"Ci sono molte funzioni per creare nuove variabili che potete usare con mutate(). La proprietà chiave è che la funzione deve essere vettorializzata: deve prendere un vettore di valori come input, restituire un vettore con lo stesso numero di valori come output. Non c’è modo di elencare tutte le possibili funzioni che potreste usare, ma ecco una selezione di funzioni che sono spesso utili:Operatori aritmetici: +, -, *, /, ^. Questi sono tutti vettorializzati,\nusando le cosiddette “regole di riciclaggio”. Se un parametro è più corto dell’altro,\nsarà automaticamente esteso per avere la stessa lunghezza. E’\nmolto utile quando uno degli argomenti è un singolo numero: air_time / 60,\nore * 60 + minuti, ecc.\nGli operatori aritmetici sono utili anche combinazione con le funzioni\nche imparerete seguito. Per esempio, x / sum(x) calcola\nla proporzione di un totale, e y - mean(y) calcola la differenza dalla\nla media.Operatori aritmetici: +, -, *, /, ^. Questi sono tutti vettorializzati,\nusando le cosiddette “regole di riciclaggio”. Se un parametro è più corto dell’altro,\nsarà automaticamente esteso per avere la stessa lunghezza. E’\nmolto utile quando uno degli argomenti è un singolo numero: air_time / 60,\nore * 60 + minuti, ecc.Gli operatori aritmetici sono utili anche combinazione con le funzioni\nche imparerete seguito. Per esempio, x / sum(x) calcola\nla proporzione di un totale, e y - mean(y) calcola la differenza dalla\nla media.Aritmetica modulare: %/% (divisione intera) e %% (resto), dove\nx == y * (x %/% y) + (x %% y). L’aritmetica modulare è uno strumento utile perché\nti permette di spezzare gli interi pezzi. Per esempio, nel set di dati\nvoli, puoi calcolare ora e minuto da dep_time con:\n\ntransmute(flights,\n  dep_time,\n  hour = dep_time %/% 100,\n  minute = dep_time %% 100\n)\n#> # tibble: 336,776 × 3\n#>   dep_time  hour minute\n#>      <int> <dbl>  <dbl>\n#> 1      517     5     17\n#> 2      533     5     33\n#> 3      542     5     42\n#> 4      544     5     44\n#> 5      554     5     54\n#> 6      554     5     54\n#> # … 336,770 rowsAritmetica modulare: %/% (divisione intera) e %% (resto), dove\nx == y * (x %/% y) + (x %% y). L’aritmetica modulare è uno strumento utile perché\nti permette di spezzare gli interi pezzi. Per esempio, nel set di dati\nvoli, puoi calcolare ora e minuto da dep_time con:Logaritmi: log(), log2(), log10(). logaritmi sono una trasformazione incredibilmente utile\nper trattare con dati che spaziano su più ordini di\ngrandezza. Essi convertono anche relazioni moltiplicative additive, una\ncaratteristica su cui torneremo nella modellazione.\nparità di condizioni, raccomando di usare log2() perché è facile da\ninterpretare: una differenza di 1 sulla scala log corrisponde al raddoppio sulla\nscala originale e una differenza di -1 corrisponde al dimezzamento.Logaritmi: log(), log2(), log10(). logaritmi sono una trasformazione incredibilmente utile\nper trattare con dati che spaziano su più ordini di\ngrandezza. Essi convertono anche relazioni moltiplicative additive, una\ncaratteristica su cui torneremo nella modellazione.parità di condizioni, raccomando di usare log2() perché è facile da\ninterpretare: una differenza di 1 sulla scala log corrisponde al raddoppio sulla\nscala originale e una differenza di -1 corrisponde al dimezzamento.Offset: lead() e lag() vi permettono di fare riferimento valori testa o coda\nvalori. Questo vi permette di calcolare le differenze correnti (ad esempio, x - lag(x))\no trovare quando valori cambiano (x != lag(x)). Sono molto utili \ninsieme group_by(), che imparerete conoscere tra poco.\n\n(x <- 1:10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nlag(x)\n#>  [1] NA  1  2  3  4  5  6  7  8  9\nlead(x)\n#>  [1]  2  3  4  5  6  7  8  9 10 NAOffset: lead() e lag() vi permettono di fare riferimento valori testa o coda\nvalori. Questo vi permette di calcolare le differenze correnti (ad esempio, x - lag(x))\no trovare quando valori cambiano (x != lag(x)). Sono molto utili \ninsieme group_by(), che imparerete conoscere tra poco.Aggregati cumulativi e rotativi: R fornisce funzioni per eseguire somme,\nprodotti, minimi e massimi: cumsum(), cumprod(), cummin(), cummax();\ne dplyr fornisce cummean() per le medie cumulative. Se avete bisogno di aggregati rotativi\n(cioè una somma calcolata su una finestra mobile), provate il pacchetto RcppRoll.\n\nx\n#>  [1]  1  2  3  4  5  6  7  8  9 10\ncumsum(x)\n#>  [1]  1  3  6 10 15 21 28 36 45 55\ncummean(x)\n#>  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5Aggregati cumulativi e rotativi: R fornisce funzioni per eseguire somme,\nprodotti, minimi e massimi: cumsum(), cumprod(), cummin(), cummax();\ne dplyr fornisce cummean() per le medie cumulative. Se avete bisogno di aggregati rotativi\n(cioè una somma calcolata su una finestra mobile), provate il pacchetto RcppRoll.Confronti logici: <, <=, >, >=, !=, e ==, che hai imparato\nprima. Se stai facendo una complessa sequenza di operazioni logiche è\nspesso una buona idea memorizzare valori intermedi nuove variabili modo da poter\ncontrollare che ogni passo funzioni come previsto.Confronti logici: <, <=, >, >=, !=, e ==, che hai imparato\nprima. Se stai facendo una complessa sequenza di operazioni logiche è\nspesso una buona idea memorizzare valori intermedi nuove variabili modo da poter\ncontrollare che ogni passo funzioni come previsto.Rango: ci sono un certo numero di funzioni per ranghi, ma si dovrebbe\niniziare con min_rank(). Esegue il tipo più usuale di classifica\n(es. 1°, 2°, 2°, 4°). Il default dà ai valori più piccoli il più piccolo dei\nranghi; usate desc(x) per dare ai valori più grandi ranghi più piccoli.\n\ny <- c(1, 2, 2, NA, 3, 4)\nmin_rank(y)\n#> [1]  1  2  2 NA  4  5\nmin_rank(desc(y))\n#> [1]  5  3  3 NA  2  1\nSe min_rank() non fa ciò di cui avete bisogno, guardate le varianti\nrow_number(), dense_rank(), percent_rank(), cume_dist(),\nntile(). Vedi le loro pagine di aiuto per maggiori dettagli.\n\nrow_number(y)\n#> [1]  1  2  3 NA  4  5\ndense_rank(y)\n#> [1]  1  2  2 NA  3  4\npercent_rank(y)\n#> [1] 0.00 0.25 0.25   NA 0.75 1.00\ncume_dist(y)\n#> [1] 0.2 0.6 0.6  NA 0.8 1.0Rango: ci sono un certo numero di funzioni per ranghi, ma si dovrebbe\niniziare con min_rank(). Esegue il tipo più usuale di classifica\n(es. 1°, 2°, 2°, 4°). Il default dà ai valori più piccoli il più piccolo dei\nranghi; usate desc(x) per dare ai valori più grandi ranghi più piccoli.Se min_rank() non fa ciò di cui avete bisogno, guardate le varianti\nrow_number(), dense_rank(), percent_rank(), cume_dist(),\nntile(). Vedi le loro pagine di aiuto per maggiori dettagli.","code":"\ntransmute(flights,\n  dep_time,\n  hour = dep_time %/% 100,\n  minute = dep_time %% 100\n)\n#> # A tibble: 336,776 × 3\n#>   dep_time  hour minute\n#>      <int> <dbl>  <dbl>\n#> 1      517     5     17\n#> 2      533     5     33\n#> 3      542     5     42\n#> 4      544     5     44\n#> 5      554     5     54\n#> 6      554     5     54\n#> # … with 336,770 more rows\n(x <- 1:10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nlag(x)\n#>  [1] NA  1  2  3  4  5  6  7  8  9\nlead(x)\n#>  [1]  2  3  4  5  6  7  8  9 10 NA\nx\n#>  [1]  1  2  3  4  5  6  7  8  9 10\ncumsum(x)\n#>  [1]  1  3  6 10 15 21 28 36 45 55\ncummean(x)\n#>  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5\ny <- c(1, 2, 2, NA, 3, 4)\nmin_rank(y)\n#> [1]  1  2  2 NA  4  5\nmin_rank(desc(y))\n#> [1]  5  3  3 NA  2  1\nrow_number(y)\n#> [1]  1  2  3 NA  4  5\ndense_rank(y)\n#> [1]  1  2  2 NA  3  4\npercent_rank(y)\n#> [1] 0.00 0.25 0.25   NA 0.75 1.00\ncume_dist(y)\n#> [1] 0.2 0.6 0.6  NA 0.8 1.0"},{"path":"transform.html","id":"esercizi-11","chapter":"5 Trasformazione","heading":"5.5.2 Esercizi","text":"Attualmente dep_time e sched_dep_time sono comodi da guardare, ma\ndifficili da calcolare perché non sono realmente numeri continui.\nConvertirli una rappresentazione più conveniente del numero di minuti\ndalla mezzanotte.Attualmente dep_time e sched_dep_time sono comodi da guardare, ma\ndifficili da calcolare perché non sono realmente numeri continui.\nConvertirli una rappresentazione più conveniente del numero di minuti\ndalla mezzanotte.Confronta air_time con arr_time - dep_time. Cosa ti aspetti di vedere?\nCosa vedi? Cosa devi fare per risolvere il problema?Confronta air_time con arr_time - dep_time. Cosa ti aspetti di vedere?\nCosa vedi? Cosa devi fare per risolvere il problema?Confronta dep_time, sched_dep_time e dep_delay. Come ti aspetteresti\naspettarti che questi tre numeri siano correlati?Confronta dep_time, sched_dep_time e dep_delay. Come ti aspetteresti\naspettarti che questi tre numeri siano correlati?Trova 10 voli più ritardo usando una funzione di classifica. Come vuoi\ngestire pareggi? Leggete attentamente la documentazione per min_rank().Trova 10 voli più ritardo usando una funzione di classifica. Come vuoi\ngestire pareggi? Leggete attentamente la documentazione per min_rank().Cosa restituisce 1:3 + 1:10? Perché?Cosa restituisce 1:3 + 1:10? Perché?Quali funzioni trigonometriche fornisce R?Quali funzioni trigonometriche fornisce R?","code":""},{"path":"transform.html","id":"summary-funs","chapter":"5 Trasformazione","heading":"5.6 Riassunti raggruppati con summarise()","text":"L’ultimo verbo chiave è summarise(). Esso collassa un frame di dati una singola riga:(Torneremo breve sul significato di quel na.rm = TRUE).La funzione summarise() non è estremamente utile meno che non la accoppiamo con la funzione group_by(). Questo cambia l’unità di analisi dall’intero set di dati ai singoli gruppi. Quindi, quando usate verbi di dplyr su un data frame raggruppato, essi saranno automaticamente applicati “per gruppo”. Per esempio, se applicassimo esattamente lo stesso codice un data frame raggruppato per data, otterremmo il ritardo medio per data:Insieme group_by() e summarise() forniscono uno degli strumenti che userete più comunemente quando lavorate con dplyr: sommari raggruppati. Ma prima di andare avanti con questo, dobbiamo introdurre una nuova potente idea: la pipe.","code":"\nsummarise(flights, delay = mean(dep_delay, na.rm = TRUE))\n#> # A tibble: 1 × 1\n#>   delay\n#>   <dbl>\n#> 1  12.6\nby_day <- group_by(flights, year, month, day)\nsummarise(by_day, delay = mean(dep_delay, na.rm = TRUE))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day delay\n#>   <int> <int> <int> <dbl>\n#> 1  2013     1     1 11.5 \n#> 2  2013     1     2 13.9 \n#> 3  2013     1     3 11.0 \n#> 4  2013     1     4  8.95\n#> 5  2013     1     5  5.73\n#> 6  2013     1     6  7.15\n#> # … with 359 more rows"},{"path":"transform.html","id":"combinare-più-operazioni-con-la-pipe","chapter":"5 Trasformazione","heading":"5.6.1 Combinare più operazioni con la ‘pipe’","text":"Immaginate di voler esplorare la relazione tra la distanza e il ritardo medio per ogni località. Usando quello che sapete su dplyr, potreste scrivere del codice come questo:Ci sono tre passi per preparare questi dati:Raggruppare voli per destinazione.Raggruppare voli per destinazione.Riassumere per calcolare la distanza, il ritardo medio e il numero di voli.Riassumere per calcolare la distanza, il ritardo medio e il numero di voli.Filtrare per rimuovere punti ‘rumorosi’ e l’aeroporto di Honolulu, che è quasi\ndue volte più lontano del prossimo aeroporto più vicino.Filtrare per rimuovere punti ‘rumorosi’ e l’aeroporto di Honolulu, che è quasi\ndue volte più lontano del prossimo aeroporto più vicino.Questo codice è un po’ frustrante da scrivere perché dobbiamo dare un nome ad ogni data frame intermedio, anche se non ci interessa. Dare un nome alle cose è difficile, quindi questo rallenta la nostra analisi.C’è un altro modo per affrontare lo stesso problema con la pipe (‘condotta’ o ‘tubatura’), %>%:Questo si concentra sulle trasformazioni, non su ciò che viene trasformato, il che rende il codice più facile da leggere. Potete leggerlo come una serie di dichiarazioni imperative: raggruppare, poi riassumere, poi filtrare. Come suggerito da questa lettura, un buon modo di pronunciare %>% quando si legge il codice è “poi”.Dietro le quinte, x %>% f(y) si trasforma f(x, y), e x %>% f(y) %>% g(z) si trasforma g(f(x, y), z) e così via. Puoi usare la pipe per riscrivere operazioni multiple modo da poterle leggere da sinistra destra, dall’alto basso. Useremo spesso la pipe d’ora poi perché migliora considerevolmente la leggibilità del codice, e torneremo su di esso modo più dettagliato pipe.Lavorare con la pipe è uno dei criteri chiave per appartenere al tidyverse. L’unica eccezione è ggplot2: è stato scritto prima che la pipe fosse scoperta. Sfortunatamente, la prossima iterazione di ggplot2, ggvis, che usa la pipe, non è ancora pronta per il prime time.","code":"\nby_dest <- group_by(flights, dest)\ndelay <- summarise(by_dest,\n  count = n(),\n  dist = mean(distance, na.rm = TRUE),\n  delay = mean(arr_delay, na.rm = TRUE)\n)\ndelay <- filter(delay, count > 20, dest != \"HNL\")\n\n# Sembra che i ritardi aumentino con la distanza fino a ~750 miglia \n# e poi diminuiscono. Forse quando i voli diventano più lunghi c'è più \n# capacità di recuperare i ritardi in volo?\nggplot(data = delay, mapping = aes(x = dist, y = delay)) +\n  geom_point(aes(size = count), alpha = 1/3) +\n  geom_smooth(se = FALSE)\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\ndelays <- flights %>% \n  group_by(dest) %>% \n  summarise(\n    count = n(),\n    dist = mean(distance, na.rm = TRUE),\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) %>% \n  filter(count > 20, dest != \"HNL\")"},{"path":"transform.html","id":"valori-mancanti-1","chapter":"5 Trasformazione","heading":"5.6.2 Valori mancanti","text":"Vi sarete chiesti quale sia l’argomento na.rm che abbiamo usato sopra. Cosa succede se non lo impostiamo?Abbiamo un sacco di valori mancanti! Questo perché le funzioni di aggregazione obbediscono alla solita regola dei valori mancanti: se c’è un qualsiasi valore mancante nell’input, l’output sarà un valore mancante. Fortunatamente, tutte le funzioni di aggregazione hanno un argomento na.rm che rimuove valori mancanti prima del calcolo:questo caso, dove valori mancanti rappresentano voli cancellati, potremmo anche affrontare il problema rimuovendo prima voli cancellati. Salveremo questo set di dati modo da poterlo riutilizzare nei prossimi esempi.","code":"\nflights %>% \n  group_by(year, month, day) %>% \n  summarise(mean = mean(dep_delay))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day  mean\n#>   <int> <int> <int> <dbl>\n#> 1  2013     1     1    NA\n#> 2  2013     1     2    NA\n#> 3  2013     1     3    NA\n#> 4  2013     1     4    NA\n#> 5  2013     1     5    NA\n#> 6  2013     1     6    NA\n#> # … with 359 more rows\nflights %>% \n  group_by(year, month, day) %>% \n  summarise(mean = mean(dep_delay, na.rm = TRUE))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day  mean\n#>   <int> <int> <int> <dbl>\n#> 1  2013     1     1 11.5 \n#> 2  2013     1     2 13.9 \n#> 3  2013     1     3 11.0 \n#> 4  2013     1     4  8.95\n#> 5  2013     1     5  5.73\n#> 6  2013     1     6  7.15\n#> # … with 359 more rows\nnot_cancelled <- flights %>% \n  filter(!is.na(dep_delay), !is.na(arr_delay))\n\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(mean = mean(dep_delay))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day  mean\n#>   <int> <int> <int> <dbl>\n#> 1  2013     1     1 11.4 \n#> 2  2013     1     2 13.7 \n#> 3  2013     1     3 10.9 \n#> 4  2013     1     4  8.97\n#> 5  2013     1     5  5.73\n#> 6  2013     1     6  7.15\n#> # … with 359 more rows"},{"path":"transform.html","id":"dati-di-conteggio","chapter":"5 Trasformazione","heading":"5.6.3 Dati di conteggio","text":"Ogni volta che fate un’aggregazione, è sempre una buona idea includere o un conteggio (n()), o un conteggio dei valori non mancanti (sum(!.na(x))). questo modo potete controllare che non stiate traendo conclusioni basate su quantità molto piccole di dati. Per esempio, guardiamo gli aerei (identificati dal loro numero di coda) che hanno ritardi medi più alti:Wow, ci sono alcuni aerei che hanno un ritardo medio di 5 ore (300 minuti)!La storia è realtà un po’ più sfumata. Possiamo ottenere maggiori informazioni se disegniamo un grafico dispersione del numero di voli rispetto al ritardo medio:Non sorprende che ci sia una variazione molto maggiore nel ritardo medio quando ci sono pochi voli. La forma di questo grafico è molto caratteristica: ogni volta che tracciate una media (o un altro riassunto) rispetto alla dimensione del gruppo, vedrete che la variazione diminuisce ’aumentare della dimensione del campione.Quando si guarda questo tipo di grafico, è spesso utile filtrare gruppi con il più piccolo numero di osservazioni, modo da poter vedere più il modello e meno la variazione estrema nei gruppi più piccoli. Questo è ciò che fa il seguente codice, oltre mostrarvi un comodo schema per integrare ggplot2 nei flussi di dplyr. È un po’ doloroso dover passare da %>% +, ma una volta che ci si prende la mano, è abbastanza comodo.Suggerimento RStudio: un’utile scorciatoia da tastiera è Cmd/Ctrl + Shift + P. Questo rimanda il chunk precedentemente inviato dall’editor alla console. Questo è molto comodo quando stai (per esempio) esplorando il valore di n nell’esempio sopra. Invii l’intero blocco una volta con Cmd/Ctrl + Invio, poi modifichi il valore di n e premi Cmd/Ctrl + Shift + P per inviare nuovamente il blocco completo.C’è un’altra variazione comune di questo tipo di schema. Guardiamo come la performance media dei battitori nel baseball è legata al numero di volte che sono alla battuta. Qui uso dati del pacchetto Lahman per calcolare la media di battuta (numero di colpi / numero di tentativi) di ogni giocatore di baseball della Major League.Quando tracciamo il grafico dell’abilità del battitore (misurata dalla media di battuta, ba) contro il numero di opportunità di colpire la palla (misurata dalla battuta, ab), si vedono due modelli:Come sopra, la variazione del nostro aggregato diminuisce man mano che abbiamo più\npunti dati.Come sopra, la variazione del nostro aggregato diminuisce man mano che abbiamo più\npunti dati.C’è una correlazione positiva tra abilità (ba) e opportunità di\ncolpire la palla (ab). Questo perché le squadre controllano chi può giocare,\ne ovviamente sceglieranno loro migliori giocatori.C’è una correlazione positiva tra abilità (ba) e opportunità di\ncolpire la palla (ab). Questo perché le squadre controllano chi può giocare,\ne ovviamente sceglieranno loro migliori giocatori.Questo ha anche importanti implicazioni per ranghi. Se si ordina ingenuamente base desc(ba), le persone con le migliori medie di battuta sono chiaramente fortunate, non abili:Potete trovare una buona spiegazione di questo problema http://varianceexplained.org/r/empirical_bayes_baseball/ e http://www.evanmiller.org/---sort--average-rating.html.","code":"\ndelays <- not_cancelled %>% \n  group_by(tailnum) %>% \n  summarise(\n    delay = mean(arr_delay)\n  )\n\nggplot(data = delays, mapping = aes(x = delay)) + \n  geom_freqpoly(binwidth = 10)\ndelays <- not_cancelled %>% \n  group_by(tailnum) %>% \n  summarise(\n    delay = mean(arr_delay, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(data = delays, mapping = aes(x = n, y = delay)) + \n  geom_point(alpha = 1/10)\ndelays %>% \n  filter(n > 25) %>% \n  ggplot(mapping = aes(x = n, y = delay)) + \n    geom_point(alpha = 1/10)\n# Convertiamo in tibble in modo che si stampi bene\nbatting <- as_tibble(Lahman::Batting)\n\nbatters <- batting %>% \n  group_by(playerID) %>% \n  summarise(\n    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),\n    ab = sum(AB, na.rm = TRUE)\n  )\n\nbatters %>% \n  filter(ab > 100) %>% \n  ggplot(mapping = aes(x = ab, y = ba)) +\n    geom_point() + \n    geom_smooth(se = FALSE)\n#> `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\nbatters %>% \n  arrange(desc(ba))\n#> # A tibble: 20,166 × 3\n#>   playerID     ba    ab\n#>   <chr>     <dbl> <int>\n#> 1 abramge01     1     1\n#> 2 alberan01     1     1\n#> 3 banisje01     1     1\n#> 4 bartocl01     1     1\n#> 5 bassdo01      1     1\n#> 6 birasst01     1     2\n#> # … with 20,160 more rows"},{"path":"transform.html","id":"summarise-funs","chapter":"5 Trasformazione","heading":"5.6.4 Funzioni di riepilogo utili","text":"Usare solo le medie, conteggi e la somma può portarvi molto lontano, ma R fornisce molte altre utili funzioni di riepilogo:Misure di posizione: abbiamo usato mean(x), ma anche median(x) è\nutile. La media è la somma divisa per la lunghezza; la mediana è un valore\ndove il 50% di x è al di sopra di esso, e il 50% è al di sotto.\nvolte è utile combinare l’aggregazione con il sottoinsieme logico.\nNon abbiamo ancora parlato di questo tipo di sottoinsiemi, ma imparerete di più\nsu di esso sottoinsiemi.\n\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    avg_delay1 = mean(arr_delay),\n    avg_delay2 = mean(arr_delay[arr_delay > 0]) # average positive delay\n  )\n#> `summarise()` grouped output 'year', 'month'. can override using \n#> `.groups` argument.\n#> # tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day avg_delay1 avg_delay2\n#>   <int> <int> <int>      <dbl>      <dbl>\n#> 1  2013     1     1      12.7        32.5\n#> 2  2013     1     2      12.7        32.0\n#> 3  2013     1     3       5.73       27.7\n#> 4  2013     1     4      -1.93       28.3\n#> 5  2013     1     5      -1.53       22.6\n#> 6  2013     1     6       4.24       24.4\n#> # … 359 rowsMisure di posizione: abbiamo usato mean(x), ma anche median(x) è\nutile. La media è la somma divisa per la lunghezza; la mediana è un valore\ndove il 50% di x è al di sopra di esso, e il 50% è al di sotto.volte è utile combinare l’aggregazione con il sottoinsieme logico.\nNon abbiamo ancora parlato di questo tipo di sottoinsiemi, ma imparerete di più\nsu di esso sottoinsiemi.Misure di spread: sd(x), IQR(x), mad(x). La deviazione quadratica media,\no deviazione standard sd(x), è la misura standard di diffusione.\nL’intervallo interquartile IQR(x) e la deviazione assoluta mediana mad(x)\nsono equivalenti robusti che possono essere più utili se hai dei valori anomali.\n\n# distance destinations variable others?\nnot_cancelled %>% \n  group_by(dest) %>% \n  summarise(distance_sd = sd(distance)) %>% \n  arrange(desc(distance_sd))\n#> # tibble: 104 × 2\n#>   dest  distance_sd\n#>   <chr>       <dbl>\n#> 1 EGE         10.5 \n#> 2 SAN         10.4 \n#> 3 SFO         10.2 \n#> 4 HNL         10.0 \n#> 5 SEA          9.98\n#> 6 LAS          9.91\n#> # … 98 rowsMisure di spread: sd(x), IQR(x), mad(x). La deviazione quadratica media,\no deviazione standard sd(x), è la misura standard di diffusione.\nL’intervallo interquartile IQR(x) e la deviazione assoluta mediana mad(x)\nsono equivalenti robusti che possono essere più utili se hai dei valori anomali.Misure di rango: min(x), quantile(x, 0.25), max(x). quantili\nsono una generalizzazione della mediana. Per esempio, quantile(x, 0.25)\ntroverà un valore di x che è maggiore del 25% dei valori,\ne inferiore al restante 75%.\n\n# first last flights leave day?\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    first = min(dep_time),\n    last = max(dep_time)\n  )\n#> `summarise()` grouped output 'year', 'month'. can override using \n#> `.groups` argument.\n#> # tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day first  last\n#>   <int> <int> <int> <int> <int>\n#> 1  2013     1     1   517  2356\n#> 2  2013     1     2    42  2354\n#> 3  2013     1     3    32  2349\n#> 4  2013     1     4    25  2358\n#> 5  2013     1     5    14  2357\n#> 6  2013     1     6    16  2355\n#> # … 359 rowsMisure di rango: min(x), quantile(x, 0.25), max(x). quantili\nsono una generalizzazione della mediana. Per esempio, quantile(x, 0.25)\ntroverà un valore di x che è maggiore del 25% dei valori,\ne inferiore al restante 75%.Misure di posizione: primo(x), n°(x, 2), ultimo(x). Queste funzionano\nmodo simile x[1], x[2], e x[lunghezza(x)] ma vi permettono di impostare un valore predefinito\nvalore se quella posizione non esiste (ad esempio, state cercando di ottenere il terzo\nelemento da un gruppo che ha solo due elementi). Per esempio, possiamo\ntrovare la prima e l’ultima partenza per ogni giorno:\n\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    first_dep = first(dep_time), \n    last_dep = last(dep_time)\n  )\n#> `summarise()` grouped output 'year', 'month'. can override using \n#> `.groups` argument.\n#> # tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day first_dep last_dep\n#>   <int> <int> <int>     <int>    <int>\n#> 1  2013     1     1       517     2356\n#> 2  2013     1     2        42     2354\n#> 3  2013     1     3        32     2349\n#> 4  2013     1     4        25     2358\n#> 5  2013     1     5        14     2357\n#> 6  2013     1     6        16     2355\n#> # … 359 rows\nQueste funzioni sono complementari al filtraggio sui ranghi. Il filtraggio dà\ntutte le variabili, con ogni osservazione una riga separata:\n\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  mutate(r = min_rank(desc(dep_time))) %>% \n  filter(r %% range(r))\n#> # tibble: 770 × 20\n#> # Groups:   year, month, day [365]\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1     2356        2359      -3     425     437     -12 B6     \n#> 3  2013     1     2       42        2359      43     518     442      36 B6     \n#> 4  2013     1     2     2354        2359      -5     413     437     -24 B6     \n#> 5  2013     1     3       32        2359      33     504     442      22 B6     \n#> 6  2013     1     3     2349        2359     -10     434     445     -11 B6     \n#> # … 764 rows, 10 variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, r <int>, abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delayMisure di posizione: primo(x), n°(x, 2), ultimo(x). Queste funzionano\nmodo simile x[1], x[2], e x[lunghezza(x)] ma vi permettono di impostare un valore predefinito\nvalore se quella posizione non esiste (ad esempio, state cercando di ottenere il terzo\nelemento da un gruppo che ha solo due elementi). Per esempio, possiamo\ntrovare la prima e l’ultima partenza per ogni giorno:Queste funzioni sono complementari al filtraggio sui ranghi. Il filtraggio dà\ntutte le variabili, con ogni osservazione una riga separata:Conteggi: Avete visto n(), che non prende argomenti e restituisce la\ndimensione del gruppo corrente. Per contare il numero di valori non mancanti, usate\nsum(!.na(x)). Per contare il numero di valori distinti (unici), usate\nn_distinct(x).\n\n# destinations carriers?\nnot_cancelled %>% \n  group_by(dest) %>% \n  summarise(carriers = n_distinct(carrier)) %>% \n  arrange(desc(carriers))\n#> # tibble: 104 × 2\n#>   dest  carriers\n#>   <chr>    <int>\n#> 1 ATL          7\n#> 2 BOS          7\n#> 3 CLT          7\n#> 4 ORD          7\n#> 5 TPA          7\n#> 6 AUS          6\n#> # … 98 rows\nconteggi sono così utili che dplyr fornisce un semplice aiuto se tutto ciò che si vuole è\nun conteggio:\n\nnot_cancelled %>% \n  count(dest)\n#> # tibble: 104 × 2\n#>   dest      n\n#>   <chr> <int>\n#> 1 ABQ     254\n#> 2 ACK     264\n#> 3 ALB     418\n#> 4 ANC       8\n#> 5 ATL   16837\n#> 6 AUS    2411\n#> # … 98 rows\nPotete opzionalmente fornire una variabile di peso. Per esempio, potreste usare\nquesto per “contare” (sommare) il numero totale di miglia volate da un aereo:\n\nnot_cancelled %>% \n  count(tailnum, wt = distance)\n#> # tibble: 4,037 × 2\n#>   tailnum      n\n#>   <chr>    <dbl>\n#> 1 D942DN    3418\n#> 2 N0EGMQ  239143\n#> 3 N10156  109664\n#> 4 N102UW   25722\n#> 5 N103US   24619\n#> 6 N104UW   24616\n#> # … 4,031 rowsConteggi: Avete visto n(), che non prende argomenti e restituisce la\ndimensione del gruppo corrente. Per contare il numero di valori non mancanti, usate\nsum(!.na(x)). Per contare il numero di valori distinti (unici), usate\nn_distinct(x).conteggi sono così utili che dplyr fornisce un semplice aiuto se tutto ciò che si vuole è\nun conteggio:Potete opzionalmente fornire una variabile di peso. Per esempio, potreste usare\nquesto per “contare” (sommare) il numero totale di miglia volate da un aereo:Conteggi e proporzioni di valori logici: sum(x > 10), mean(y == 0).\nQuando viene usato con funzioni numeriche, TRUE è convertito 1 e FALSE 0.\nQuesto rende sum() e mean() molto utili: La somma(x) dà il numero di\nTRUEs x, e mean(x)dà la proporzione.\n\n# Quanti voli sono partiti prima delle 5 del mattino? (questi di solito \n# voli indicano voli ritardo del giorno precedente)\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(n_early = sum(dep_time < 500))\n#> `summarise()` grouped output 'year', 'month'. can override using \n#> `.groups` argument.\n#> # tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day n_early\n#>   <int> <int> <int>   <int>\n#> 1  2013     1     1       0\n#> 2  2013     1     2       3\n#> 3  2013     1     3       4\n#> 4  2013     1     4       3\n#> 5  2013     1     5       3\n#> 6  2013     1     6       2\n#> # … 359 rows\n\n# Quale percentuale di voli è ritardo di più di un'ora?\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(hour_prop = mean(arr_delay > 60))\n#> `summarise()` grouped output 'year', 'month'. can override using \n#> `.groups` argument.\n#> # tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day hour_prop\n#>   <int> <int> <int>     <dbl>\n#> 1  2013     1     1    0.0722\n#> 2  2013     1     2    0.0851\n#> 3  2013     1     3    0.0567\n#> 4  2013     1     4    0.0396\n#> 5  2013     1     5    0.0349\n#> 6  2013     1     6    0.0470\n#> # … 359 rowsConteggi e proporzioni di valori logici: sum(x > 10), mean(y == 0).\nQuando viene usato con funzioni numeriche, TRUE è convertito 1 e FALSE 0.\nQuesto rende sum() e mean() molto utili: La somma(x) dà il numero di\nTRUEs x, e mean(x)dà la proporzione.","code":"\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    avg_delay1 = mean(arr_delay),\n    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay\n  )\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day avg_delay1 avg_delay2\n#>   <int> <int> <int>      <dbl>      <dbl>\n#> 1  2013     1     1      12.7        32.5\n#> 2  2013     1     2      12.7        32.0\n#> 3  2013     1     3       5.73       27.7\n#> 4  2013     1     4      -1.93       28.3\n#> 5  2013     1     5      -1.53       22.6\n#> 6  2013     1     6       4.24       24.4\n#> # … with 359 more rows\n# Why is distance to some destinations more variable than to others?\nnot_cancelled %>% \n  group_by(dest) %>% \n  summarise(distance_sd = sd(distance)) %>% \n  arrange(desc(distance_sd))\n#> # A tibble: 104 × 2\n#>   dest  distance_sd\n#>   <chr>       <dbl>\n#> 1 EGE         10.5 \n#> 2 SAN         10.4 \n#> 3 SFO         10.2 \n#> 4 HNL         10.0 \n#> 5 SEA          9.98\n#> 6 LAS          9.91\n#> # … with 98 more rows\n# When do the first and last flights leave each day?\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    first = min(dep_time),\n    last = max(dep_time)\n  )\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day first  last\n#>   <int> <int> <int> <int> <int>\n#> 1  2013     1     1   517  2356\n#> 2  2013     1     2    42  2354\n#> 3  2013     1     3    32  2349\n#> 4  2013     1     4    25  2358\n#> 5  2013     1     5    14  2357\n#> 6  2013     1     6    16  2355\n#> # … with 359 more rows\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(\n    first_dep = first(dep_time), \n    last_dep = last(dep_time)\n  )\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 5\n#> # Groups:   year, month [12]\n#>    year month   day first_dep last_dep\n#>   <int> <int> <int>     <int>    <int>\n#> 1  2013     1     1       517     2356\n#> 2  2013     1     2        42     2354\n#> 3  2013     1     3        32     2349\n#> 4  2013     1     4        25     2358\n#> 5  2013     1     5        14     2357\n#> 6  2013     1     6        16     2355\n#> # … with 359 more rows\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  mutate(r = min_rank(desc(dep_time))) %>% \n  filter(r %in% range(r))\n#> # A tibble: 770 × 20\n#> # Groups:   year, month, day [365]\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1     2356        2359      -3     425     437     -12 B6     \n#> 3  2013     1     2       42        2359      43     518     442      36 B6     \n#> 4  2013     1     2     2354        2359      -5     413     437     -24 B6     \n#> 5  2013     1     3       32        2359      33     504     442      22 B6     \n#> 6  2013     1     3     2349        2359     -10     434     445     -11 B6     \n#> # … with 764 more rows, 10 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, r <int>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\n# Which destinations have the most carriers?\nnot_cancelled %>% \n  group_by(dest) %>% \n  summarise(carriers = n_distinct(carrier)) %>% \n  arrange(desc(carriers))\n#> # A tibble: 104 × 2\n#>   dest  carriers\n#>   <chr>    <int>\n#> 1 ATL          7\n#> 2 BOS          7\n#> 3 CLT          7\n#> 4 ORD          7\n#> 5 TPA          7\n#> 6 AUS          6\n#> # … with 98 more rows\nnot_cancelled %>% \n  count(dest)\n#> # A tibble: 104 × 2\n#>   dest      n\n#>   <chr> <int>\n#> 1 ABQ     254\n#> 2 ACK     264\n#> 3 ALB     418\n#> 4 ANC       8\n#> 5 ATL   16837\n#> 6 AUS    2411\n#> # … with 98 more rows\nnot_cancelled %>% \n  count(tailnum, wt = distance)\n#> # A tibble: 4,037 × 2\n#>   tailnum      n\n#>   <chr>    <dbl>\n#> 1 D942DN    3418\n#> 2 N0EGMQ  239143\n#> 3 N10156  109664\n#> 4 N102UW   25722\n#> 5 N103US   24619\n#> 6 N104UW   24616\n#> # … with 4,031 more rows\n# Quanti voli sono partiti prima delle 5 del mattino? (questi di solito \n# i voli indicano voli in ritardo del giorno precedente)\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(n_early = sum(dep_time < 500))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day n_early\n#>   <int> <int> <int>   <int>\n#> 1  2013     1     1       0\n#> 2  2013     1     2       3\n#> 3  2013     1     3       4\n#> 4  2013     1     4       3\n#> 5  2013     1     5       3\n#> 6  2013     1     6       2\n#> # … with 359 more rows\n\n# Quale percentuale di voli è in ritardo di più di un'ora?\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(hour_prop = mean(arr_delay > 60))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day hour_prop\n#>   <int> <int> <int>     <dbl>\n#> 1  2013     1     1    0.0722\n#> 2  2013     1     2    0.0851\n#> 3  2013     1     3    0.0567\n#> 4  2013     1     4    0.0396\n#> 5  2013     1     5    0.0349\n#> 6  2013     1     6    0.0470\n#> # … with 359 more rows"},{"path":"transform.html","id":"raggruppare-per-variabili-multiple","chapter":"5 Trasformazione","heading":"5.6.5 Raggruppare per variabili multiple","text":"Quando si raggruppa per variabili multiple, ogni riepilogo si stacca da un livello del raggruppamento. Questo rende facile arrotolare progressivamente un set di dati:Fate attenzione quando concatenate progressivamente sommari: va bene per le somme e conteggi, ma dovete pensare alla ponderazione di medie e varianze, e non è possibile farlo esattamente per le statistiche basate sui ranghi come la mediana. altre parole, la somma delle somme per gruppi è la somma complessiva, ma la mediana delle mediane per gruppi non è la mediana complessiva.","code":"\ndaily <- group_by(flights, year, month, day)\n(per_day   <- summarise(daily, flights = n()))\n#> `summarise()` has grouped output by 'year', 'month'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 365 × 4\n#> # Groups:   year, month [12]\n#>    year month   day flights\n#>   <int> <int> <int>   <int>\n#> 1  2013     1     1     842\n#> 2  2013     1     2     943\n#> 3  2013     1     3     914\n#> 4  2013     1     4     915\n#> 5  2013     1     5     720\n#> 6  2013     1     6     832\n#> # … with 359 more rows\n(per_month <- summarise(per_day, flights = sum(flights)))\n#> `summarise()` has grouped output by 'year'. You can override using the\n#> `.groups` argument.\n#> # A tibble: 12 × 3\n#> # Groups:   year [1]\n#>    year month flights\n#>   <int> <int>   <int>\n#> 1  2013     1   27004\n#> 2  2013     2   24951\n#> 3  2013     3   28834\n#> 4  2013     4   28330\n#> 5  2013     5   28796\n#> 6  2013     6   28243\n#> # … with 6 more rows\n(per_year  <- summarise(per_month, flights = sum(flights)))\n#> # A tibble: 1 × 2\n#>    year flights\n#>   <int>   <int>\n#> 1  2013  336776"},{"path":"transform.html","id":"de-raggruppamento","chapter":"5 Trasformazione","heading":"5.6.6 De-raggruppamento","text":"Se avete bisogno di rimuovere il raggruppamento e tornare alle operazioni su dati non raggruppati, usate ungroup().","code":"\ndaily %>% \n  ungroup() %>%             # no longer grouped by date\n  summarise(flights = n())  # all flights\n#> # A tibble: 1 × 1\n#>   flights\n#>     <int>\n#> 1  336776"},{"path":"transform.html","id":"esercizi-12","chapter":"5 Trasformazione","heading":"5.6.7 Esercizi","text":"Cerca almeno 5 modi diversi per valutare le caratteristiche di ritardo tipiche di un gruppo di voli.\nConsidera seguenti scenari:\nUn volo è anticipo di 15 minuti il 50% delle volte, e ritardo di 15 minuti il 50% delle volte.\ndelle volte.\nUn volo è sempre ritardo di 10 minuti.\nUn volo è 30 minuti anticipo il 50% del tempo e 30 minuti ritardo il 50% del tempo.\ndelle volte.\nIl 99% delle volte un volo è orario. L’1% delle volte è ritardo di 2 ore.\nCos’è più importante: il ritardo di arrivo o il ritardo di partenza?Cerca almeno 5 modi diversi per valutare le caratteristiche di ritardo tipiche di un gruppo di voli.\nConsidera seguenti scenari:Un volo è anticipo di 15 minuti il 50% delle volte, e ritardo di 15 minuti il 50% delle volte.\ndelle volte.Un volo è anticipo di 15 minuti il 50% delle volte, e ritardo di 15 minuti il 50% delle volte.\ndelle volte.Un volo è sempre ritardo di 10 minuti.Un volo è sempre ritardo di 10 minuti.Un volo è 30 minuti anticipo il 50% del tempo e 30 minuti ritardo il 50% del tempo.\ndelle volte.Un volo è 30 minuti anticipo il 50% del tempo e 30 minuti ritardo il 50% del tempo.\ndelle volte.Il 99% delle volte un volo è orario. L’1% delle volte è ritardo di 2 ore.Il 99% delle volte un volo è orario. L’1% delle volte è ritardo di 2 ore.Cos’è più importante: il ritardo di arrivo o il ritardo di partenza?Trovate un altro approccio che vi dia lo stesso risultato di\nnot_cancelled %>% count(dest) e\nnot_cancelled %>% count(tailnum, wt = distance) (senza usare\ncount()).Trovate un altro approccio che vi dia lo stesso risultato di\nnot_cancelled %>% count(dest) e\nnot_cancelled %>% count(tailnum, wt = distance) (senza usare\ncount()).La nostra definizione di voli cancellati (.na(dep_delay) | .na(arr_delay)\n) è leggermente subottimale. Perché? Qual è la colonna più importante?La nostra definizione di voli cancellati (.na(dep_delay) | .na(arr_delay)\n) è leggermente subottimale. Perché? Qual è la colonna più importante?Guarda il numero di voli cancellati al giorno. C’è un modello sottostante?\nLa proporzione di voli cancellati è legata al ritardo medio?Guarda il numero di voli cancellati al giorno. C’è un modello sottostante?\nLa proporzione di voli cancellati è legata al ritardo medio?Quale compagnia ha peggiori ritardi? Sfida: puoi distinguere gli effetti\neffetti dei cattivi aeroporti rispetto alle cattive compagnie? Perché/perché ? (Suggerimento: pensa \nflights %>% group_by(carrier, dest) %>% summarise(n()))Quale compagnia ha peggiori ritardi? Sfida: puoi distinguere gli effetti\neffetti dei cattivi aeroporti rispetto alle cattive compagnie? Perché/perché ? (Suggerimento: pensa \nflights %>% group_by(carrier, dest) %>% summarise(n()))Cosa fa l’argomento sort di count(). Quando potreste usarlo?Cosa fa l’argomento sort di count(). Quando potreste usarlo?","code":""},{"path":"transform.html","id":"mutazioni-raggruppate-e-filtri","chapter":"5 Trasformazione","heading":"5.7 Mutazioni raggruppate (e filtri)","text":"Il raggruppamento è molto utile insieme summarise(), ma si possono anche fare operazioni convenienti con mutate() e filter():Trova peggiori membri di ogni gruppo:\n\nflights_sml %>% \n  group_by(year, month, day) %>%\n  filter(rank(desc(arr_delay)) < 10)\n#> # tibble: 3,306 × 7\n#> # Groups:   year, month, day [365]\n#>    year month   day dep_delay arr_delay distance air_time\n#>   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl>\n#> 1  2013     1     1       853       851      184       41\n#> 2  2013     1     1       290       338     1134      213\n#> 3  2013     1     1       260       263      266       46\n#> 4  2013     1     1       157       174      213       60\n#> 5  2013     1     1       216       222      708      121\n#> 6  2013     1     1       255       250      589      115\n#> # … 3,300 rowsTrova peggiori membri di ogni gruppo:Trova tutti gruppi più grandi di una soglia:\n\npopular_dests <- flights %>% \n  group_by(dest) %>% \n  filter(n() > 365)\npopular_dests\n#> # tibble: 332,577 × 19\n#> # Groups:   dest [77]\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … 332,571 rows, 9 variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delayTrova tutti gruppi più grandi di una soglia:Standardizzare per calcolare le metriche per gruppo:\n\npopular_dests %>% \n  filter(arr_delay > 0) %>% \n  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% \n  select(year:day, dest, arr_delay, prop_delay)\n#> # tibble: 131,106 × 6\n#> # Groups:   dest [77]\n#>    year month   day dest  arr_delay prop_delay\n#>   <int> <int> <int> <chr>     <dbl>      <dbl>\n#> 1  2013     1     1 IAH          11  0.000111 \n#> 2  2013     1     1 IAH          20  0.000201 \n#> 3  2013     1     1 MIA          33  0.000235 \n#> 4  2013     1     1 ORD          12  0.0000424\n#> 5  2013     1     1 FLL          19  0.0000938\n#> 6  2013     1     1 ORD           8  0.0000283\n#> # … 131,100 rowsStandardizzare per calcolare le metriche per gruppo:Un filtro raggruppato è una mutazione raggruppata seguita da un filtro non raggruppato. Generalmente li evito tranne che per manipolazioni rapide e sporche: altrimenti è difficile controllare di aver fatto la manipolazione correttamente.Le funzioni che funzionano più naturalmente nei mutate raggruppati e nei filtri sono note come funzioni finestra (rispetto alle funzioni di sintesi usate per sommari). Puoi imparare di più sulle utili funzioni finestra nella vignetta corrispondente: vignette(\"window-functions\").","code":"\nflights_sml %>% \n  group_by(year, month, day) %>%\n  filter(rank(desc(arr_delay)) < 10)\n#> # A tibble: 3,306 × 7\n#> # Groups:   year, month, day [365]\n#>    year month   day dep_delay arr_delay distance air_time\n#>   <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl>\n#> 1  2013     1     1       853       851      184       41\n#> 2  2013     1     1       290       338     1134      213\n#> 3  2013     1     1       260       263      266       46\n#> 4  2013     1     1       157       174      213       60\n#> 5  2013     1     1       216       222      708      121\n#> 6  2013     1     1       255       250      589      115\n#> # … with 3,300 more rows\npopular_dests <- flights %>% \n  group_by(dest) %>% \n  filter(n() > 365)\npopular_dests\n#> # A tibble: 332,577 × 19\n#> # Groups:   dest [77]\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      517         515       2     830     819      11 UA     \n#> 2  2013     1     1      533         529       4     850     830      20 UA     \n#> 3  2013     1     1      542         540       2     923     850      33 AA     \n#> 4  2013     1     1      544         545      -1    1004    1022     -18 B6     \n#> 5  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 6  2013     1     1      554         558      -4     740     728      12 UA     \n#> # … with 332,571 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\npopular_dests %>% \n  filter(arr_delay > 0) %>% \n  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% \n  select(year:day, dest, arr_delay, prop_delay)\n#> # A tibble: 131,106 × 6\n#> # Groups:   dest [77]\n#>    year month   day dest  arr_delay prop_delay\n#>   <int> <int> <int> <chr>     <dbl>      <dbl>\n#> 1  2013     1     1 IAH          11  0.000111 \n#> 2  2013     1     1 IAH          20  0.000201 \n#> 3  2013     1     1 MIA          33  0.000235 \n#> 4  2013     1     1 ORD          12  0.0000424\n#> 5  2013     1     1 FLL          19  0.0000938\n#> 6  2013     1     1 ORD           8  0.0000283\n#> # … with 131,100 more rows"},{"path":"transform.html","id":"esercizi-13","chapter":"5 Trasformazione","heading":"5.7.1 Esercizi","text":"Fai riferimento alle liste di funzioni utili per mutare e filtrare.\nDescrivete come cambia ogni operazione quando la combinate con il raggruppamento.Fai riferimento alle liste di funzioni utili per mutare e filtrare.\nDescrivete come cambia ogni operazione quando la combinate con il raggruppamento.Quale aereo (tailnum) ha il peggior record di puntualità?Quale aereo (tailnum) ha il peggior record di puntualità?che ora del giorno dovresti volare se vuoi evitare il più possibile ritardi?\npossibile?che ora del giorno dovresti volare se vuoi evitare il più possibile ritardi?\npossibile?Per ogni destinazione, calcola minuti totali di ritardo. Per ogni\nvolo, calcola la proporzione del ritardo totale per la sua destinazione.Per ogni destinazione, calcola minuti totali di ritardo. Per ogni\nvolo, calcola la proporzione del ritardo totale per la sua destinazione.ritardi sono tipicamente correlati temporalmente: anche una volta che il problema che\nil problema che ha causato il ritardo iniziale è stato risolto, voli successivi sono ritardati\nper permettere ai voli precedenti di partire. Utilizzando lag(), esplorate come il ritardo\ndi un volo sia correlato al ritardo del volo immediatamente precedente.ritardi sono tipicamente correlati temporalmente: anche una volta che il problema che\nil problema che ha causato il ritardo iniziale è stato risolto, voli successivi sono ritardati\nper permettere ai voli precedenti di partire. Utilizzando lag(), esplorate come il ritardo\ndi un volo sia correlato al ritardo del volo immediatamente precedente.Guarda ogni destinazione. Potete trovare voli che sono sospettosamente\nveloci? (cioè voli che rappresentano un potenziale errore di inserimento dati). 2. Calcola\nil tempo di volo di un volo rispetto al volo più breve per quella destinazione.\nQuali voli hanno subito più ritardi volo?Guarda ogni destinazione. Potete trovare voli che sono sospettosamente\nveloci? (cioè voli che rappresentano un potenziale errore di inserimento dati). 2. Calcola\nil tempo di volo di un volo rispetto al volo più breve per quella destinazione.\nQuali voli hanno subito più ritardi volo?Trova tutte le destinazioni che sono volate da almeno due compagnie. Usa questa\ninformazioni per classificare vettori.Trova tutte le destinazioni che sono volate da almeno due compagnie. Usa questa\ninformazioni per classificare vettori.Per ogni aereo, conti il numero di voli prima del primo ritardo\nsuperiore 1 ora.Per ogni aereo, conti il numero di voli prima del primo ritardo\nsuperiore 1 ora.","code":""},{"path":"workflow-script.html","id":"workflow-script","chapter":"6 Workflow: script","heading":"6 Workflow: script","text":"Finora avete usato la console per eseguire il codice. Questo è un ottimo punto di partenza, ma vi accorgerete che diventa angusto abbastanza rapidamente man mano che create grafici ggplot2 più complessi e pipe dplyr. Per darti più spazio per lavorare, è una grande idea usare l’editor di script. Aprilo cliccando sul menu File, e selezionando New File, poi R script, o usando la scorciatoia da tastiera Cmd/Ctrl + Shift + N. Ora vedrai quattro riquadri:L’editor di script è un ottimo posto per mettere il codice che ti interessa. Continuate sperimentare nella console, ma una volta che avete scritto del codice che funziona e fa quello che volete, mettetelo nell’editor di script. RStudio salverà automaticamente il contenuto dell’editor quando si esce da RStudio, e lo caricherà automaticamente quando si riapre. Tuttavia, è una buona idea salvare regolarmente propri script e farne il backup.","code":""},{"path":"workflow-script.html","id":"esecuzione-del-codice","chapter":"6 Workflow: script","heading":"6.1 Esecuzione del codice","text":"L’editor di script è anche un ottimo posto per costruire complessi grafici ggplot2 o lunghe sequenze di manipolazioni dplyr. La chiave per usare efficacemente l’editor di script è memorizzare una delle più importanti scorciatoie da tastiera: Cmd/Ctrl + Enter. Questo esegue l’espressione R corrente nella console. Per esempio, prendete il codice qui sotto. Se il tuo cursore è su █, , premendo Cmd/Ctrl + Enter eseguirai il comando completo che genera not_cancelled. Sposterà anche il cursore ’istruzione successiva (che inizia con not_cancelled %>%). Questo rende facile eseguire il tuo script completo premendo ripetutamente Cmd/Ctrl + Invio.Invece di eseguire espressione per espressione, puoi anche eseguire lo script completo un solo passo: Cmd/Ctrl + Shift + S. Farlo regolarmente è un ottimo modo per controllare di aver catturato tutte le parti importanti del tuo codice nello script.Ti consiglio di iniziare sempre il tuo script con pacchetti che ti servono. questo modo, se condividete il vostro codice con altri, possono facilmente vedere quali pacchetti hanno bisogno di installare. Notate, comunque, che non dovreste mai includere install.packages() o setwd() uno script che condividete. È molto antisociale cambiare le impostazioni sul computer di qualcun altro!Quando lavorerete nei prossimi capitoli, vi raccomando vivamente di iniziare nell’editor e di fare pratica con le scorciatoie da tastiera. Con il tempo, inviare codice alla console questo modo diventerà così naturale che non ci penserete nemmeno.","code":"library(dplyr)\nlibrary(nycflights13)\n\nnot_cancelled <- flights %>% \n  filter(!is.na(dep_delay)█, !is.na(arr_delay))\n\nnot_cancelled %>% \n  group_by(year, month, day) %>% \n  summarise(mean = mean(dep_delay))"},{"path":"workflow-script.html","id":"diagnostica-di-rstudio","chapter":"6 Workflow: script","heading":"6.2 Diagnostica di RStudio","text":"L’editor di script evidenzierà anche gli errori di sintassi con una linea rossa ghirigori e una croce nella barra laterale:Hover cross see problem :RStudio also let know potential problems:","code":""},{"path":"workflow-script.html","id":"esercizi-14","chapter":"6 Workflow: script","heading":"6.3 Esercizi","text":"Andate sull’account twitter di RStudio Tips, https://twitter.com/rstudiotips\ne trova un suggerimento che sembra interessante. Esercitatevi ad usarlo!Andate sull’account twitter di RStudio Tips, https://twitter.com/rstudiotips\ne trova un suggerimento che sembra interessante. Esercitatevi ad usarlo!Quali altri errori comuni segnalerà la diagnostica di RStudio? Leggete\nhttps://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics per\nscoprirlo.Quali altri errori comuni segnalerà la diagnostica di RStudio? Leggete\nhttps://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics per\nscoprirlo.","code":""},{"path":"analisi-esplorativa.html","id":"analisi-esplorativa","chapter":"7 Analisi esplorativa","heading":"7 Analisi esplorativa","text":"","code":""},{"path":"analisi-esplorativa.html","id":"introduzione-3","chapter":"7 Analisi esplorativa","heading":"7.1 Introduzione","text":"Questo capitolo vi mostrerà come usare la visualizzazione e la trasformazione per esplorare vostri dati modo sistematico, un compito che gli statistici chiamano analisi esplorativa dei dati, o EDA breve. L’EDA è un ciclo iterativo. Voi:Generate domande sui vostri dati.Generate domande sui vostri dati.Cercate le risposte visualizzando, trasformando e modellando vostri dati.Cercate le risposte visualizzando, trasformando e modellando vostri dati.Usare ciò che si impara per raffinare le domande e/o generare nuove domande.Usare ciò che si impara per raffinare le domande e/o generare nuove domande.L’EDA non è un processo formale con un rigido insieme di regole. Più che altro, l’EDA è uno stato mentale. Durante le fasi iniziali dell’EDA dovreste sentirvi liberi di investigare ogni idea che vi viene mente. Alcune di queste idee andranno buon fine e altre saranno vicoli ciechi. Man mano che la vostra esplorazione continua, vi concentrerete su alcune aree particolarmente produttive che alla fine metterete per iscritto e comunicherete agli altri.L’EDA è una parte importante di qualsiasi analisi dei dati, anche se le domande ti vengono servite su un piatto d’argento, perché devi sempre indagare sulla qualità dei tuoi dati. La pulizia dei dati è solo un’applicazione dell’EDA: vi chiedete se vostri dati soddisfino o meno le vostre aspettative. Per fare la pulizia dei dati, avrete bisogno di impiegare tutti gli strumenti dell’EDA: visualizzazione, trasformazione e modellazione.","code":""},{"path":"analisi-esplorativa.html","id":"prerequisiti-3","chapter":"7 Analisi esplorativa","heading":"7.1.1 Prerequisiti","text":"questo capitolo combineremo ciò che avete imparato su dplyr e ggplot2 per porre domande modo interattivo, rispondere con dati e poi porre nuove domande.","code":"\nlibrary(tidyverse)"},{"path":"analisi-esplorativa.html","id":"domande","chapter":"7 Analisi esplorativa","heading":"7.2 Domande","text":"“Non ci sono domande statistiche di routine, solo domande statistiche discutibili\nroutine”. — Sir David CoxMolto meglio una risposta approssimativa alla domanda giusta, che è spesso\nvaga, che una risposta esatta alla domanda sbagliata, che può sempre essere resa\nprecisa”. — John TukeyIl tuo obiettivo durante l’EDA è quello di sviluppare una comprensione dei tuoi dati. Il modo più semplice per farlo è usare le domande come strumenti per guidare la vostra indagine. Quando fate una domanda, la domanda focalizza la vostra attenzione su una parte specifica del vostro set di dati e vi aiuta decidere quali grafici, modelli o trasformazioni fare.L’EDA è fondamentalmente un processo creativo. E come la maggior parte dei processi creativi, la chiave per fare domande di qualità è generare una grande quantità di domande. È difficile fare domande rivelatrici ’inizio della vostra analisi perché non sapete quali intuizioni sono contenute nel vostro set di dati. D’altra parte, ogni nuova domanda che ponete vi esporrà un nuovo aspetto dei vostri dati e aumenterà le vostre possibilità di fare una scoperta. È possibile scavare rapidamente nelle parti più interessanti dei vostri dati - e sviluppare una serie di domande che fanno riflettere - se fate seguire ad ogni domanda una nuova domanda basata su ciò che trovate.Non c’è una regola su quali domande dovresti porre per guidare la tua ricerca. Tuttavia, due tipi di domande saranno sempre utili per fare scoperte ’interno dei tuoi dati. Queste domande possono essere formulate liberamente come:Che tipo di variazione si verifica ’interno delle mie variabili?Che tipo di variazione si verifica ’interno delle mie variabili?Che tipo di covariazione si verifica tra le mie variabili?Che tipo di covariazione si verifica tra le mie variabili?Il resto di questo capitolo esaminerà queste due domande. Spiegherò cosa sono la variazione e la covariazione, e vi mostrerò diversi modi per rispondere ciascuna domanda. Per facilitare la discussione, definiamo alcuni termini:Una variabile è una quantità, qualità o proprietà che si può misurare.Una variabile è una quantità, qualità o proprietà che si può misurare.Un valore è lo stato di una variabile quando la si misura. Il valore di una\nIl valore di una variabile può cambiare da una misurazione ’altra.Un valore è lo stato di una variabile quando la si misura. Il valore di una\nIl valore di una variabile può cambiare da una misurazione ’altra.Una osservazione è un insieme di misurazioni fatte condizioni simili\n(di solito si fanno tutte le misure di un’osservazione nello stesso\ntempo e sullo stesso oggetto). Un’osservazione conterrà diversi valori,\nciascuno associato ad una variabile diversa. volte mi riferirò \nun’osservazione come un punto di dati.Una osservazione è un insieme di misurazioni fatte condizioni simili\n(di solito si fanno tutte le misure di un’osservazione nello stesso\ntempo e sullo stesso oggetto). Un’osservazione conterrà diversi valori,\nciascuno associato ad una variabile diversa. volte mi riferirò \nun’osservazione come un punto di dati.Dati tabulari sono un insieme di valori, ciascuno associato una variabile e un’osservazione.\nosservazione. dati tabulari sono ordinati se ogni valore è collocato nella sua\n“cella”, ogni variabile nella sua colonna e ogni osservazione nella sua\nriga.Dati tabulari sono un insieme di valori, ciascuno associato una variabile e un’osservazione.\nosservazione. dati tabulari sono ordinati se ogni valore è collocato nella sua\n“cella”, ogni variabile nella sua colonna e ogni osservazione nella sua\nriga.Finora, tutti dati che avete visto sono stati ordinati. Nella vita reale, la maggior parte dei dati non è ordinata, quindi torneremo di nuovo su queste idee [dati ordinati].","code":""},{"path":"analisi-esplorativa.html","id":"variazione","chapter":"7 Analisi esplorativa","heading":"7.3 Variazione","text":"La Variazione è la tendenza dei valori di una variabile cambiare da una misurazione ’altra. Puoi vedere facilmente la variazione nella vita reale; se misuri qualsiasi variabile continua due volte, otterrai due risultati diversi. Questo è vero anche se si misurano quantità che sono costanti, come la velocità della luce. Ognuna delle vostre misurazioni includerà una piccola quantità di errore che varia da misura misura. Le variabili categoriche possono anche variare se misurate attraverso soggetti diversi (per esempio colori degli occhi di persone diverse), o tempi diversi (per esempio livelli di energia di un elettrone momenti diversi).\nOgni variabile ha il suo modello di variazione, che può rivelare informazioni interessanti. Il modo migliore per capire questo modello è quello di visualizzare la distribuzione dei valori della variabile.","code":""},{"path":"analisi-esplorativa.html","id":"visualizzare-le-distribuzioni","chapter":"7 Analisi esplorativa","heading":"7.3.1 Visualizzare le distribuzioni","text":"Il modo cui si visualizza la distribuzione di una variabile dipende dal fatto che la variabile sia categorica o continua. Una variabile è categorica se può assumere solo uno di un piccolo insieme di valori. R, le variabili categoriche sono solitamente salvate come fattori o vettori di caratteri. Per esaminare la distribuzione di una variabile categorica, usate un grafico barre:L’altezza delle barre mostra quante osservazioni si sono verificate con ogni valore x. Puoi calcolare questi valori manualmente con dplyr::count():Una variabile è continua se può prendere uno qualsiasi di un insieme infinito di valori ordinati. numeri e le date-ora sono due esempi di variabili continue. Per esaminare la distribuzione di una variabile continua, usate un istogramma:Puoi calcolarlo mano combinando dplyr::count() e ggplot2::cut_width():Un istogramma divide l’asse x intervalli equamente distanziati e poi usa l’altezza di una barra per mostrare il numero di osservazioni che rientrano ciascun intervallo. Nel grafico qui sopra, la barra più alta mostra che quasi 30.000 osservazioni hanno un valore di carat tra 0,25 e 0,75, che sono bordi sinistro e destro della barra.Potete impostare la larghezza degli intervalli un istogramma con l’argomento binwidth, che è misurato nelle unità della variabile x. Dovreste sempre esplorare una varietà di larghezze di binario quando lavorate con gli istogrammi, poiché diverse larghezze di binario possono rivelare diversi modelli. Per esempio, ecco come appare il grafico qui sopra quando ingrandiamo solo diamanti con una dimensione inferiore tre carati e scegliamo una larghezza di banda più piccola.Se vuoi sovrapporre più istogrammi nello stesso grafico, ti consiglio di usare geom_freqpoly() invece di geom_histogram(). La funzione geom_freqpoly() esegue lo stesso calcolo di geom_histogram(), ma invece di visualizzare conteggi con delle barre, utilizza delle linee. È molto più facile capire le linee sovrapposte rispetto alle barre.Ci sono alcune sfide con questo tipo di grafico, su cui torneremo visualizzare una variabile categorica e una continua.Ora che potete visualizzare la variazione, cosa dovreste cercare nei vostri grafici? E che tipo di domande successive dovresti fare? Ho messo insieme una lista qui sotto dei tipi di informazioni più utili che troverete nei vostri grafici, insieme ad alcune domande di follow-per ogni tipo di informazione. La chiave per fare buone domande di follow-sarà fare affidamento sulla tua curiosità (Cosa vuoi sapere di più?) e sul tuo scetticismo (Come potrebbe essere fuorviante?).","code":"\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut))\ndiamonds %>% \n  count(cut)\n#> # A tibble: 5 × 2\n#>   cut           n\n#>   <ord>     <int>\n#> 1 Fair       1610\n#> 2 Good       4906\n#> 3 Very Good 12082\n#> 4 Premium   13791\n#> 5 Ideal     21551\nggplot(data = diamonds) +\n  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)\ndiamonds %>% \n  count(cut_width(carat, 0.5))\n#> # A tibble: 11 × 2\n#>   `cut_width(carat, 0.5)`     n\n#>   <fct>                   <int>\n#> 1 [-0.25,0.25]              785\n#> 2 (0.25,0.75]             29498\n#> 3 (0.75,1.25]             15977\n#> 4 (1.25,1.75]              5313\n#> 5 (1.75,2.25]              2002\n#> 6 (2.25,2.75]               322\n#> # … with 5 more rows\nsmaller <- diamonds %>% \n  filter(carat < 3)\n  \nggplot(data = smaller, mapping = aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\nggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +\n  geom_freqpoly(binwidth = 0.1)"},{"path":"analisi-esplorativa.html","id":"valori-tipici","chapter":"7 Analisi esplorativa","heading":"7.3.2 Valori tipici","text":"Sia nei grafici barre che negli istogrammi, le barre alte mostrano valori comuni di una variabile, e le barre più corte mostrano valori meno comuni. punti che non hanno barre rivelano valori che non sono stati visti nei vostri dati. Per trasformare queste informazioni domande utili, cercate qualcosa di inaspettato:Quali valori sono più comuni? Perché?Quali valori sono più comuni? Perché?Quali valori sono rari? Perché? Corrisponde alle tue aspettative?Quali valori sono rari? Perché? Corrisponde alle tue aspettative?Riesci vedere qualche schema insolito? Cosa potrebbe spiegarli?Riesci vedere qualche schema insolito? Cosa potrebbe spiegarli?Come esempio, l’istogramma qui sotto suggerisce diverse domande interessanti:Perché ci sono più diamanti carati interi e frazioni comuni di carati?Perché ci sono più diamanti carati interi e frazioni comuni di carati?Perché ci sono più diamanti leggermente destra di ogni picco rispetto quelli\nsono leggermente sinistra di ogni picco?Perché ci sono più diamanti leggermente destra di ogni picco rispetto quelli\nsono leggermente sinistra di ogni picco?Perché non ci sono diamanti più grandi di 3 carati?Perché non ci sono diamanti più grandi di 3 carati?raggruppamenti di valori simili suggeriscono l’esistenza di sottogruppi nei tuoi dati. Per capire sottogruppi, chiedetevi:Come sono simili tra loro le osservazioni ’interno di ogni cluster?Come sono simili tra loro le osservazioni ’interno di ogni cluster?che modo le osservazioni cluster separati sono diverse l’una dall’altra?che modo le osservazioni cluster separati sono diverse l’una dall’altra?Come puoi spiegare o descrivere cluster?Come puoi spiegare o descrivere cluster?Perché l’aspetto dei cluster potrebbe essere fuorviante?Perché l’aspetto dei cluster potrebbe essere fuorviante?L’istogramma qui sotto mostra la durata (minuti) di 272 eruzioni dell’Old Faithful Geyser nel Parco Nazionale di Yellowstone. tempi di eruzione sembrano essere raggruppati due gruppi: ci sono eruzioni brevi (di circa 2 minuti) ed eruzioni lunghe (4-5 minuti), ma poco nel mezzo.Molte delle domande di cui sopra vi spingeranno ad esplorare una relazione tra variabili, per esempio, per vedere se valori di una variabile possono spiegare il comportamento di un’altra variabile. Ci arriveremo tra poco.","code":"\nggplot(data = smaller, mapping = aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\nggplot(data = faithful, mapping = aes(x = eruptions)) + \n  geom_histogram(binwidth = 0.25)"},{"path":"analisi-esplorativa.html","id":"valori-insoliti","chapter":"7 Analisi esplorativa","heading":"7.3.3 Valori insoliti","text":"valori anomali sono osservazioni insolite; punti di dati che non sembrano adattarsi allo schema. volte valori anomali sono errori di inserimento dei dati; altre volte valori anomali suggeriscono importanti novità scientifiche. Quando si hanno molti dati, valori anomali sono volte difficili da vedere un istogramma. Per esempio, prendiamo la distribuzione della variabile y dal set di dati dei diamanti. L’unica prova dell’esistenza di outlier sono limiti insolitamente ampi sull’asse delle x.Ci sono così tante osservazioni nei bin comuni che bin rari sono così corti che non potete vederli (anche se forse se fissate intensamente lo 0 noterete qualcosa). Per rendere facile vedere valori insoliti, abbiamo bisogno di zoomare piccoli valori dell’asse y con coord_cartesian():(coord_cartesian() ha anche un argomento xlim() per quando avete bisogno di zoomare sull’asse x. ggplot2 ha anche le funzioni xlim() e ylim() che lavorano modo leggermente diverso: buttano via dati al di fuori dei limiti).Questo ci permette di vedere che ci sono tre valori insoliti: 0, ~30, e ~60. Li tiriamo fuori con dplyr:La variabile y misura una delle tre dimensioni di questi diamanti, mm. Sappiamo che diamanti non possono avere una larghezza di 0mm, quindi questi valori devono essere errati. Potremmo anche sospettare che le misure di 32mm e 59mm non siano plausibili: quei diamanti sono lunghi più di un pollice, ma non costano centinaia di migliaia di dollari!È una buona pratica ripetere l’analisi con e senza valori anomali. Se hanno un effetto minimo sui risultati, e non riesci capire perché sono lì, è ragionevole sostituirli con valori mancanti e andare avanti. Tuttavia, se hanno un effetto sostanziale sui tuoi risultati, non dovresti abbandonarli senza giustificazione. Dovrai capire cosa li ha causati (ad esempio un errore di inserimento dati) e rendere noto che li hai rimossi nel tuo scritto.","code":"\nggplot(diamonds) + \n  geom_histogram(mapping = aes(x = y), binwidth = 0.5)\nggplot(diamonds) + \n  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\nunusual <- diamonds %>% \n  filter(y < 3 | y > 20) %>% \n  select(price, x, y, z) %>%\n  arrange(y)\nunusual\n#> # A tibble: 9 × 4\n#>   price     x     y     z\n#>   <int> <dbl> <dbl> <dbl>\n#> 1  5139  0      0    0   \n#> 2  6381  0      0    0   \n#> 3 12800  0      0    0   \n#> 4 15686  0      0    0   \n#> 5 18034  0      0    0   \n#> 6  2130  0      0    0   \n#> 7  2130  0      0    0   \n#> 8  2075  5.15  31.8  5.12\n#> 9 12210  8.09  58.9  8.06"},{"path":"analisi-esplorativa.html","id":"esercizi-15","chapter":"7 Analisi esplorativa","heading":"7.3.4 Esercizi","text":"Esplora la distribuzione di ciascuna delle variabili x, y e z.\ndiamanti. Cosa hai imparato? Pensa un diamante e come\npotresti decidere quale dimensione è la lunghezza, la larghezza e la profondità.Esplora la distribuzione di ciascuna delle variabili x, y e z.\ndiamanti. Cosa hai imparato? Pensa un diamante e come\npotresti decidere quale dimensione è la lunghezza, la larghezza e la profondità.Esplora la distribuzione del prezzo. Scopri qualcosa di insolito\no sorprendente? (Suggerimento: pensa attentamente alla larghezza di banda e assicurati di\ndi provare una vasta gamma di valori).Esplora la distribuzione del prezzo. Scopri qualcosa di insolito\no sorprendente? (Suggerimento: pensa attentamente alla larghezza di banda e assicurati di\ndi provare una vasta gamma di valori).Quanti diamanti sono 0,99 carati? Quanti sono da 1 carato? Quale\npensi che sia la causa della differenza?Quanti diamanti sono 0,99 carati? Quanti sono da 1 carato? Quale\npensi che sia la causa della differenza?Confrontate e contrastate coord_cartesian() vs xlim() o ylim() quando\nzoomare su un istogramma. Cosa succede se lasciate binwidth non impostato?\nCosa succede se provate zoomare modo da mostrare solo metà della barra?Confrontate e contrastate coord_cartesian() vs xlim() o ylim() quando\nzoomare su un istogramma. Cosa succede se lasciate binwidth non impostato?\nCosa succede se provate zoomare modo da mostrare solo metà della barra?","code":""},{"path":"analisi-esplorativa.html","id":"valori-mancanti-2","chapter":"7 Analisi esplorativa","heading":"7.4 Valori mancanti","text":"Se avete incontrato valori insoliti nel vostro set di dati e volete semplicemente passare al resto della vostra analisi, avete due opzioni.Eliminare l’intera riga con valori strani:\n\ndiamonds2 <- diamonds %>% \n  filter((y, 3, 20))\nNon raccomando questa opzione perché solo perché una misurazione\nnon è valida, non significa che tutte le misure lo siano. Inoltre, se si hanno\ndati di bassa qualità, quando avrete applicato questo approccio tutte le variabili,\npotreste scoprire che non vi rimane alcun dato!Eliminare l’intera riga con valori strani:Non raccomando questa opzione perché solo perché una misurazione\nnon è valida, non significa che tutte le misure lo siano. Inoltre, se si hanno\ndati di bassa qualità, quando avrete applicato questo approccio tutte le variabili,\npotreste scoprire che non vi rimane alcun dato!Invece, consiglio di sostituire valori insoliti con valori mancanti.\nIl modo più semplice per farlo è usare mutate() per sostituire la variabile\ncon una copia modificata. Potete usare la funzione ifelse() per sostituire\nvalori insoliti con NA:\n\ndiamonds2 <- diamonds %>% \n  mutate(y = ifelse(y < 3 | y > 20, NA, y))Invece, consiglio di sostituire valori insoliti con valori mancanti.\nIl modo più semplice per farlo è usare mutate() per sostituire la variabile\ncon una copia modificata. Potete usare la funzione ifelse() per sostituire\nvalori insoliti con NA:ifelse() ha tre argomenti. Il primo argomento test dovrebbe essere un vettore logico. Il risultato conterrà il valore del secondo argomento, yes, quando test è TRUE, e il valore del terzo argomento, , quando è false. alternativa ifelse, usate dplyr::case_when(). case_when() è particolarmente utile ’interno di mutate quando si vuole creare una nuova variabile che si basa su una combinazione complessa di variabili esistenti.Come R, ggplot2 sottoscrive la filosofia che valori mancanti non dovrebbero mai mancare silenziosamente. Non è ovvio dove si dovrebbero tracciare valori mancanti, quindi ggplot2 non li include nel grafico, ma avverte che sono stati rimossi:Per sopprimere questo avvertimento, impostate na.rm = TRUE:Altre volte vuoi capire cosa rende le osservazioni con valori mancanti diverse dalle osservazioni con valori registrati. Per esempio, nycflights13::flights, valori mancanti nella variabile dep_time indicano che il volo è stato cancellato. Quindi potresti voler confrontare gli orari di partenza programmati per gli orari cancellati e non cancellati. Potete farlo creando una nuova variabile con .na().Tuttavia questo grafico non è ottimale perché ci sono molti più voli non cancellati che voli cancellati. Nella prossima sezione esploreremo alcune tecniche per migliorare questo confronto.","code":"\ndiamonds2 <- diamonds %>% \n  filter(between(y, 3, 20))\ndiamonds2 <- diamonds %>% \n  mutate(y = ifelse(y < 3 | y > 20, NA, y))\nggplot(data = diamonds2, mapping = aes(x = x, y = y)) + \n  geom_point()\n#> Warning: Removed 9 rows containing missing values (`geom_point()`).\nggplot(data = diamonds2, mapping = aes(x = x, y = y)) + \n  geom_point(na.rm = TRUE)\nnycflights13::flights %>% \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + sched_min / 60\n  ) %>% \n  ggplot(mapping = aes(sched_dep_time)) + \n    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)"},{"path":"analisi-esplorativa.html","id":"esercizi-16","chapter":"7 Analisi esplorativa","heading":"7.4.1 Esercizi","text":"Cosa succede ai valori mancanti un istogramma? Cosa succede ai valori mancanti\nvalori mancanti un grafico barre? Perché c’è una differenza?Cosa succede ai valori mancanti un istogramma? Cosa succede ai valori mancanti\nvalori mancanti un grafico barre? Perché c’è una differenza?Cosa fa na.rm = TRUE mean() e sum()?Cosa fa na.rm = TRUE mean() e sum()?","code":""},{"path":"analisi-esplorativa.html","id":"covariazione","chapter":"7 Analisi esplorativa","heading":"7.5 Covariazione","text":"Se la variazione descrive il comportamento ’interno di una variabile, la covariazione descrive il comportamento tra le variabili. La Covariazione è la tendenza dei valori di due o più variabili variare insieme modo correlato. Il modo migliore per individuare la covariazione è visualizzare la relazione tra due o più variabili. Il modo cui lo si fa dovrebbe dipendere ancora una volta dal tipo di variabili coinvolte.","code":""},{"path":"analisi-esplorativa.html","id":"cat-cont","chapter":"7 Analisi esplorativa","heading":"7.5.1 Una variabile categorica e continua","text":"È comune voler esplorare la distribuzione di una variabile continua suddivisa da una variabile categorica, come nel precedente poligono di frequenza. L’aspetto predefinito di geom_freqpoly() non è molto utile per questo tipo di confronto perché l’altezza è data dal conteggio. Ciò significa che se uno dei gruppi è molto più piccolo degli altri, è difficile vedere le differenze di forma. Per esempio, esploriamo come il prezzo di un diamante varia con la sua qualità:È difficile vedere la differenza di distribuzione perché conteggi complessivi sono molto diversi:Per rendere il confronto più facile, dobbiamo scambiare ciò che viene visualizzato sull’asse y. Invece di visualizzare il conteggio, visualizzeremo densità, che è il conteggio standardizzato modo che l’area sotto ogni poligono di frequenza sia uno.C’è qualcosa di piuttosto sorprendente questo grafico - sembra che diamanti discreti (‘fair’, la qualità più bassa) abbiano il prezzo medio più alto! Ma forse è perché poligoni di frequenza sono un po’ difficili da interpretare - c’è molto da fare questo grafico.Un’altra alternativa per visualizzare la distribuzione di una variabile continua suddivisa per una variabile categorica è il boxplot. Un boxplot è un tipo di stenografia visiva per una distribuzione di valori che è popolare tra gli statistici. Ogni boxplot è composto da:Un riquadro che si estende dal 25° percentile della distribuzione al\n75° percentile, una distanza nota come intervallo interquartile (IQR). Nel\nmezzo del riquadro c’è una linea che mostra la mediana, cioè il 50° percentile,\ndella distribuzione. Queste tre linee vi danno un senso della diffusione della\ndistribuzione e se la distribuzione è simmetrica o meno intorno alla\nmediana o inclinata su un lato.Un riquadro che si estende dal 25° percentile della distribuzione al\n75° percentile, una distanza nota come intervallo interquartile (IQR). Nel\nmezzo del riquadro c’è una linea che mostra la mediana, cioè il 50° percentile,\ndella distribuzione. Queste tre linee vi danno un senso della diffusione della\ndistribuzione e se la distribuzione è simmetrica o meno intorno alla\nmediana o inclinata su un lato.Punti visivi che mostrano le osservazioni che cadono più di 1,5 volte il\nIQR da entrambi bordi del riquadro. Questi punti fuori misura sono insoliti\nquindi sono tracciati singolarmente.Punti visivi che mostrano le osservazioni che cadono più di 1,5 volte il\nIQR da entrambi bordi del riquadro. Questi punti fuori misura sono insoliti\nquindi sono tracciati singolarmente.Una linea (o baffo) che si estende da ogni estremità del riquadro e va fino al\npunto non anomalo più lontano nella distribuzione.Una linea (o baffo) che si estende da ogni estremità del riquadro e va fino al\npunto non anomalo più lontano nella distribuzione.Diamo un’occhiata alla distribuzione del prezzo per taglio usando geom_boxplot():Vediamo molte meno informazioni sulla distribuzione, ma boxplot sono molto più compatti, quindi possiamo confrontarli più facilmente (e adattarne di più su un solo grafico). Questo supporta la scoperta controintuitiva che diamanti di migliore qualità sono media più economici! Negli esercizi, sarete sfidati capire perché.Il taglio è un fattore ordinato: giusto è peggiore di buono, che è peggiore di molto buono e così via. Molte variabili categoriche non hanno un tale ordine intrinseco, quindi potreste volerle riordinare per fare una visualizzazione più informativa. Un modo per farlo è con la funzione reorder().Per esempio, prendete la variabile class nel set di dati mpg. Potreste essere interessati sapere come varia il chilometraggio autostradale tra le classi:Per rendere la tendenza più facile da vedere, possiamo riordinare la classe base al valore mediano di hwy:Se avete nomi di variabili lunghi, geom_boxplot() funzionerà meglio se lo capovolgete di 90°. Potete farlo con coord_flip().","code":"\nggplot(data = diamonds, mapping = aes(x = price)) + \n  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)\nggplot(diamonds) + \n  geom_bar(mapping = aes(x = cut))\nggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + \n  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)\n#> Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `after_stat(density)` instead.\nggplot(data = diamonds, mapping = aes(x = cut, y = price)) +\n  geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot()\nggplot(data = mpg) +\n  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy))\nggplot(data = mpg) +\n  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +\n  coord_flip()"},{"path":"analisi-esplorativa.html","id":"esercizi-17","chapter":"7 Analisi esplorativa","heading":"7.5.1.1 Esercizi","text":"Usa ciò che hai imparato per migliorare la visualizzazione degli orari di partenza\ndei voli cancellati rispetto quelli non cancellati.Usa ciò che hai imparato per migliorare la visualizzazione degli orari di partenza\ndei voli cancellati rispetto quelli non cancellati.Quale variabile nel dataset dei diamanti è più importante per prevedere\nil prezzo di un diamante? Come è correlata questa variabile con il taglio?\nPerché la combinazione di queste due relazioni fa sì che diamanti di qualità inferiore\npiù costosi diamanti di qualità inferiore?Quale variabile nel dataset dei diamanti è più importante per prevedere\nil prezzo di un diamante? Come è correlata questa variabile con il taglio?\nPerché la combinazione di queste due relazioni fa sì che diamanti di qualità inferiore\npiù costosi diamanti di qualità inferiore?Installate il pacchetto ggstance e create un boxplot orizzontale.\nCome si confronta questo con l’uso di coord_flip()?Installate il pacchetto ggstance e create un boxplot orizzontale.\nCome si confronta questo con l’uso di coord_flip()?Un problema con boxplot è che sono stati sviluppati un’era di\ndi insiemi di dati molto più piccoli e tendono visualizzare un proibitivo\nun numero proibitivo di “valori anomali”. Un approccio per rimediare questo problema è\nil plot del valore delle lettere. Installate il pacchetto lvplot e provate ad usare\ngeom_lv() per visualizzare la distribuzione del prezzo rispetto al taglio. Cosa\nimparate? Come interpretate grafici?Un problema con boxplot è che sono stati sviluppati un’era di\ndi insiemi di dati molto più piccoli e tendono visualizzare un proibitivo\nun numero proibitivo di “valori anomali”. Un approccio per rimediare questo problema è\nil plot del valore delle lettere. Installate il pacchetto lvplot e provate ad usare\ngeom_lv() per visualizzare la distribuzione del prezzo rispetto al taglio. Cosa\nimparate? Come interpretate grafici?Confrontate e contrastate geom_violin() con un geom_histogram() sfaccettato,\no un geom_freqpoly() colorato. Quali sono pro e contro di ciascun\nmetodo?Confrontate e contrastate geom_violin() con un geom_histogram() sfaccettato,\no un geom_freqpoly() colorato. Quali sono pro e contro di ciascun\nmetodo?Se avete un piccolo set di dati, volte è utile usare geom_jitter()\nper vedere la relazione tra una variabile continua e una categorica.\nIl pacchetto ggbeeswarm fornisce una serie di metodi simili \ngeom_jitter(). Elencateli e descrivete brevemente cosa fa ciascuno di essi.Se avete un piccolo set di dati, volte è utile usare geom_jitter()\nper vedere la relazione tra una variabile continua e una categorica.\nIl pacchetto ggbeeswarm fornisce una serie di metodi simili \ngeom_jitter(). Elencateli e descrivete brevemente cosa fa ciascuno di essi.","code":""},{"path":"analisi-esplorativa.html","id":"due-variabili-categoriche","chapter":"7 Analisi esplorativa","heading":"7.5.2 Due variabili categoriche","text":"Per visualizzare la covariazione tra variabili categoriche, avrete bisogno di contare il numero di osservazioni per ogni combinazione. Un modo per farlo è affidarsi al built-geom_count():La dimensione di ogni cerchio nel grafico mostra quante osservazioni si sono verificate per ogni combinazione di valori. La covariazione apparirà come una forte correlazione tra specifici valori x e specifici valori y.Un altro approccio è quello di calcolare il conteggio con dplyr:Poi visualizzate con geom_tile() e il riempimento estetico:Se le variabili categoriche non sono ordinate, potreste voler usare il pacchetto seriation per riordinare simultaneamente le righe e le colonne modo da rivelare più chiaramente modelli interessanti. Per grafici più grandi, potreste provare pacchetti d3heatmap o heatmaply, che creano grafici interattivi.","code":"\nggplot(data = diamonds) +\n  geom_count(mapping = aes(x = cut, y = color))\ndiamonds %>% \n  count(color, cut)\n#> # A tibble: 35 × 3\n#>   color cut           n\n#>   <ord> <ord>     <int>\n#> 1 D     Fair        163\n#> 2 D     Good        662\n#> 3 D     Very Good  1513\n#> 4 D     Premium    1603\n#> 5 D     Ideal      2834\n#> 6 E     Fair        224\n#> # … with 29 more rows\ndiamonds %>% \n  count(color, cut) %>%  \n  ggplot(mapping = aes(x = color, y = cut)) +\n    geom_tile(mapping = aes(fill = n))"},{"path":"analisi-esplorativa.html","id":"esercizi-18","chapter":"7 Analisi esplorativa","heading":"7.5.2.1 Esercizi","text":"Come potreste ridimensionare il dataset di conteggio di cui sopra per mostrare più chiaramente\nla distribuzione del taglio nel colore o del colore nel taglio?Come potreste ridimensionare il dataset di conteggio di cui sopra per mostrare più chiaramente\nla distribuzione del taglio nel colore o del colore nel taglio?Usate geom_tile() insieme dplyr per esplorare come ritardi medi dei voli\nper la destinazione e il mese dell’anno. Cosa rende il\ndifficile da leggere? Come potreste migliorarlo?Usate geom_tile() insieme dplyr per esplorare come ritardi medi dei voli\nper la destinazione e il mese dell’anno. Cosa rende il\ndifficile da leggere? Come potreste migliorarlo?Perché è leggermente meglio usare aes(x = color, y = cut) piuttosto che aes(x = cut, y = color) nell’esempio sopra?\npiuttosto che aes(x = cut, y = color) nell’esempio sopra?Perché è leggermente meglio usare aes(x = color, y = cut) piuttosto che aes(x = cut, y = color) nell’esempio sopra?\npiuttosto che aes(x = cut, y = color) nell’esempio sopra?","code":""},{"path":"analisi-esplorativa.html","id":"due-variabili-continue","chapter":"7 Analisi esplorativa","heading":"7.5.3 Due variabili continue","text":"Avete già visto un ottimo modo per visualizzare la covariazione tra due variabili continue: disegnare uno scatterplot con geom_point(). Potete vedere la covariazione come un modello nei punti. Per esempio, potete vedere una relazione esponenziale tra la dimensione del carato e il prezzo di un diamante.Gli scatterplot diventano meno utili man mano che la dimensione del tuo set di dati cresce, perché punti cominciano sovrapporsi e si accumulano aree di nero uniforme (come sopra). Hai già visto un modo per risolvere il problema: usare l’estetica alpha per aggiungere trasparenza.Ma usare la trasparenza può essere impegnativo per insiemi di dati molto grandi. Un’altra soluzione è usare bin. precedenza avete usato geom_histogram() e geom_freqpoly() per ‘binare’ una dimensione. Ora imparerete come usare geom_bin2d() e geom_hex() per ‘binare’ due dimensioni.geom_bin2d() e geom_hex() dividono il piano delle coordinate bin 2d e poi usano un colore di riempimento per mostrare quanti punti rientrano ogni bin. La funzione geom_bin2d() crea dei contenitori rettangolari. geom_hex() crea bin esagonali. Avrai bisogno di installare il pacchetto hexbin per usare geom_hex().Un’altra opzione è quella di binare una variabile continua modo che si comporti come una variabile categorica. Poi puoi usare una delle tecniche per visualizzare la combinazione di una variabile categorica e una continua che hai imparato. Per esempio, potreste classificare carat e poi, per ogni gruppo, visualizzare un boxplot:cut_width(x, width), come usato sopra, divide x bins di larghezza width. Per default, boxplot hanno ’incirca lo stesso aspetto (parte il numero di outlier) indipendentemente dal numero di osservazioni, quindi è difficile dire che ogni boxplot riassume un numero diverso di punti. Un modo per mostrarlo è rendere la larghezza del boxplot proporzionale al numero di punti con varwidth = TRUE.Un altro approccio è quello di visualizzare approssimativamente lo stesso numero di punti ogni bin. Questo è il compito di cut_number():","code":"\nggplot(data = diamonds) +\n  geom_point(mapping = aes(x = carat, y = price))\nggplot(data = diamonds) + \n  geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100)\nggplot(data = smaller) +\n  geom_bin2d(mapping = aes(x = carat, y = price))\n\n# install.packages(\"hexbin\")\nggplot(data = smaller) +\n  geom_hex(mapping = aes(x = carat, y = price))\nggplot(data = smaller, mapping = aes(x = carat, y = price)) + \n  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)))\nggplot(data = smaller, mapping = aes(x = carat, y = price)) + \n  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))"},{"path":"analisi-esplorativa.html","id":"esercizi-19","chapter":"7 Analisi esplorativa","heading":"7.5.3.1 Esercizi","text":"Invece di riassumere la distribuzione condizionale con un boxplot, si\npotrebbe usare un poligono di frequenza. Cosa dovete considerare quando usate\ncut_width() vs cut_number()? Che impatto ha su una visualizzazione di\nla distribuzione 2d di carat e price?Invece di riassumere la distribuzione condizionale con un boxplot, si\npotrebbe usare un poligono di frequenza. Cosa dovete considerare quando usate\ncut_width() vs cut_number()? Che impatto ha su una visualizzazione di\nla distribuzione 2d di carat e price?Visualizzate la distribuzione dei carati, suddivisa per prezzo.Visualizzate la distribuzione dei carati, suddivisa per prezzo.Come fa la distribuzione del prezzo dei diamanti molto grandi paragonarsi ai piccoli diamanti?\ndiamanti piccoli? È come ti aspetti o ti sorprende?Come fa la distribuzione del prezzo dei diamanti molto grandi paragonarsi ai piccoli diamanti?\ndiamanti piccoli? È come ti aspetti o ti sorprende?Combinate due delle tecniche che avete imparato per visualizzare la\ndistribuzione combinata di taglio, caratura e prezzo.Combinate due delle tecniche che avete imparato per visualizzare la\ndistribuzione combinata di taglio, caratura e prezzo.grafici bidimensionali rivelano valori anomali che non sono visibili quelli monodimensionali.\ndimensionale. Per esempio, alcuni punti nel grafico sottostante hanno una\ncombinazione insolita di valori x e y, che rende punti anomali\nanche se loro valori x e y sembrano normali se esaminati separatamente.\n\nggplot(data = diamonds) +\n  geom_point(mapping = aes(x = x, y = y)) +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\nPerché un grafico dispersione è una visualizzazione migliore di un grafico celle per questo caso?grafici bidimensionali rivelano valori anomali che non sono visibili quelli monodimensionali.\ndimensionale. Per esempio, alcuni punti nel grafico sottostante hanno una\ncombinazione insolita di valori x e y, che rende punti anomali\nanche se loro valori x e y sembrano normali se esaminati separatamente.Perché un grafico dispersione è una visualizzazione migliore di un grafico celle per questo caso?","code":"\nggplot(data = diamonds) +\n  geom_point(mapping = aes(x = x, y = y)) +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))"},{"path":"analisi-esplorativa.html","id":"schemi-e-modelli","chapter":"7 Analisi esplorativa","heading":"7.6 Schemi e modelli","text":"Gli schemi nei tuoi dati forniscono indizi sulle relazioni. Se esiste una relazione sistematica tra due variabili, essa apparirà come un modello nei dati. Se individuate un modello, chiedetevi:Questo modello potrebbe essere dovuto alla coincidenza (cioè al caso)?Questo modello potrebbe essere dovuto alla coincidenza (cioè al caso)?Come puoi descrivere la relazione implicita nel modello?Come puoi descrivere la relazione implicita nel modello?Quanto è forte la relazione implicita nello schema?Quanto è forte la relazione implicita nello schema?Quali altre variabili potrebbero influenzare la relazione?Quali altre variabili potrebbero influenzare la relazione?La relazione cambia se si guardano singoli sottogruppi dei dati?La relazione cambia se si guardano singoli sottogruppi dei dati?Un grafico dispersione della lunghezza delle eruzioni dell’Old Faithful rispetto al tempo di attesa tra le eruzioni mostra un modello: tempi di attesa più lunghi sono associati eruzioni più lunghe. Lo scatterplot mostra anche due cluster che abbiamo notato sopra.Gli schemi forniscono uno degli strumenti più utili per gli scienziati dei dati perché rivelano la covariazione. Se si pensa alla variazione come un fenomeno che crea incertezza, la covariazione è un fenomeno che la riduce. Se due variabili covariano, puoi usare valori di una variabile per fare previsioni migliori sui valori della seconda. Se la covariazione è dovuta una relazione causale (un caso speciale), allora si può usare il valore di una variabile per controllare il valore della seconda.modelli sono uno strumento per estrarre modelli dai dati. Per esempio, considerate dati sui diamanti. È difficile capire la relazione tra taglio e prezzo, perché taglio e carato, e carato e prezzo sono strettamente correlati. È possibile utilizzare un modello per rimuovere la relazione molto forte tra prezzo e carato modo da poter esplorare le sottigliezze che rimangono. Il codice seguente adatta un modello che predice il price dal carat e poi calcola residui (la differenza tra il valore predetto e il valore reale). residui ci danno una visione del prezzo del diamante, una volta rimosso l’effetto della caratura.Una volta eliminata la forte relazione tra carati e prezzo, si può vedere ciò che ci si aspetta nella relazione tra taglio e prezzo: relazione alle loro dimensioni, diamanti di migliore qualità sono più costosi.Imparerai come funzionano modelli e il pacchetto modelr nella parte finale del libro, modellare. Teniamo la modellazione per dopo perché capire cosa sono modelli e come funzionano è più facile una volta che si hanno mano gli strumenti di gestione dei dati e di programmazione.","code":"\nggplot(data = faithful) + \n  geom_point(mapping = aes(x = eruptions, y = waiting))\nlibrary(modelr)\n\nmod <- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 <- diamonds %>% \n  add_residuals(mod) %>% \n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) + \n  geom_point(mapping = aes(x = carat, y = resid))\nggplot(data = diamonds2) + \n  geom_boxplot(mapping = aes(x = cut, y = resid))"},{"path":"analisi-esplorativa.html","id":"chiamate-ggplot2","chapter":"7 Analisi esplorativa","heading":"7.7 Chiamate ggplot2","text":"Man mano che passeremo da questi capitoli introduttivi, passeremo ad un’espressione più concisa del codice ggplot2. Finora siamo stati molto espliciti, il che è utile quando si sta imparando:Tipicamente, primi uno o due argomenti di una funzione sono così importanti che dovreste conoscerli memoria. primi due argomenti di ggplot() sono data e mapping, e primi due argomenti di aes() sono x e y. Nel resto del libro, non forniremo questi nomi. Questo risparmia la digitazione e, riducendo la quantità di boilerplate, rende più facile vedere cosa c’è di diverso tra le trame. Questa è una preoccupazione di programmazione molto importante che torneremo funzioni.Riscrivendo la trama precedente modo più conciso si ottiene:volte trasformeremo la fine di una pipeline di trasformazione dei dati una trama. Fate attenzione alla transizione da %>% +. Vorrei che questa transizione non fosse necessaria, ma sfortunatamente ggplot2 è stato creato prima che il tubo fosse scoperto.","code":"\nggplot(data = faithful, mapping = aes(x = eruptions)) + \n  geom_freqpoly(binwidth = 0.25)\nggplot(faithful, aes(eruptions)) + \n  geom_freqpoly(binwidth = 0.25)\ndiamonds %>% \n  count(cut, clarity) %>% \n  ggplot(aes(clarity, cut, fill = n)) + \n    geom_tile()"},{"path":"analisi-esplorativa.html","id":"per-saperne-di-più","chapter":"7 Analisi esplorativa","heading":"7.8 Per saperne di più","text":"Se vuoi imparare di più sui meccanismi di ggplot2, ti consiglio vivamente di prendere una copia del libro ggplot2: https://amzn.com/331924275X. È stato recentemente aggiornato, quindi include il codice di dplyr e tidyr, e ha molto più spazio per esplorare tutte le sfaccettature della visualizzazione. Sfortunatamente il libro non è generalmente disponibile gratuitamente, ma se avete una connessione con un’università potete probabilmente ottenere una versione elettronica gratuita attraverso SpringerLink.Un’altra risorsa utile è il R Graphics Cookbook di Winston Chang. Gran parte dei contenuti sono disponibili online su http://www.cookbook-r.com/Graphs/.Raccomando anche Graphical Data Analysis R, di Antony Unwin. Questo è un libro di lunghezza simile al materiale trattato questo capitolo, ma ha lo spazio per andare molto più profondità.","code":""},{"path":"workflow-progetti.html","id":"workflow-progetti","chapter":"8 Workflow: progetti","heading":"8 Workflow: progetti","text":"Un giorno avrete bisogno di lasciare R, andare fare qualcos’altro e tornare alla vostra analisi il giorno dopo. Un giorno lavorerete su più analisi contemporaneamente che usano tutte R e volete tenerle separate. Un giorno avrete bisogno di portare dati dal mondo esterno R e inviare risultati numerici e cifre da R al mondo esterno. Per gestire queste situazioni di vita reale, dovete prendere due decisioni:Cosa della vostra analisi è “reale”, cioè cosa salverete come registrazione duratura di ciò che è successo?Cosa della vostra analisi è “reale”, cioè cosa salverete come registrazione duratura di ciò che è successo?Dove “vive” la vostra analisi?Dove “vive” la vostra analisi?","code":""},{"path":"workflow-progetti.html","id":"cosa-è-reale","chapter":"8 Workflow: progetti","heading":"8.1 Cosa è reale?","text":"Come utente alle prime armi di R, va bene considerare il vostro ambiente (cioè gli oggetti elencati nel pannello dell’ambiente) “reale”. Tuttavia, lungo termine, migliorerete molto se considerate vostri script R come “reali”.Con vostri script R (e vostri file di dati), potete ricreare l’ambiente. È molto più difficile ricreare vostri script R dal vostro ambiente! Dovrete riscrivere un sacco di codice memoria (commettendo errori per tutto il tempo) o dovrete scavare attentamente nella vostra storia di R.Per favorire questo comportamento, vi consiglio vivamente di istruire RStudio non conservare il vostro spazio di lavoro tra le sessioni:Questo vi causerà un po’ di grattacapi breve termine, perché ora quando riavvierete RStudio non ricorderà risultati del codice che avete eseguito l’ultima volta. Ma questi problemi breve termine vi risparmieranno un’agonia lungo termine perché vi costringe catturare tutte le interazioni importanti nel vostro codice. Non c’è niente di peggio che scoprire tre mesi dopo il fatto che avete memorizzato solo risultati di un calcolo importante nel vostro spazio di lavoro, non il calcolo stesso nel vostro codice.C’è una comoda coppia di scorciatoie da tastiera che lavorano insieme per assicurarsi di aver catturato le parti importanti del vostro codice nell’editor:Premi Cmd/Ctrl + Shift + F10 per riavvare RStudio.Premi Cmd/Ctrl + Shift + S per ricompilare lo script corrente.Uso questo schema centinaia di volte alla settimana.","code":""},{"path":"workflow-progetti.html","id":"dove-vive-la-vostra-analisi","chapter":"8 Workflow: progetti","heading":"8.2 Dove vive la vostra analisi?","text":"R ha una potente nozione di cartella di lavoro. Questa è dove R cerca file che gli chiedete di caricare, e dove metterà qualsiasi file che gli chiedete di salvare. RStudio mostra la vostra directory di lavoro corrente cima alla console:E potete stamparlo nel codice R eseguendo getwd():Come utente principiante di R, va bene lasciare che la vostra directory home, la directory documenti, o qualsiasi altra directory strana sul vostro computer sia la directory di lavoro di R. Ma hai letto sei capitoli di questo libro, e non sei più un principiante. Molto presto dovreste evolvere nell’organizzare vostri progetti analitici directory e, quando lavorate su un progetto, impostare la directory di lavoro di R nella directory associata.Non ve lo consiglio, ma potete anche impostare la directory di lavoro dall’interno di R:Ma non dovresti mai farlo perché c’è un modo migliore; un modo che ti mette anche sulla strada per gestire il tuo lavoro di R come un esperto.","code":"\ngetwd()\n#> [1] \"/Users/hadley/Documents/r4ds/r4ds\"\nsetwd(\"/path/to/my/CoolProject\")"},{"path":"workflow-progetti.html","id":"percorsi-e-directory","chapter":"8 Workflow: progetti","heading":"8.3 Percorsi e directory","text":"percorsi (path) e le directory sono un po’ complicati perché ci sono due stili di base di percorsi: Mac/Linux e Windows. Ci sono tre modi principali cui differiscono:La differenza più importante è come si separano componenti del\npercorso. Mac e Linux usano gli slash (ad esempio, plots/diamonds.pdf) e Windows\nusa backslash (es. plots\\diamonds.pdf). R può lavorare con entrambi tipi\n(non importa quale piattaforma tu stia usando), ma sfortunatamente,\nbackslash hanno un significato speciale per R, e per ottenere un singolo backslash\nnel percorso, devi digitare due backslash! Questo rende la vita frustrante,\nquindi raccomando di usare sempre lo stile Linux/Mac con le barre avanti.La differenza più importante è come si separano componenti del\npercorso. Mac e Linux usano gli slash (ad esempio, plots/diamonds.pdf) e Windows\nusa backslash (es. plots\\diamonds.pdf). R può lavorare con entrambi tipi\n(non importa quale piattaforma tu stia usando), ma sfortunatamente,\nbackslash hanno un significato speciale per R, e per ottenere un singolo backslash\nnel percorso, devi digitare due backslash! Questo rende la vita frustrante,\nquindi raccomando di usare sempre lo stile Linux/Mac con le barre avanti.percorsi assoluti (cioè percorsi che puntano allo stesso posto indipendentemente dalla\nla vostra directory di lavoro) hanno un aspetto diverso. Windows iniziano con una lettera di unità\n(ad esempio, C:) o due barre rovesciate (ad esempio, \\servername) e \nMac/Linux iniziano con una barra “/” (es. /users/hadley). Non si dovrebbero\nmai usare percorsi assoluti nei vostri script, perché ostacolano la condivisione:\nnessun altro avrà esattamente la stessa configurazione di directory che avete voi.percorsi assoluti (cioè percorsi che puntano allo stesso posto indipendentemente dalla\nla vostra directory di lavoro) hanno un aspetto diverso. Windows iniziano con una lettera di unità\n(ad esempio, C:) o due barre rovesciate (ad esempio, \\servername) e \nMac/Linux iniziano con una barra “/” (es. /users/hadley). Non si dovrebbero\nmai usare percorsi assoluti nei vostri script, perché ostacolano la condivisione:\nnessun altro avrà esattamente la stessa configurazione di directory che avete voi.L’ultima piccola differenza è il posto cui punta ~. ~ è una\ncomoda scorciatoia per la tua home directory. Windows non ha davvero\nla nozione di una home directory, quindi punta invece alla tua directory dei documenti.L’ultima piccola differenza è il posto cui punta ~. ~ è una\ncomoda scorciatoia per la tua home directory. Windows non ha davvero\nla nozione di una home directory, quindi punta invece alla tua directory dei documenti.","code":""},{"path":"workflow-progetti.html","id":"progetti-rstudio","chapter":"8 Workflow: progetti","heading":"8.4 Progetti RStudio","text":"Gli esperti di R tengono tutti file associati ad un progetto insieme — dati di input, script R, risultati analitici, figure. Questa è una pratica così saggia e comune che RStudio ha un supporto integrato per questo tramite projects.Creiamo un progetto da usare mentre lavorate al resto di questo libro. Cliccate su File > New Project, quindi:Chiama il tuo progetto r4ds e pensa attentamente quale sottodirectory metti il progetto. Se non lo memorizzate un posto sensato, sarà difficile trovarlo futuro!Una volta completato questo processo, avrete un nuovo progetto RStudio solo per questo libro. Controllate che la directory “home” del vostro progetto sia la directory di lavoro corrente:Ogni volta che si fa riferimento un file con un percorso relativo, esso lo cercherà qui.Ora inserite seguenti comandi nell’editor di script e salvate il file, chiamandolo “diamonds.R”. Successivamente, esegui lo script completo che salverà un file PDF e CSV nella directory del tuo progetto. Non preoccupatevi dei dettagli, li imparerete più avanti nel libro.Uscire da RStudio. Ispeziona la cartella associata al tuo progetto — nota il file .Rproj. Fai doppio clic su quel file per riaprire il progetto. Notate che tornate al punto cui avete lasciato: è la stessa directory di lavoro e la stessa cronologia dei comandi, e tutti file su cui stavate lavorando sono ancora aperti. Poiché hai seguito le mie istruzioni sopra, avrai comunque un ambiente completamente nuovo, garantendoti che stai iniziando con una tabula rasa.Nel tuo modo preferito, specifico per il sistema operativo, cerca sul tuo computer diamonds.pdf e troverai il PDF (nessuna sorpresa) ma anche lo script che lo ha creato (diamonds.R). Questa è una grande vittoria! Un giorno vorrete rifare una figura o semplicemente capire da dove viene. Se salvate rigorosamente le figure su file con il codice R e mai con il mouse o gli appunti, sarete grado di riprodurre il vecchio lavoro con facilità!","code":"\ngetwd()\n#> [1] /Users/hadley/Documents/r4ds/r4ds\nlibrary(tidyverse)\n\nggplot(diamonds, aes(carat, price)) + \n  geom_hex()\nggsave(\"diamonds.pdf\")\n\nwrite_csv(diamonds, \"diamonds.csv\")"},{"path":"workflow-progetti.html","id":"riassunto","chapter":"8 Workflow: progetti","heading":"8.5 Riassunto","text":"sintesi, progetti RStudio vi danno un solido flusso di lavoro che vi servirà bene futuro:Creare un progetto RStudio per ogni progetto di analisi dei dati.Creare un progetto RStudio per ogni progetto di analisi dei dati.Conservate lì file di dati; parleremo del loro caricamento R importazione dei dati.Conservate lì file di dati; parleremo del loro caricamento R importazione dei dati.Tieni lì gli script; modificali, eseguili pezzi o nella loro interezza.Tieni lì gli script; modificali, eseguili pezzi o nella loro interezza.Salva tuoi output (grafici e dati puliti) lì.Salva tuoi output (grafici e dati puliti) lì.Usa sempre e solo percorsi relativi, non assoluti.Usa sempre e solo percorsi relativi, non assoluti.Tutto ciò di cui hai bisogno è un unico posto, e separato modo pulito da tutti gli altri progetti su cui stai lavorando.","code":""},{"path":"wrangle-intro.html","id":"wrangle-intro","chapter":"9 Introduzione","heading":"9 Introduzione","text":"questa parte del libro, imparerete il data wrangling, l’arte di portare vostri dati R una forma utile per la visualizzazione e la modellazione. Il data wrangling è molto importante: senza di esso non potete lavorare con vostri dati! Ci sono tre parti principali per il data wrangling:Questa parte del libro procede come segue:tibble, imparerete la variante del data frame che usiamo questo libro: il tibble. Imparerete cosa li rende diversi dai normali data frame, e come potete costruirli “mano”.tibble, imparerete la variante del data frame che usiamo questo libro: il tibble. Imparerete cosa li rende diversi dai normali data frame, e come potete costruirli “mano”.importazione dei dati, imparerete come prendere vostri dati dal disco e inserirli R. Ci concentreremo sui formati rettangolari di testo semplice, ma vi daremo dei riferimenti pacchetti che aiutano con altri tipi di dati.importazione dei dati, imparerete come prendere vostri dati dal disco e inserirli R. Ci concentreremo sui formati rettangolari di testo semplice, ma vi daremo dei riferimenti pacchetti che aiutano con altri tipi di dati.tidy data, imparerete conoscere tidy data, un modo coerente di memorizzare vostri dati che rende più facile la trasformazione, la visualizzazione e la modellazione. Imparerete principi di base, e come ottenere vostri dati una forma ordinata.tidy data, imparerete conoscere tidy data, un modo coerente di memorizzare vostri dati che rende più facile la trasformazione, la visualizzazione e la modellazione. Imparerete principi di base, e come ottenere vostri dati una forma ordinata.Il data wrangling comprende anche la trasformazione dei dati, di cui avete già imparato qualcosa. Ora ci concentreremo sulle nuove competenze per tre tipi specifici di dati che incontrerete spesso nella pratica:Dati relazionali vi darà gli strumenti per lavorare con più insiemi di dati interconnessi.Dati relazionali vi darà gli strumenti per lavorare con più insiemi di dati interconnessi.Stringhe introdurrà le espressioni regolari, un potente strumento per manipolare le stringhe.Stringhe introdurrà le espressioni regolari, un potente strumento per manipolare le stringhe.Fattori sono il modo cui R memorizza dati categorici. Sono usati quando una variabile ha un insieme fisso di valori possibili, o quando si vuole usare un ordinamento non alfabetico di una stringa.Fattori sono il modo cui R memorizza dati categorici. Sono usati quando una variabile ha un insieme fisso di valori possibili, o quando si vuole usare un ordinamento non alfabetico di una stringa.Date e tempi vi darà gli strumenti chiave per lavorare con date e date-ora.Date e tempi vi darà gli strumenti chiave per lavorare con date e date-ora.","code":""},{"path":"tibble.html","id":"tibble","chapter":"10 Tibble","heading":"10 Tibble","text":"","code":""},{"path":"tibble.html","id":"introduzione-4","chapter":"10 Tibble","heading":"10.1 Introduzione","text":"questo libro lavoriamo con “tibble” invece dei tradizionali data.frame di R. tibble sono data frame, ma modificano alcuni vecchi comportamenti per renderci la vita un po’ più facile. R è un vecchio linguaggio, e alcune cose che erano utili 10 o 20 anni fa ora intralciano. È difficile cambiare la base di R senza rompere il codice esistente, così la maggior parte dell’innovazione avviene nei pacchetti. Qui descriveremo il pacchetto tibble, che fornisce frame di dati opinionati che rendono il lavoro nel tidyverse un po’ più facile. Nella maggior parte dei punti, userò il termine tibble e data frame modo intercambiabile; quando voglio attirare l’attenzione sui data frame integrati R, li chiamerò data.frame.Se questo capitolo vi lascia la voglia di imparare di più sulle tibbie, potreste godervi la vignette(\"tibble\").","code":""},{"path":"tibble.html","id":"prerequisiti-4","chapter":"10 Tibble","heading":"10.1.1 Prerequisiti","text":"questo capitolo esploreremo il pacchetto tibble, parte del core tidyverse.","code":"\nlibrary(tidyverse)"},{"path":"tibble.html","id":"creare-una-tibble","chapter":"10 Tibble","heading":"10.2 Creare una tibble","text":"Quasi tutte le funzioni che userete questo libro producono tibble, poiché le tibble sono una delle caratteristiche unificanti del tidyverse. La maggior parte degli altri pacchetti di R usa normali data frame, quindi potreste voler forzare un data frame una tibble. Potete farlo con as_tibble():Potete creare un nuovo tibble da vettori individuali con tibble(). La funzione tibble() ricicla automaticamente gli input di lunghezza 1, e vi permette di fare riferimento alle variabili che avete appena creato, come mostrato qui sotto.Se avete già familiarità con data.frame(), notate che tibble() fa molto meno: non cambia mai il tipo di input (ad esempio non converte mai le stringhe fattori!), non cambia mai nomi delle variabili, e non crea mai nomi di righe.È possibile che un tibble abbia nomi di colonne che non sono nomi di variabili R validi, anche detti nomi non-sintattici. Per esempio, potrebbero non iniziare con una lettera, o potrebbero contenere caratteri insoliti come uno spazio. Per fare riferimento queste variabili, avete bisogno di circondarle con backtick, `:Avrete anche bisogno dei backtick quando lavorerete con queste variabili altri pacchetti, come ggplot2, dplyr e tidyr.Un altro modo per creare un tibble è con tribble(), abbreviazione di transposed tibble. tribble() è personalizzato per l’inserimento dei dati nel codice: le intestazioni delle colonne sono definite da formule (cioè iniziano con ~), e le voci sono separate da virgole. Questo rende possibile la disposizione di piccole quantità di dati forma facilmente leggibile.Spesso aggiungo un commento (la linea che inizia con #), per rendere davvero chiaro dove si trova l’intestazione.","code":"\nas_tibble(iris)\n#> # A tibble: 150 × 5\n#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>          <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#> 1          5.1         3.5          1.4         0.2 setosa \n#> 2          4.9         3            1.4         0.2 setosa \n#> 3          4.7         3.2          1.3         0.2 setosa \n#> 4          4.6         3.1          1.5         0.2 setosa \n#> 5          5           3.6          1.4         0.2 setosa \n#> 6          5.4         3.9          1.7         0.4 setosa \n#> # … with 144 more rows\ntibble(\n  x = 1:5, \n  y = 1, \n  z = x ^ 2 + y\n)\n#> # A tibble: 5 × 3\n#>       x     y     z\n#>   <int> <dbl> <dbl>\n#> 1     1     1     2\n#> 2     2     1     5\n#> 3     3     1    10\n#> 4     4     1    17\n#> 5     5     1    26\ntb <- tibble(\n  `:)` = \"smile\", \n  ` ` = \"space\",\n  `2000` = \"number\"\n)\ntb\n#> # A tibble: 1 × 3\n#>   `:)`  ` `   `2000`\n#>   <chr> <chr> <chr> \n#> 1 smile space number\ntribble(\n  ~x, ~y, ~z,\n  #--|--|----\n  \"a\", 2, 3.6,\n  \"b\", 1, 8.5\n)\n#> # A tibble: 2 × 3\n#>   x         y     z\n#>   <chr> <dbl> <dbl>\n#> 1 a         2   3.6\n#> 2 b         1   8.5"},{"path":"tibble.html","id":"tibble-vs.-data.frame","chapter":"10 Tibble","heading":"10.3 Tibble vs. data.frame","text":"Ci sono due differenze principali nell’uso di un tibble rispetto un classico data.frame: stampa e sottoinsieme.","code":""},{"path":"tibble.html","id":"stampa","chapter":"10 Tibble","heading":"10.3.1 Stampa","text":"Le tibble hanno un metodo di stampa raffinato che mostra solo le prime 10 righe e tutte le colonne che si adattano allo schermo. Questo rende molto più facile lavorare con grandi quantità di dati. Oltre al suo nome, ogni colonna riporta il suo tipo, una bella caratteristica presa prestito da str():Le tibble sono progettate modo da non sovraccaricare accidentalmente la vostra console quando stampate grandi frame di dati. Ma volte avete bisogno di più output rispetto alla visualizzazione di default. Ci sono alcune opzioni che possono aiutare.Per prima cosa, potete esplicitamente print() il data frame e controllare il numero di righe (n) e la larghezza della visualizzazione. La larghezza = Inf visualizzerà tutte le colonne:Potete anche controllare il comportamento di stampa predefinito impostando le opzioni:options(tibble.print_max = n, tibble.print_min = m): se più di n\nrighe, stampa solo righe m. Usa options(tibble.print_min = Inf) per mostrare sempre\nmostrare sempre tutte le righe.options(tibble.print_max = n, tibble.print_min = m): se più di n\nrighe, stampa solo righe m. Usa options(tibble.print_min = Inf) per mostrare sempre\nmostrare sempre tutte le righe.Usa options(tibble.width = Inf) per stampare sempre tutte le colonne, indipendentemente\ndella larghezza dello schermo.Usa options(tibble.width = Inf) per stampare sempre tutte le colonne, indipendentemente\ndella larghezza dello schermo.Puoi vedere una lista completa di opzioni guardando l’aiuto del pacchetto con package?tibble.Un’ultima opzione è quella di usare il visualizzatore di dati integrato RStudio per ottenere una vista scorrimento dell’intero set di dati. Questo è spesso utile alla fine di una lunga catena di manipolazioni.","code":"\ntibble(\n  a = lubridate::now() + runif(1e3) * 86400,\n  b = lubridate::today() + runif(1e3) * 30,\n  c = 1:1e3,\n  d = runif(1e3),\n  e = sample(letters, 1e3, replace = TRUE)\n)\n#> # A tibble: 1,000 × 5\n#>   a                   b              c     d e    \n#>   <dttm>              <date>     <int> <dbl> <chr>\n#> 1 2023-02-18 01:14:29 2023-02-24     1 0.368 n    \n#> 2 2023-02-18 19:19:38 2023-03-01     2 0.612 l    \n#> 3 2023-02-18 13:43:18 2023-03-11     3 0.415 p    \n#> 4 2023-02-18 03:04:35 2023-03-10     4 0.212 m    \n#> 5 2023-02-17 23:28:51 2023-03-07     5 0.733 i    \n#> 6 2023-02-18 10:29:48 2023-03-03     6 0.460 n    \n#> # … with 994 more rows\nnycflights13::flights %>% \n  print(n = 10, width = Inf)\nnycflights13::flights %>% \n  View()"},{"path":"tibble.html","id":"subsetting","chapter":"10 Tibble","heading":"10.3.2 Subsetting","text":"Finora tutti gli strumenti che avete imparato hanno lavorato con data frame completi. Se volete estrarre una singola variabile, avete bisogno di alcuni nuovi strumenti, $ e [[. [[ può estrarre per nome o per posizione; $ estrae solo per nome, ma è un po’ meno digitabile.Per usarli una pipe, dovrete usare il segnaposto speciale .:Rispetto un data.frame, le tibble sono più rigide: non fanno mai corrispondenze parziali e generano un avviso se la colonna cui si sta cercando di accedere non esiste.","code":"\ndf <- tibble(\n  x = runif(5),\n  y = rnorm(5)\n)\n\n# Extract by name\ndf$x\n#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161\ndf[[\"x\"]]\n#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161\n\n# Extract by position\ndf[[1]]\n#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161\ndf %>% .$x\n#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161\ndf %>% .[[\"x\"]]\n#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161"},{"path":"tibble.html","id":"interagire-con-il-vecchio-codice","chapter":"10 Tibble","heading":"10.4 Interagire con il vecchio codice","text":"Alcune vecchie funzioni non funzionano con le tibble. Se incontrate una di queste funzioni, usate .data.frame() per trasformare un tibble un data.frame:La ragione principale per cui alcune vecchie funzioni non funzionano con tibble è la funzione [. Non usiamo molto la funzione [ questo libro perché dplyr::filter() e dplyr::select() vi permettono di risolvere gli stessi problemi con un codice più chiaro (ma ne imparerete qualcosa sottoinsiemi di vettori). Con data frame di base di R, [ volte restituisce un data frame e volte un vettore. Con le tibble, [ restituisce sempre un’altra tibble.","code":"\nclass(as.data.frame(tb))\n#> [1] \"data.frame\""},{"path":"tibble.html","id":"esercizi-20","chapter":"10 Tibble","heading":"10.5 Esercizi","text":"Come potete dire se un oggetto è una tibla? (Suggerimento: provate stampare mtcars,\nche è un normale data frame).Come potete dire se un oggetto è una tibla? (Suggerimento: provate stampare mtcars,\nche è un normale data frame).Confronta e contrasta le seguenti operazioni su un data.frame e\ntibble equivalente. Cosa c’è di diverso? Perché comportamenti predefiniti dei data frame\nvi causano frustrazione?\n\ndf <- data.frame(abc = 1, xyz = \"\")\ndf$x\ndf[, \"xyz\"]\ndf[, c(\"abc\", \"xyz\")]Confronta e contrasta le seguenti operazioni su un data.frame e\ntibble equivalente. Cosa c’è di diverso? Perché comportamenti predefiniti dei data frame\nvi causano frustrazione?Se avete il nome di una variabile memorizzata un oggetto, ad esempio var <- \"mpg\",\ncome potete estrarre la variabile di riferimento da una tibla?Se avete il nome di una variabile memorizzata un oggetto, ad esempio var <- \"mpg\",\ncome potete estrarre la variabile di riferimento da una tibla?Esercitati fare riferimento nomi non sintattici nel seguente data frame:\nEstrarre la variabile chiamata 1.\nTracciare uno scatterplot di 1 contro 2.\nCreare una nuova colonna chiamata 3 che è 2 divisa per 1.\nRinominare le colonne one, two e three.\n\nannoying <- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)Esercitati fare riferimento nomi non sintattici nel seguente data frame:Estrarre la variabile chiamata 1.Estrarre la variabile chiamata 1.Tracciare uno scatterplot di 1 contro 2.Tracciare uno scatterplot di 1 contro 2.Creare una nuova colonna chiamata 3 che è 2 divisa per 1.Creare una nuova colonna chiamata 3 che è 2 divisa per 1.Rinominare le colonne one, two e three.Rinominare le colonne one, two e three.Cosa fa tibble::enframe()? Quando potreste usarlo?Cosa fa tibble::enframe()? Quando potreste usarlo?Quale opzione controlla quanti nomi di colonna aggiuntivi vengono stampati\npiè di pagina di una tibble?Quale opzione controlla quanti nomi di colonna aggiuntivi vengono stampati\npiè di pagina di una tibble?","code":"\ndf <- data.frame(abc = 1, xyz = \"a\")\ndf$x\ndf[, \"xyz\"]\ndf[, c(\"abc\", \"xyz\")]\nannoying <- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)"},{"path":"importazione-dei-dati.html","id":"importazione-dei-dati","chapter":"11 Importazione dei dati","heading":"11 Importazione dei dati","text":"","code":""},{"path":"importazione-dei-dati.html","id":"introduzione-5","chapter":"11 Importazione dei dati","heading":"11.1 Introduzione","text":"Lavorare con dati forniti dai pacchetti di R è un ottimo modo per imparare gli strumenti della data science, ma ad un certo punto si vuole smettere di imparare e iniziare lavorare con propri dati. questo capitolo, imparerete come leggere file rettangolari di testo semplice R. Qui, gratteremo solo la superficie dell’importazione dei dati, ma molti dei principi saranno trasferiti ad altre forme di dati. Finiremo con alcune indicazioni di pacchetti che sono utili per altri tipi di dati.","code":""},{"path":"importazione-dei-dati.html","id":"prerequisiti-5","chapter":"11 Importazione dei dati","heading":"11.1.1 Prerequisiti","text":"questo capitolo imparerete come caricare file piatti R con il pacchetto readr, che fa parte del core tidyverse.","code":"\nlibrary(tidyverse)"},{"path":"importazione-dei-dati.html","id":"iniziamo","chapter":"11 Importazione dei dati","heading":"11.2 Iniziamo!","text":"La maggior parte delle funzioni di readr si occupa di trasformare file piatti data frame:read_csv() legge file delimitati da virgole, read_csv2() legge file separati da punto e virgola\nseparati da punto e virgola (comune nei paesi dove , è usato come posto decimale come l’Italia),\nread_tsv() legge file delimitati da tabulazione, e read_delim() legge file\ncon qualsiasi delimitatore.read_csv() legge file delimitati da virgole, read_csv2() legge file separati da punto e virgola\nseparati da punto e virgola (comune nei paesi dove , è usato come posto decimale come l’Italia),\nread_tsv() legge file delimitati da tabulazione, e read_delim() legge file\ncon qualsiasi delimitatore.read_fwf() legge file larghezza fissa. Potete specificare campi sia per la loro\nlarghezza con fwf_widths() o la loro posizione con fwf_positions().\nread_table() legge una variazione comune dei file larghezza fissa cui le colonne\nsono separate da spazi bianchi.read_fwf() legge file larghezza fissa. Potete specificare campi sia per la loro\nlarghezza con fwf_widths() o la loro posizione con fwf_positions().\nread_table() legge una variazione comune dei file larghezza fissa cui le colonne\nsono separate da spazi bianchi.read_log() legge file di log stile Apache. (Ma controllate anche\nwebreadr che è costruito sopra\nread_log() e fornisce molti altri strumenti utili).read_log() legge file di log stile Apache. (Ma controllate anche\nwebreadr che è costruito sopra\nread_log() e fornisce molti altri strumenti utili).Queste funzioni hanno tutte una sintassi simile: una volta che ne hai imparato una, puoi usare le altre con facilità. Per il resto di questo capitolo ci concentreremo su read_csv(). Non solo file csv sono una delle forme più comuni di memorizzazione dei dati, ma una volta che hai capito read_csv(), puoi facilmente applicare la tua conoscenza tutte le altre funzioni di readr.Il primo argomento di read_csv() è il più importante: è il percorso del file da leggere.Quando si esegue read_csv() viene stampata una specifica di colonna che fornisce il nome e il tipo di ogni colonna. Questa è una parte importante di readr, su cui torneremo analizzare un file.Puoi anche fornire un file csv linea. Questo è utile per sperimentare con readr e per creare esempi riproducibili da condividere con altri:entrambi casi read_csv() usa la prima riga dei dati per nomi delle colonne, che è una convenzione molto comune. Ci sono due casi cui si potrebbe voler modificare questo comportamento:volte ci sono alcune righe di metadati ’inizio del file. Si può\nusare skip = n per saltare le prime n linee; o usare comment = \"#\" per eliminare\ntutte le linee che iniziano con (per esempio) #.\n\nread_csv(\"first line metadata\n  second line metadata\n  x,y,z\n  1,2,3\", skip = 2)\n#> Rows: 1 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.\n#> # tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n\nread_csv(\"# comment want skip\n  x,y,z\n  1,2,3\", comment = \"#\")\n#> Rows: 1 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.\n#> # tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3A volte ci sono alcune righe di metadati ’inizio del file. Si può\nusare skip = n per saltare le prime n linee; o usare comment = \"#\" per eliminare\ntutte le linee che iniziano con (per esempio) #.dati potrebbero non avere nomi di colonna. Puoi usare col_names = FALSE per dire read_csv() di non trattare la prima riga come intestazioni, e invece etichettarle sequenzialmente da X1 Xn:\n\nread_csv(\"1,2,3\\n4,5,6\", col_names = FALSE)\n#> Rows: 2 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): X1, X2, X3\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.\n#> # tibble: 2 × 3\n#>      X1    X2    X3\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\n(\"\\n\" è una comoda scorciatoia per aggiungere una nuova riga. Imparerai di più su di essa e su altri tipi di escape delle stringhe nozioni di base sulle stringhe).\nalternativa puoi passare col_names un vettore di caratteri che sarà usato come nome delle colonne:\n\nread_csv(\"1,2,3\\n4,5,6\", col_names = c(\"x\", \"y\", \"z\"))\n#> Rows: 2 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.\n#> # tibble: 2 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6I dati potrebbero non avere nomi di colonna. Puoi usare col_names = FALSE per dire read_csv() di non trattare la prima riga come intestazioni, e invece etichettarle sequenzialmente da X1 Xn:(\"\\n\" è una comoda scorciatoia per aggiungere una nuova riga. Imparerai di più su di essa e su altri tipi di escape delle stringhe nozioni di base sulle stringhe).alternativa puoi passare col_names un vettore di caratteri che sarà usato come nome delle colonne:Un’altra opzione che comunemente ha bisogno di modifiche è na: questa specifica il valore (o valori) che sono usati per rappresentare valori mancanti nel tuo file:Questo è tutto ciò che dovete sapere per leggere ~75% dei file CSV che incontrerete nella pratica. Puoi anche adattare facilmente ciò che hai imparato per leggere file separati da tabulazione con read_tsv() e file larghezza fissa con read_fwf(). Per leggere file più impegnativi, avrete bisogno di imparare di più su come readr analizza ogni colonna, trasformandola vettori R.","code":"\nheights <- read_csv(\"data/heights.csv\")\n#> Rows: 1192 Columns: 6\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr (2): sex, race\n#> dbl (4): earn, height, ed, age\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nread_csv(\"a,b,c\n1,2,3\n4,5,6\")\n#> Rows: 2 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): a, b, c\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 2 × 3\n#>       a     b     c\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\nread_csv(\"The first line of metadata\n  The second line of metadata\n  x,y,z\n  1,2,3\", skip = 2)\n#> Rows: 1 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n\nread_csv(\"# A comment I want to skip\n  x,y,z\n  1,2,3\", comment = \"#\")\n#> Rows: 1 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 1 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\nread_csv(\"1,2,3\\n4,5,6\", col_names = FALSE)\n#> Rows: 2 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): X1, X2, X3\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 2 × 3\n#>      X1    X2    X3\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\nread_csv(\"1,2,3\\n4,5,6\", col_names = c(\"x\", \"y\", \"z\"))\n#> Rows: 2 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (3): x, y, z\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 2 × 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1     1     2     3\n#> 2     4     5     6\nread_csv(\"a,b,c\\n1,2,.\", na = \".\")\n#> Rows: 1 Columns: 3\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl (2): a, b\n#> lgl (1): c\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 1 × 3\n#>       a     b c    \n#>   <dbl> <dbl> <lgl>\n#> 1     1     2 NA"},{"path":"importazione-dei-dati.html","id":"rispetto-a-r-di-base","chapter":"11 Importazione dei dati","heading":"11.2.1 Rispetto a R di base","text":"Se avete usato R precedenza, potreste chiedervi perché non stiamo usando read.csv(). Ci sono alcune buone ragioni per favorire le funzioni readr rispetto alle equivalenti di base:Sono tipicamente molto più veloci (~10x) dei loro equivalenti di base.\nlavori lunghi hanno una barra di avanzamento, così puoi vedere cosa sta succedendo.\nSe state cercando la velocità pura, provate data.table::fread(). Non si adatta\ncosì bene al tidyverse, ma può essere un po’ più veloce.Sono tipicamente molto più veloci (~10x) dei loro equivalenti di base.\nlavori lunghi hanno una barra di avanzamento, così puoi vedere cosa sta succedendo.\nSe state cercando la velocità pura, provate data.table::fread(). Non si adatta\ncosì bene al tidyverse, ma può essere un po’ più veloce.Producono tibble, non convertono vettori di caratteri fattori,\nnon usano nomi delle righe, o non pasticciano nomi delle colonne. Queste sono fonti comuni di\nfrustrazione con le funzioni R di base.Producono tibble, non convertono vettori di caratteri fattori,\nnon usano nomi delle righe, o non pasticciano nomi delle colonne. Queste sono fonti comuni di\nfrustrazione con le funzioni R di base.Sono più riproducibili. Le funzioni R di base ereditano alcuni comportamenti dal\ndal vostro sistema operativo e dalle variabili d’ambiente, quindi il codice d’importazione che funziona\nsul vostro computer potrebbe non funzionare su quello di qualcun altro.Sono più riproducibili. Le funzioni R di base ereditano alcuni comportamenti dal\ndal vostro sistema operativo e dalle variabili d’ambiente, quindi il codice d’importazione che funziona\nsul vostro computer potrebbe non funzionare su quello di qualcun altro.","code":""},{"path":"importazione-dei-dati.html","id":"esercizi-21","chapter":"11 Importazione dei dati","heading":"11.2.2 Esercizi","text":"Quale funzione usereste per leggere un file cui campi sono separati con\n“|”?Quale funzione usereste per leggere un file cui campi sono separati con\n“|”?Oltre file, skip e comment, quali altri argomenti hanno\nread_csv() e read_tsv() hanno comune?Oltre file, skip e comment, quali altri argomenti hanno\nread_csv() e read_tsv() hanno comune?Quali sono gli argomenti più importanti di read_fwf()?Quali sono gli argomenti più importanti di read_fwf()?volte le stringhe un file CSV contengono virgole. Per evitare che\ncausare problemi, esse devono essere circondate da un carattere di citazione, come\n\" o '. Per default, read_csv() assume che il carattere di citazione\nsarà \". Quale argomento read_csv() devi specificare\nper leggere il seguente testo un frame di dati?\n\n\"x,y\\n1,',b'\"volte le stringhe un file CSV contengono virgole. Per evitare che\ncausare problemi, esse devono essere circondate da un carattere di citazione, come\n\" o '. Per default, read_csv() assume che il carattere di citazione\nsarà \". Quale argomento read_csv() devi specificare\nper leggere il seguente testo un frame di dati?Identifica cosa c’è di sbagliato ciascuno dei seguenti file CSV linea.\nCosa succede quando si esegue il codice?\n\nread_csv(\",b\\n1,2,3\\n4,5,6\")\nread_csv(\",b,c\\n1,2\\n1,2,3,4\")\nread_csv(\",b\\n\\\"1\")\nread_csv(\",b\\n1,2\\na,b\")\nread_csv(\";b\\n1;3\")Identifica cosa c’è di sbagliato ciascuno dei seguenti file CSV linea.\nCosa succede quando si esegue il codice?","code":"\n\"x,y\\n1,'a,b'\"\nread_csv(\"a,b\\n1,2,3\\n4,5,6\")\nread_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\nread_csv(\"a,b\\n\\\"1\")\nread_csv(\"a,b\\n1,2\\na,b\")\nread_csv(\"a;b\\n1;3\")"},{"path":"importazione-dei-dati.html","id":"analizzare-un-vettore","chapter":"11 Importazione dei dati","heading":"11.3 Analizzare un vettore","text":"Prima di entrare nei dettagli di come readr legge file dal disco, dobbiamo fare una piccola deviazione per parlare delle funzioni parse_*(). Queste funzioni prendono un vettore di caratteri e restituiscono un vettore più specializzato come un logico, un intero o una data:Queste funzioni sono utili di per sé, ma sono anche un importante elemento costitutivo di readr. Una volta che avrete imparato come funzionano singoli analizzatori questa sezione, torneremo indietro e vedremo come si adattano insieme per analizzare un file completo nella prossima sezione.Come tutte le funzioni del tidyverse, le funzioni parse_*() sono uniformi: il primo argomento è un vettore di caratteri da analizzare, e l’argomento na specifica quali stringhe dovrebbero essere trattate come mancanti:Se il parsing fallisce, riceverai un avviso:E fallimenti mancheranno nell’output:Se ci sono molti fallimenti nell’analisi, avrete bisogno di usare problems() per ottenere l’insieme completo. Questo restituisce una tibble, che potete poi manipolare con dplyr.Usare parser è soprattutto una questione di comprensione di ciò che è disponibile e di come trattano diversi tipi di input. Ci sono otto analizzatori particolarmente importanti:parse_logical() e parse_integer() analizzano logici e gli interi,\nrispettivamente. Non c’è praticamente nulla che possa andare storto con questi\nquindi non li descriverò ulteriormente qui.parse_logical() e parse_integer() analizzano logici e gli interi,\nrispettivamente. Non c’è praticamente nulla che possa andare storto con questi\nquindi non li descriverò ulteriormente qui.parse_double()è un parser numerico rigoroso, e parse_number()\nè un analizzatore numerico flessibile. Questi sono più complicati di quanto ci si possa\naspettare perché diverse parti del mondo scrivono numeri modi\nmodi diversi.parse_double()è un parser numerico rigoroso, e parse_number()\nè un analizzatore numerico flessibile. Questi sono più complicati di quanto ci si possa\naspettare perché diverse parti del mondo scrivono numeri modi\nmodi diversi.parse_character() sembra così semplice che non dovrebbe essere necessario. Ma\nuna complicazione lo rende abbastanza importante: le codifiche dei caratteri.parse_character() sembra così semplice che non dovrebbe essere necessario. Ma\nuna complicazione lo rende abbastanza importante: le codifiche dei caratteri.parse_factor() crea fattori, la struttura dati che R usa per rappresentare\nvariabili categoriche con valori fissi e noti.parse_factor() crea fattori, la struttura dati che R usa per rappresentare\nvariabili categoriche con valori fissi e noti.parse_datetime(), parse_date(), e parse_time() vi permettono di\nanalizzare varie specifiche di data e ora. Queste sono le più complicate\nperché ci sono molti modi diversi di scrivere le date.parse_datetime(), parse_date(), e parse_time() vi permettono di\nanalizzare varie specifiche di data e ora. Queste sono le più complicate\nperché ci sono molti modi diversi di scrivere le date.Le sezioni seguenti descrivono questi analizzatori modo più dettagliato.","code":"\nstr(parse_logical(c(\"TRUE\", \"FALSE\", \"NA\")))\n#>  logi [1:3] TRUE FALSE NA\nstr(parse_integer(c(\"1\", \"2\", \"3\")))\n#>  int [1:3] 1 2 3\nstr(parse_date(c(\"2010-01-01\", \"1979-10-14\")))\n#>  Date[1:2], format: \"2010-01-01\" \"1979-10-14\"\nparse_integer(c(\"1\", \"231\", \".\", \"456\"), na = \".\")\n#> [1]   1 231  NA 456\nx <- parse_integer(c(\"123\", \"345\", \"abc\", \"123.45\"))\n#> Warning: 2 parsing failures.\n#> row col               expected actual\n#>   3  -- no trailing characters abc   \n#>   4  -- no trailing characters 123.45\nx\n#> [1] 123 345  NA  NA\n#> attr(,\"problems\")\n#> # A tibble: 2 × 4\n#>     row   col expected               actual\n#>   <int> <int> <chr>                  <chr> \n#> 1     3    NA no trailing characters abc   \n#> 2     4    NA no trailing characters 123.45\nproblems(x)\n#> # A tibble: 2 × 4\n#>     row   col expected               actual\n#>   <int> <int> <chr>                  <chr> \n#> 1     3    NA no trailing characters abc   \n#> 2     4    NA no trailing characters 123.45"},{"path":"importazione-dei-dati.html","id":"numeri","chapter":"11 Importazione dei dati","heading":"11.3.1 Numeri","text":"Sembra che dovrebbe essere semplice analizzare un numero, ma tre problemi lo rendono difficile:La gente scrive numeri modo diverso nelle diverse parti del mondo.\nPer esempio, alcuni paesi usano . tra la parte intera e quella frazionaria\ndi un numero reale, mentre altri usano ,.La gente scrive numeri modo diverso nelle diverse parti del mondo.\nPer esempio, alcuni paesi usano . tra la parte intera e quella frazionaria\ndi un numero reale, mentre altri usano ,.numeri sono spesso circondati da altri caratteri che forniscono qualche\ncontesto, come “$1000” o “10%”.numeri sono spesso circondati da altri caratteri che forniscono qualche\ncontesto, come “$1000” o “10%”.numeri spesso contengono caratteri di “raggruppamento” per renderli più facili da leggere,\ncome “1.000.000”, e questi caratteri di raggruppamento variano nel mondo.numeri spesso contengono caratteri di “raggruppamento” per renderli più facili da leggere,\ncome “1.000.000”, e questi caratteri di raggruppamento variano nel mondo.Per affrontare il primo problema, readr ha la nozione di “locale”, un oggetto che specifica le opzioni di analisi che differiscono da luogo luogo. Quando si analizzano numeri, l’opzione più importante è il carattere che si usa per il segno decimale. Puoi sovrascrivere il valore predefinito di . creando un nuovo locale e impostando l’argomento decimal_mark:Il locale predefinito di readr è US-centrico, perché generalmente R è US-centrico (cioè la documentazione di base di R è scritta inglese americano). Un approccio alternativo sarebbe cercare di indovinare valori predefiniti dal vostro sistema operativo. Questo è difficile da fare bene e, cosa più importante, rende il vostro codice fragile: anche se funziona sul vostro computer, potrebbe fallire quando lo inviate per email ad un collega un altro paese.parse_number() affronta il secondo problema: ignora caratteri non numerici prima e dopo il numero. Questo è particolarmente utile per le valute e le percentuali, ma funziona anche per estrarre numeri incorporati nel testo.L’ultimo problema è affrontato dalla combinazione di parse_number() e il locale, poiché parse_number() ignorerà il “grouping mark” (segno di raggruppamento):","code":"\nparse_double(\"1.23\")\n#> [1] 1.23\nparse_double(\"1,23\", locale = locale(decimal_mark = \",\"))\n#> [1] 1.23\nparse_number(\"$100\")\n#> [1] 100\nparse_number(\"20%\")\n#> [1] 20\nparse_number(\"It cost $123.45\")\n#> [1] 123.45\n# Used in America\nparse_number(\"$123,456,789\")\n#> [1] 123456789\n\n# Used in many parts of Europe\nparse_number(\"123.456.789\", locale = locale(grouping_mark = \".\"))\n#> [1] 123456789\n\n# Used in Switzerland\nparse_number(\"123'456'789\", locale = locale(grouping_mark = \"'\"))\n#> [1] 123456789"},{"path":"importazione-dei-dati.html","id":"readr-strings","chapter":"11 Importazione dei dati","heading":"11.3.2 Stringhe","text":"Sembra che parse_character() dovrebbe essere molto semplice — potrebbe semplicemente restituire il suo input. Sfortunatamente la vita non è così semplice, poiché ci sono più modi di rappresentare la stessa stringa. Per capire cosa sta succedendo, dobbiamo immergerci nei dettagli di come computer rappresentano le stringhe. R, possiamo arrivare alla rappresentazione sottostante di una stringa usando charToRaw():Ogni numero esadecimale rappresenta un byte di informazione: 48 è H, 61 è , e così via. La mappatura dal numero esadecimale al carattere è chiamata codifica, e questo caso la codifica è chiamata ASCII. ASCII fa un ottimo lavoro nel rappresentare caratteri inglesi, perché è il American Standard Code Information Interchange.Le cose diventano più complicate per le lingue diverse dall’inglese. Nei primi giorni dell’informatica c’erano molti standard concorrenti per la codifica dei caratteri non inglesi, e per interpretare correttamente una stringa bisognava conoscere sia valori che la codifica. Per esempio, due codifiche comuni sono Latin1 (alias ISO-8859-1, usato per le lingue dell’Europa occidentale) e Latin2 (alias ISO-8859-2, usato per le lingue dell’Europa orientale). Latin1, il byte b1 è “±”, ma Latin2, è “ą”! Fortunatamente, oggi c’è uno standard che è supportato quasi ovunque: UTF-8. UTF-8 può codificare quasi tutti caratteri usati dagli esseri umani oggi, così come molti simboli extra (come le emoji!).readr usa UTF-8 ovunque: assume che tuoi dati siano codificati UTF-8 quando li leggi, e li usa sempre quando scrivi. Questo è un buon default, ma fallirà per dati prodotti da vecchi sistemi che non capiscono UTF-8. Se questo succede voi, le vostre stringhe avranno un aspetto strano quando le stampate. volte solo uno o due caratteri potrebbero essere incasinati; altre volte si otterrà una completa incomprensione. Per esempio:Per risolvere il problema è necessario specificare la codifica parse_character():Come si fa trovare la codifica corretta? Se sei fortunato, sarà inclusa da qualche parte nella documentazione dei dati. Sfortunatamente, questo è raramente il caso, così readr fornisce guess_encoding() per aiutarvi capirlo. Non è infallibile, e funziona meglio quando hai molto testo (diversamente da qui), ma è un punto di partenza ragionevole. Aspettatevi di provare alcune codifiche diverse prima di trovare quella giusta.Il primo argomento di guess_encoding() può essere un percorso verso un file, oppure, come questo caso, un vettore grezzo (utile se le stringhe sono già R).Le codifiche sono un argomento ricco e complesso, e qui ho solo grattato la superficie. Se volete saperne di più, vi consiglio di leggere la spiegazione dettagliata su http://kunststube.net/encoding/.","code":"\ncharToRaw(\"Hadley\")\n#> [1] 48 61 64 6c 65 79\nx1 <- \"El Ni\\xf1o was particularly bad this year\"\nx2 <- \"\\x82\\xb1\\x82\\xf1\\x82\\xc9\\x82\\xbf\\x82\\xcd\"\n\nx1\n#> [1] \"El Ni\\xf1o was particularly bad this year\"\nx2\n#> [1] \"\\x82\\xb1\\x82\\xf1\\x82ɂ\\xbf\\x82\\xcd\"\nparse_character(x1, locale = locale(encoding = \"Latin1\"))\n#> [1] \"El Niño was particularly bad this year\"\nparse_character(x2, locale = locale(encoding = \"Shift-JIS\"))\n#> [1] \"こんにちは\"\nguess_encoding(charToRaw(x1))\n#> # A tibble: 2 × 2\n#>   encoding   confidence\n#>   <chr>           <dbl>\n#> 1 ISO-8859-1       0.46\n#> 2 ISO-8859-9       0.23\nguess_encoding(charToRaw(x2))\n#> # A tibble: 1 × 2\n#>   encoding confidence\n#>   <chr>         <dbl>\n#> 1 KOI8-R         0.42"},{"path":"importazione-dei-dati.html","id":"readr-factors","chapter":"11 Importazione dei dati","heading":"11.3.3 Fattori","text":"R usa fattori per rappresentare variabili categoriche che hanno un insieme noto di possibili valori. Date parse_factor() un vettore di livelli noti per generare un avviso ogni volta che è presente un valore inaspettato:Ma se hai molte voci problematiche, spesso è più facile lasciarle come vettori di caratteri e poi usare gli strumenti che imparerai stringhe e fattori per pulirle.","code":"\nfruit <- c(\"apple\", \"banana\")\nparse_factor(c(\"apple\", \"banana\", \"bananana\"), levels = fruit)\n#> Warning: 1 parsing failure.\n#> row col           expected   actual\n#>   3  -- value in level set bananana\n#> [1] apple  banana <NA>  \n#> attr(,\"problems\")\n#> # A tibble: 1 × 4\n#>     row   col expected           actual  \n#>   <int> <int> <chr>              <chr>   \n#> 1     3    NA value in level set bananana\n#> Levels: apple banana"},{"path":"importazione-dei-dati.html","id":"readr-datetimes","chapter":"11 Importazione dei dati","heading":"11.3.4 Date, date e orari","text":"Puoi scegliere tra tre analizzatori seconda che tu voglia una data (il numero di giorni dal 1970-01-01), una data-ora (il numero di secondi dalla mezzanotte del 1970-01-01), o un’ora (il numero di secondi dalla mezzanotte). Se chiamato senza ulteriori argomenti:parse_datetime() si aspetta una data-ora ISO8601. ISO8601 è uno\nstandard internazionale cui componenti di una data sono\norganizzati dal più grande al più piccolo: anno, mese, giorno, ora, minuto,\nsecondo.\n\nparse_datetime(\"2010-10-01T2010\")\n#> [1] \"2010-10-01 20:10:00 UTC\"\n# time omitted, set midnight\nparse_datetime(\"20101010\")\n#> [1] \"2010-10-10 UTC\"\nQuesto è lo standard di data/ora più importante, e se lavorate con\ndate e ore frequentemente, vi consiglio di leggere\nhttps://en.wikipedia.org/wiki/ISO_8601parse_datetime() si aspetta una data-ora ISO8601. ISO8601 è uno\nstandard internazionale cui componenti di una data sono\norganizzati dal più grande al più piccolo: anno, mese, giorno, ora, minuto,\nsecondo.Questo è lo standard di data/ora più importante, e se lavorate con\ndate e ore frequentemente, vi consiglio di leggere\nhttps://en.wikipedia.org/wiki/ISO_8601parse_date() si aspetta un anno quattro cifre, un - o /, il mese, un -\no /, poi il giorno:\n\nparse_date(\"2010-10-01\")\n#> [1] \"2010-10-01\"parse_date() si aspetta un anno quattro cifre, un - o /, il mese, un -\no /, poi il giorno:parse_time() si aspetta l’ora, :, minuti, opzionalmente : e secondi,\ne uno specificatore opzionale /pm:\n\nlibrary(hms)\nparse_time(\"01:10 \")\n#> 01:10:00\nparse_time(\"20:10:01\")\n#> 20:10:01\nR base non ha integrata una buona classe per dati temporali, quindi usiamo\nquella fornita nel pacchetto hms.parse_time() si aspetta l’ora, :, minuti, opzionalmente : e secondi,\ne uno specificatore opzionale /pm:R base non ha integrata una buona classe per dati temporali, quindi usiamo\nquella fornita nel pacchetto hms.Se queste impostazioni predefinite non funzionano per vostri dati, potete fornire il vostro formato di data e ora, composto dai seguenti elementi:Anno\n%Y (4 cifre).\nAnno : %y (2 cifre); 00-69 -> 2000-2069, 70-99 -> 1970-1999.\nMese\n%m (2 cifre).\n\n%b (nome abbreviato, come “Jan”).\n\n%B (nome completo, “Gennaio”).\nGiorno\n%d (2 cifre).\n\n%e (spazio iniziale opzionale).\nOra\n%H 0-23 ore.\n\n%0-12, deve essere usato con %p.\n\n%p indicatore /PM.\n\n%M minuti.\n\n%S secondi interi.\n\n%OS secondi reali.\n\n%Z Fuso orario (come nome, per esempio America/Chicago). Attenzione alle abbreviazioni:\nse sei americano, nota che “EST” è un fuso orario canadese che non\nha l’ora legale. Non è non Eastern Standard Time! Torneremo\ntorneremo su questo fusi orari.\n\n%z (come offset da UTC, ad esempio +0800).\nNon cifre\n%. salta un carattere non numerico.\n\n%* salta qualsiasi numero di non cifre.\nIl modo migliore per capire il formato corretto è quello di creare alcuni esempi un vettore di caratteri, e testare con una delle funzioni di analisi. Per esempio:Se stai usando %b o %B con nomi di mesi non inglesi, dovrai impostare l’argomento lang locale(). Vedi la lista delle lingue incorporate date_names_langs(), o se la tua lingua non è già inclusa, crea la tua con date_names().","code":"\nparse_datetime(\"2010-10-01T2010\")\n#> [1] \"2010-10-01 20:10:00 UTC\"\n# If time is omitted, it will be set to midnight\nparse_datetime(\"20101010\")\n#> [1] \"2010-10-10 UTC\"\nparse_date(\"2010-10-01\")\n#> [1] \"2010-10-01\"\nlibrary(hms)\nparse_time(\"01:10 am\")\n#> 01:10:00\nparse_time(\"20:10:01\")\n#> 20:10:01\nparse_date(\"01/02/15\", \"%m/%d/%y\")\n#> [1] \"2015-01-02\"\nparse_date(\"01/02/15\", \"%d/%m/%y\")\n#> [1] \"2015-02-01\"\nparse_date(\"01/02/15\", \"%y/%m/%d\")\n#> [1] \"2001-02-15\"\nparse_date(\"1 gennaio 2015\", \"%d %B %Y\", locale = locale(\"it\"))\n#> [1] \"2015-01-01\""},{"path":"importazione-dei-dati.html","id":"esercizi-22","chapter":"11 Importazione dei dati","heading":"11.3.5 Esercizi","text":"Quali sono gli argomenti più importanti di locale()?Quali sono gli argomenti più importanti di locale()?Cosa succede se provate impostare decimal_mark e grouping_mark.\nallo stesso carattere? Cosa succede al valore predefinito di\ngrouping_mark quando si imposta decimal_mark “,”? Cosa succede\nal valore predefinito di decimal_mark quando imposti il grouping_mark “.\nsu”.”?Cosa succede se provate impostare decimal_mark e grouping_mark.\nallo stesso carattere? Cosa succede al valore predefinito di\ngrouping_mark quando si imposta decimal_mark “,”? Cosa succede\nal valore predefinito di decimal_mark quando imposti il grouping_mark “.\nsu”.”?Non ho discusso le opzioni date_format e time_format per\nlocale(). Cosa fanno? Costruisci un esempio che mostri quando\npotrebbero essere utili.Non ho discusso le opzioni date_format e time_format per\nlocale(). Cosa fanno? Costruisci un esempio che mostri quando\npotrebbero essere utili.Se vivete fuori dagli Stati Uniti, create un nuovo oggetto locale che incapsuli\nle impostazioni per tipi di file che leggete più comunemente.Se vivete fuori dagli Stati Uniti, create un nuovo oggetto locale che incapsuli\nle impostazioni per tipi di file che leggete più comunemente.Qual è la differenza tra read_csv() e read_csv2()?Qual è la differenza tra read_csv() e read_csv2()?Quali sono le codifiche più comuni usate Europa? Quali sono le\ncodifiche più comuni usate Asia? Fai qualche ricerca su Google per scoprirlo.Quali sono le codifiche più comuni usate Europa? Quali sono le\ncodifiche più comuni usate Asia? Fai qualche ricerca su Google per scoprirlo.Genera la corretta stringa di formato per analizzare ciascuna delle seguenti\ndate e orari:\n\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 2014\nt1 <- \"1705\"\nt2 <- \"11:15:10.12 PM\"Genera la corretta stringa di formato per analizzare ciascuna delle seguenti\ndate e orari:","code":"\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 2014\nt1 <- \"1705\"\nt2 <- \"11:15:10.12 PM\""},{"path":"importazione-dei-dati.html","id":"analizzare-un-file","chapter":"11 Importazione dei dati","heading":"11.4 Analizzare un file","text":"Ora che hai imparato come analizzare un singolo vettore, è tempo di tornare ’inizio ed esplorare come readr analizza un file. Ci sono due cose nuove che imparerete questa sezione:Come readr indovina automaticamente il tipo di ogni colonna.Come sovrascrivere la specifica predefinita.","code":""},{"path":"importazione-dei-dati.html","id":"strategia","chapter":"11 Importazione dei dati","heading":"11.4.1 Strategia","text":"readr usa un’euristica per capire il tipo di ogni colonna: legge le prime 1000 righe e usa alcune euristiche (moderatamente conservative) per capire il tipo di ogni colonna. Puoi emulare questo processo con un vettore di caratteri usando guess_parser(), che restituisce la migliore ipotesi di readr, e parse_guess() che usa tale ipotesi per analizzare la colonna:L’euristica prova ciascuno dei seguenti tipi, fermandosi quando trova una corrispondenza:logico: contiene solo “F”, “T”, “FALSE” o “TRUE”.integer: contiene solo caratteri numerici (e -).double: contiene solo doppi validi (inclusi numeri come 4.5e-5).number: contiene doppi validi con il segno di raggruppamento ’interno.time: corrisponde al formato predefinito time_format.date: corrisponde al formato predefinito date_format.date-time: qualsiasi data ISO8601.Se nessuna di queste regole è applicabile, allora la colonna rimarrà come un vettore di stringhe.","code":"\nguess_parser(\"2010-10-01\")\n#> [1] \"date\"\nguess_parser(\"15:01\")\n#> [1] \"time\"\nguess_parser(c(\"TRUE\", \"FALSE\"))\n#> [1] \"logical\"\nguess_parser(c(\"1\", \"5\", \"9\"))\n#> [1] \"double\"\nguess_parser(c(\"12,352,561\"))\n#> [1] \"number\"\n\nstr(parse_guess(\"2010-10-10\"))\n#>  Date[1:1], format: \"2010-10-10\""},{"path":"importazione-dei-dati.html","id":"problemi","chapter":"11 Importazione dei dati","heading":"11.4.2 Problemi","text":"Questi valori predefiniti non sempre funzionano per file più grandi. Ci sono due problemi di base:Le prime mille righe potrebbero essere un caso speciale, e readr indovina\nun tipo che non è sufficientemente generale. Per esempio, si potrebbe avere\nuna colonna di doppi che contiene solo interi nelle prime 1000 righe.Le prime mille righe potrebbero essere un caso speciale, e readr indovina\nun tipo che non è sufficientemente generale. Per esempio, si potrebbe avere\nuna colonna di doppi che contiene solo interi nelle prime 1000 righe.La colonna potrebbe contenere molti valori mancanti. Se le prime 1000\nrighe contengono solo NA, readr penserà che sia un vettore logico\nvettoriale logico, mentre voi probabilmente volete analizzarlo come qualcosa di più\nspecifico.La colonna potrebbe contenere molti valori mancanti. Se le prime 1000\nrighe contengono solo NA, readr penserà che sia un vettore logico\nvettoriale logico, mentre voi probabilmente volete analizzarlo come qualcosa di più\nspecifico.readr contiene un CSV impegnativo che illustra entrambi questi problemi:(Si noti l’uso di readr_example() che trova il percorso di uno dei file inclusi nel pacchetto)Ci sono due output stampati: la specifica della colonna generata guardando le prime 1000 righe e primi cinque fallimenti dell’analisi. È sempre una buona idea estrarre esplicitamente problems(), modo da poterli esplorare più fondo:Una buona strategia è quella di lavorare colonna per colonna finché non ci sono più problemi. Qui possiamo vedere che ci sono molti problemi di parsing con la colonna y. Se guardiamo le ultime righe, vedrete che sono date memorizzate un vettore di caratteri:Questo suggerisce che invece abbiamo bisogno di usare un parser di date. Per correggere la chiamata, iniziate copiando e incollando la specifica della colonna nella vostra chiamata originale:Poi potete fissare il tipo della colonna y specificando che y è una colonna di data:Ogni funzione parse_xyz() ha una corrispondente funzione col_xyz(). Si usa parse_xyz() quando dati sono già un vettore di caratteri R; si usa col_xyz() quando si vuole dire readr come caricare dati.Raccomando vivamente di fornire sempre col_types, partendo dalla stampa fornita da readr. Questo assicura che tu abbia uno script di importazione dati coerente e riproducibile. Se ti affidi alle ipotesi di default e tuoi dati cambiano, readr continuerà leggerli. Se vuoi essere davvero rigoroso, usa stop_for_problems(): questo lancerà un errore e fermerà lo script se ci sono problemi di analisi.","code":"\nchallenge <- read_csv(readr_example(\"challenge.csv\"))\n#> Rows: 2000 Columns: 2\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl  (1): x\n#> date (1): y\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nproblems(challenge)\n#> # A tibble: 0 × 5\n#> # … with 5 variables: row <int>, col <int>, expected <chr>, actual <chr>,\n#> #   file <chr>\ntail(challenge)\n#> # A tibble: 6 × 2\n#>       x y         \n#>   <dbl> <date>    \n#> 1 0.805 2019-11-21\n#> 2 0.164 2018-03-29\n#> 3 0.472 2014-08-04\n#> 4 0.718 2015-08-16\n#> 5 0.270 2020-02-04\n#> 6 0.608 2019-01-06\nchallenge <- read_csv(\n  readr_example(\"challenge.csv\"), \n  col_types = cols(\n    x = col_double(),\n    y = col_logical()\n  )\n)\nchallenge <- read_csv(\n  readr_example(\"challenge.csv\"), \n  col_types = cols(\n    x = col_double(),\n    y = col_date()\n  )\n)\ntail(challenge)\n#> # A tibble: 6 × 2\n#>       x y         \n#>   <dbl> <date>    \n#> 1 0.805 2019-11-21\n#> 2 0.164 2018-03-29\n#> 3 0.472 2014-08-04\n#> 4 0.718 2015-08-16\n#> 5 0.270 2020-02-04\n#> 6 0.608 2019-01-06"},{"path":"importazione-dei-dati.html","id":"altre-strategie","chapter":"11 Importazione dei dati","heading":"11.4.3 Altre strategie","text":"Ci sono alcune altre strategie generali per aiutarti ad analizzare file:Nell’esempio precedente, siamo stati solo sfortunati: se guardiamo solo una riga più rispetto quella di default, possiamo analizzare correttamente un colpo solo:\n\nchallenge2 <- read_csv(readr_example(\"challenge.csv\"), guess_max = 1001)\n#> Rows: 2000 Columns: 2\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl  (1): x\n#> date (1): y\n#> \n#> ℹ Use `spec()` retrieve full column specification data.\n#> ℹ Specify column types set `show_col_types = FALSE` quiet message.\nchallenge2\n#> # tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … 1,994 rowsNell’esempio precedente, siamo stati solo sfortunati: se guardiamo solo una riga più rispetto quella di default, possiamo analizzare correttamente un colpo solo:volte è più facile diagnosticare problemi se si leggono tutte le colonne come vettori di caratteri:\n\nchallenge2 <- read_csv(readr_example(\"challenge.csv\"), \n  col_types = cols(.default = col_character())\n)\nparticularly useful conjunction type_convert(),\napplies parsing heuristics character columns data\nframe.\n\ndf <- tribble(\n  ~x,  ~y,\n  \"1\", \"1.21\",\n  \"2\", \"2.32\",\n  \"3\", \"4.56\"\n)\ndf\n#> # tibble: 3 × 2\n#>   x     y    \n#>   <chr> <chr>\n#> 1 1     1.21 \n#> 2 2     2.32 \n#> 3 3     4.56\n\n# Note column types\ntype_convert(df)\n#> \n#> ── Column specification ────────────────────────────────────────────────────────\n#> cols(\n#>   x = col_double(),\n#>   y = col_double()\n#> )\n#> # tibble: 3 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1  1.21\n#> 2     2  2.32\n#> 3     3  4.56A volte è più facile diagnosticare problemi se si leggono tutte le colonne come vettori di caratteri:particularly useful conjunction type_convert(),\napplies parsing heuristics character columns data\nframe.Se stai leggendo un file molto grande, potresti voler impostare n_max \nun numero piccolo come 10.000 o 100.000. Questo accelererà le vostre\niterazioni mentre si eliminano problemi comuni.Se stai leggendo un file molto grande, potresti voler impostare n_max \nun numero piccolo come 10.000 o 100.000. Questo accelererà le vostre\niterazioni mentre si eliminano problemi comuni.Se stai avendo grossi problemi di analisi, volte è più facile\nleggere semplicemente un vettore di caratteri di linee con read_lines(),\no anche un vettore di caratteri di lunghezza 1 con read_file(). Poi si\npotete usare le abilità di analisi delle stringhe che imparerete seguito per analizzare\nformati più esotici.Se stai avendo grossi problemi di analisi, volte è più facile\nleggere semplicemente un vettore di caratteri di linee con read_lines(),\no anche un vettore di caratteri di lunghezza 1 con read_file(). Poi si\npotete usare le abilità di analisi delle stringhe che imparerete seguito per analizzare\nformati più esotici.","code":"\nchallenge2 <- read_csv(readr_example(\"challenge.csv\"), guess_max = 1001)\n#> Rows: 2000 Columns: 2\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl  (1): x\n#> date (1): y\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nchallenge2\n#> # A tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … with 1,994 more rows\nchallenge2 <- read_csv(readr_example(\"challenge.csv\"), \n  col_types = cols(.default = col_character())\n)\ndf <- tribble(\n  ~x,  ~y,\n  \"1\", \"1.21\",\n  \"2\", \"2.32\",\n  \"3\", \"4.56\"\n)\ndf\n#> # A tibble: 3 × 2\n#>   x     y    \n#>   <chr> <chr>\n#> 1 1     1.21 \n#> 2 2     2.32 \n#> 3 3     4.56\n\n# Note the column types\ntype_convert(df)\n#> \n#> ── Column specification ────────────────────────────────────────────────────────\n#> cols(\n#>   x = col_double(),\n#>   y = col_double()\n#> )\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1  1.21\n#> 2     2  2.32\n#> 3     3  4.56"},{"path":"importazione-dei-dati.html","id":"scrivere-su-un-file","chapter":"11 Importazione dei dati","heading":"11.5 Scrivere su un file","text":"readr dispone anche di due utili funzioni per scrivere dati su disco: write_csv() e write_tsv(). Entrambe le funzioni aumentano le possibilità che il file di output venga letto correttamente:codificando sempre le stringhe UTF-8.codificando sempre le stringhe UTF-8.Salvando date e orari formato ISO8601 modo che siano facilmente\nanalizzati altrove.Salvando date e orari formato ISO8601 modo che siano facilmente\nanalizzati altrove.Se vuoi esportare un file csv Excel, usa write_excel_csv() — questo scrive un carattere speciale (un “byte order mark”) ’inizio del file che dice Excel che stai usando la codifica UTF-8.Gli argomenti più importanti sono x (il frame di dati da salvare) e path (la posizione cui salvarlo). Puoi anche specificare come vengono scritti valori mancanti con na, e se vuoi applicare ad un file esistente.Si noti che le informazioni sul tipo vengono perse quando si salva csv:Questo rende CSV un po’ inaffidabili per la memorizzazione dei risultati intermedi - è necessario ricreare la specifica della colonna ogni volta che si carica. Ci sono due alternative:write_rds() e read_rds() sono wrapper uniformi intorno alle funzioni di base\nfunzioni di base readRDS() e saveRDS(). Queste memorizzano dati nel formato binario personalizzato di R\nformato binario personalizzato di R chiamato RDS:\n\nwrite_rds(challenge, \"challenge.rds\")\nread_rds(\"challenge.rds\")\n#> # tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … 1,994 rowswrite_rds() e read_rds() sono wrapper uniformi intorno alle funzioni di base\nfunzioni di base readRDS() e saveRDS(). Queste memorizzano dati nel formato binario personalizzato di R\nformato binario personalizzato di R chiamato RDS:Il pacchetto feather implementa un formato di file binario veloce che può essere condiviso attraverso linguaggi di programmazione:\n\nlibrary(feather)\nwrite_feather(challenge, \"challenge.feather\")\nread_feather(\"challenge.feather\")\n#> # tibble: 2,000 x 2\n#>       x      y\n#>   <dbl> <date>\n#> 1   404   <NA>\n#> 2  4172   <NA>\n#> 3  3004   <NA>\n#> 4   787   <NA>\n#> 5    37   <NA>\n#> 6  2332   <NA>\n#> # ... 1,994 rowsIl pacchetto feather implementa un formato di file binario veloce che può essere condiviso attraverso linguaggi di programmazione:Feather tende ad essere più veloce di RDS ed è utilizzabile al di fuori di R. RDS supporta le liste-colonne (che imparerete molti modelli); feather attualmente non lo fa.","code":"\nwrite_csv(challenge, \"challenge.csv\")\nchallenge\n#> # A tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … with 1,994 more rows\nwrite_csv(challenge, \"challenge-2.csv\")\nread_csv(\"challenge-2.csv\")\n#> Rows: 2000 Columns: 2\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> dbl  (1): x\n#> date (1): y\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#> # A tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … with 1,994 more rows\nwrite_rds(challenge, \"challenge.rds\")\nread_rds(\"challenge.rds\")\n#> # A tibble: 2,000 × 2\n#>       x y     \n#>   <dbl> <date>\n#> 1   404 NA    \n#> 2  4172 NA    \n#> 3  3004 NA    \n#> 4   787 NA    \n#> 5    37 NA    \n#> 6  2332 NA    \n#> # … with 1,994 more rows\nlibrary(feather)\nwrite_feather(challenge, \"challenge.feather\")\nread_feather(\"challenge.feather\")\n#> # A tibble: 2,000 x 2\n#>       x      y\n#>   <dbl> <date>\n#> 1   404   <NA>\n#> 2  4172   <NA>\n#> 3  3004   <NA>\n#> 4   787   <NA>\n#> 5    37   <NA>\n#> 6  2332   <NA>\n#> # ... with 1,994 more rows"},{"path":"importazione-dei-dati.html","id":"altri-tipi-di-dati","chapter":"11 Importazione dei dati","heading":"11.6 Altri tipi di dati","text":"Per ottenere altri tipi di dati R, raccomandiamo di iniziare con pacchetti tidyverse elencati qui sotto. Non sono certamente perfetti, ma sono un buon punto di partenza. Per dati rettangolari:haven legge file SPSS, Stata e SAS.haven legge file SPSS, Stata e SAS.readxl legge file excel (sia .xls che .xlsx).readxl legge file excel (sia .xls che .xlsx).DBI, insieme ad un backend specifico per database (ad esempio RMySQL,\nRSQLite, RPostgreSQL ecc.) ti permette di eseguire query SQL su un\ndatabase e restituire un frame di dati.DBI, insieme ad un backend specifico per database (ad esempio RMySQL,\nRSQLite, RPostgreSQL ecc.) ti permette di eseguire query SQL su un\ndatabase e restituire un frame di dati.Per dati gerarchici: usate jsonlite (di Jeroen Ooms) per json, e xml2 per XML. Jenny Bryan ha alcuni eccellenti esempi funzionanti su https://jennybc.github.io/purrr-tutorial/.Per altri tipi di file, provate il R data import/export manual e il pacchetto rio.","code":""},{"path":"tidy-data.html","id":"tidy-data","chapter":"12 Tidy data","heading":"12 Tidy data","text":"","code":""},{"path":"tidy-data.html","id":"introduzione-6","chapter":"12 Tidy data","heading":"12.1 Introduzione","text":"“Le famiglie felici sono tutte uguali; ogni famiglia infelice è infelice modo suo”. — Leo Tolstoy“Le serie di dati ordinate sono tutte uguali, ma ogni serie di dati disordinata è disordinata modo suo”. — Hadley WickhamIn questo capitolo, imparerete un modo coerente per organizzare vostri dati R, un’organizzazione chiamata tidy data. Mettere vostri dati questo formato richiede un po’ di lavoro iniziale, ma questo lavoro ripaga nel lungo termine. Una volta che avete dati ordinati e gli strumenti ordinati forniti dai pacchetti del tidyverse, passerete molto meno tempo mescolare dati da una rappresentazione ’altra, permettendovi di dedicare più tempo alle domande analitiche che avete disposizione.Questo capitolo vi darà un’introduzione pratica ai ‘tidy data’(dati ordinati, organizzati) e agli strumenti di accompagnamento nel pacchetto tidyr. Se volete saperne di più sulla teoria sottostante, potreste apprezzare il documento Tidy Data pubblicato nel Journal Statistical Software, http://www.jstatsoft.org/v59/i10/paper.","code":""},{"path":"tidy-data.html","id":"prerequisiti-6","chapter":"12 Tidy data","heading":"12.1.1 Prerequisiti","text":"questo capitolo ci concentreremo su tidyr, un pacchetto che fornisce una serie di strumenti per aiutare riordinare vostri insiemi di dati disordinati. tidyr è un membro del core tidyverse.","code":"\nlibrary(tidyverse)"},{"path":"tidy-data.html","id":"tidy-data-1","chapter":"12 Tidy data","heading":"12.2 Tidy data","text":"È possibile rappresentare gli stessi dati sottostanti più modi. L’esempio qui sotto mostra gli stessi dati organizzati quattro modi diversi. Ogni set di dati mostra gli stessi valori di quattro variabili paese, anno, popolazione, e casi, ma ogni set di dati organizza valori un modo diverso.Sono tutte rappresentazioni degli stessi dati sottostanti, ma non sono ugualmente facili da usare. Un dataset, il dataset ordinato, sarà molto più facile da lavorare ’interno del tidyverse.Ci sono tre regole correlate che rendono un dataset ordinato:Ogni variabile deve avere la propria colonna.Ogni osservazione deve avere la sua riga.Ogni valore deve avere la propria cella.La figura 12.1 mostra visivamente le regole.\nFigure 12.1: Seguire tre regole rende un set di dati ordinato: le variabili sono nelle colonne, le osservazioni sono nelle righe e valori sono nelle celle.\nQueste tre regole sono interrelate perché è impossibile soddisfare solo due delle tre. Questa interrelazione porta ad un insieme ancora più semplice di istruzioni pratiche:Metti ogni set di dati una tibble.Metti ogni variabile una colonna.questo esempio, solo la table1 è ordinata. È l’unica rappresentazione cui ogni colonna è una variabile.Perché assicurarsi che dati siano ordinati? Ci sono due vantaggi principali:C’è un vantaggio generale nel scegliere un modo coerente di memorizzare\ndati. Se hai una struttura di dati coerente, è più facile imparare gli\nstrumenti che lavorano con essa perché hanno un’uniformità di fondo.C’è un vantaggio generale nel scegliere un modo coerente di memorizzare\ndati. Se hai una struttura di dati coerente, è più facile imparare gli\nstrumenti che lavorano con essa perché hanno un’uniformità di fondo.C’è un vantaggio specifico nel mettere le variabili colonne perché\npermette alla natura vettoriale di R di brillare. Come avete imparato \nmutate e riassunti raggruppati, la maggior parte\nfunzioni built-di R lavorano con vettori di valori. Questo rende la trasformazione\ndati ordinati modo particolarmente naturale.C’è un vantaggio specifico nel mettere le variabili colonne perché\npermette alla natura vettoriale di R di brillare. Come avete imparato \nmutate e riassunti raggruppati, la maggior parte\nfunzioni built-di R lavorano con vettori di valori. Questo rende la trasformazione\ndati ordinati modo particolarmente naturale.dplyr, ggplot2 e tutti gli altri pacchetti del tidyverse sono progettati per lavorare con dati ordinati. Ecco un paio di piccoli esempi che mostrano come potreste lavorare con table1.","code":"\ntable1\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\ntable2\n#> # A tibble: 12 × 4\n#>   country      year type           count\n#>   <chr>       <dbl> <chr>          <dbl>\n#> 1 Afghanistan  1999 cases            745\n#> 2 Afghanistan  1999 population  19987071\n#> 3 Afghanistan  2000 cases           2666\n#> 4 Afghanistan  2000 population  20595360\n#> 5 Brazil       1999 cases          37737\n#> 6 Brazil       1999 population 172006362\n#> # … with 6 more rows\ntable3\n#> # A tibble: 6 × 3\n#>   country      year rate             \n#>   <chr>       <dbl> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583\n\n# Distribuito su due tibble\ntable4a  # casi\n#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <dbl>  <dbl>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\ntable4b  # popolazione\n#> # A tibble: 3 × 3\n#>   country         `1999`     `2000`\n#>   <chr>            <dbl>      <dbl>\n#> 1 Afghanistan   19987071   20595360\n#> 2 Brazil       172006362  174504898\n#> 3 China       1272915272 1280428583\n# Calcolare il tasso per 10.000\ntable1 %>% \n  mutate(rate = cases / population * 10000)\n#> # A tibble: 6 × 5\n#>   country      year  cases population  rate\n#>   <chr>       <dbl>  <dbl>      <dbl> <dbl>\n#> 1 Afghanistan  1999    745   19987071 0.373\n#> 2 Afghanistan  2000   2666   20595360 1.29 \n#> 3 Brazil       1999  37737  172006362 2.19 \n#> 4 Brazil       2000  80488  174504898 4.61 \n#> 5 China        1999 212258 1272915272 1.67 \n#> 6 China        2000 213766 1280428583 1.67\n\n# Calcolare i casi per anno\ntable1 %>% \n  count(year, wt = cases)\n#> # A tibble: 2 × 2\n#>    year      n\n#>   <dbl>  <dbl>\n#> 1  1999 250740\n#> 2  2000 296920\n\n# Visualizzare i cambiamenti nel tempo\nlibrary(ggplot2)\nggplot(table1, aes(year, cases)) + \n  geom_line(aes(group = country), colour = \"grey50\") + \n  geom_point(aes(colour = country))"},{"path":"tidy-data.html","id":"esercizi-23","chapter":"12 Tidy data","heading":"12.2.1 Esercizi","text":"Usando la prosa, descrivete come sono organizzate le variabili e le osservazioni \nciascuna delle tabelle di esempio.Usando la prosa, descrivete come sono organizzate le variabili e le osservazioni \nciascuna delle tabelle di esempio.Calcola il rate per la table2, e la table4a + table4b.\nDovrai eseguire quattro operazioni:\nEstrarre il numero di casi di TBC per paese e per anno.\nEstrarre la popolazione corrispondente per paese e per anno.\nDividere casi per la popolazione e moltiplicare per 10000.\nMemorizzare di nuovo nel posto appropriato.\nQuale rappresentazione è più facile da lavorare? Qual è la più difficile? Perché?Calcola il rate per la table2, e la table4a + table4b.\nDovrai eseguire quattro operazioni:Estrarre il numero di casi di TBC per paese e per anno.Estrarre la popolazione corrispondente per paese e per anno.Dividere casi per la popolazione e moltiplicare per 10000.Memorizzare di nuovo nel posto appropriato.Quale rappresentazione è più facile da lavorare? Qual è la più difficile? Perché?Ricreate il grafico che mostra il cambiamento dei casi nel tempo usando la tabella2     invece ditable1`. Cosa devi fare per prima cosa?Ricreate il grafico che mostra il cambiamento dei casi nel tempo usando la tabella2     invece ditable1`. Cosa devi fare per prima cosa?","code":""},{"path":"tidy-data.html","id":"pivoting","chapter":"12 Tidy data","heading":"12.3 Pivoting","text":"principi dei tidy data sembrano così ovvi che potreste chiedervi se incontrerete mai un set di dati che non sia ordinato. Sfortunatamente, però, la maggior parte dei dati che incontrerete saranno disordinati. Ci sono due ragioni principali:La maggior parte delle persone non ha familiarità con principi dei dati ordinati, ed è difficile\nricavarli da soli, meno che non si passi molto tempo lavorare con dati.La maggior parte delle persone non ha familiarità con principi dei dati ordinati, ed è difficile\nricavarli da soli, meno che non si passi molto tempo lavorare con dati.dati sono spesso organizzati per facilitare qualche uso diverso dall’analisi. Per\nesempio, dati sono spesso organizzati per rendere l’inserimento il più facile possibile.dati sono spesso organizzati per facilitare qualche uso diverso dall’analisi. Per\nesempio, dati sono spesso organizzati per rendere l’inserimento il più facile possibile.Questo significa che per la maggior parte delle analisi reali, dovrete fare un po’ di ordine. Il primo passo è sempre quello di capire quali sono le variabili e le osservazioni. volte questo è facile; altre volte avrete bisogno di consultare le persone che hanno originariamente generato dati.\nIl secondo passo è quello di risolvere uno dei due problemi comuni:Una variabile potrebbe essere distribuita su più colonne.Una variabile potrebbe essere distribuita su più colonne.Un’osservazione potrebbe essere sparsa su più righe.Un’osservazione potrebbe essere sparsa su più righe.Tipicamente un set di dati soffrirà solo di uno di questi problemi; soffrirà di entrambi solo se siete davvero sfortunati! Per risolvere questi problemi, avrete bisogno delle due funzioni più importanti di tidyr: pivot_longer() e pivot_wider().","code":""},{"path":"tidy-data.html","id":"longer","chapter":"12 Tidy data","heading":"12.3.1 Longer","text":"Un problema comune è un dataset dove alcuni dei nomi delle colonne non sono nomi di variabili, ma valori di una variabile. Prendete la table4a: nomi delle colonne 1999 e 2000 rappresentano valori della variabile year, valori nelle colonne 1999 e 2000 rappresentano valori della variabile cases, e ogni riga rappresenta due osservazioni, non una.Per riordinare un set di dati come questo, abbiamo bisogno di pivot le colonne offensive una nuova coppia di variabili. Per descrivere questa operazione abbiamo bisogno di tre parametri:L’insieme delle colonne cui nomi sono valori, non variabili. questo esempio,\nqueste sono le colonne 1999 e 2000.L’insieme delle colonne cui nomi sono valori, non variabili. questo esempio,\nqueste sono le colonne 1999 e 2000.Il nome della variabile cui spostare nomi delle colonne. Qui è year.Il nome della variabile cui spostare nomi delle colonne. Qui è year.Il nome della variabile cui spostare valori della colonna. Qui è case.Il nome della variabile cui spostare valori della colonna. Qui è case.Insieme questi parametri generano la chiamata pivot_longer():Le colonne per fare il pivot sono specificate con la notazione stile dplyr::select(). Qui ci sono solo due colonne, quindi le elenchiamo singolarmente. Notate che “1999” e “2000” sono nomi non sintattici (perché non iniziano con una lettera), quindi dobbiamo circondarli di backtick. Per rinfrescarti la memoria sugli altri modi di selezionare le colonne, vedi select.year e cases non esistono table4a quindi mettiamo loro nomi tra virgolette.\nFigure 12.2: Pivot di table4 forma ‘long’ e ordinata.\nNel risultato finale, le colonne pivotate vengono eliminate e si ottengono nuove colonne year e cases. Altrimenti, le relazioni tra le variabili originali sono conservate. Visivamente, questo è mostrato nella figura 12.2.La funzione pivot_longer() rende set di dati più lunghi aumentando il numero di righe e diminuendo il numero di colonne. Non credo che abbia senso descrivere un set di dati come se fosse “forma lunga”. La lunghezza è un termine relativo, e si può solo dire (per esempio) che il dataset è più lungo del dataset B.Possiamo usare pivot_longer() per riordinare table4b modo simile. L’unica differenza è la variabile memorizzata nei valori delle celle:Per combinare le versioni riordinate di table4a e table4b una singola tibble, dobbiamo usare dplyr::left_join(), che imparerai dati relazionali.","code":"\ntable4a\n#> # A tibble: 3 × 3\n#>   country     `1999` `2000`\n#>   <chr>        <dbl>  <dbl>\n#> 1 Afghanistan    745   2666\n#> 2 Brazil       37737  80488\n#> 3 China       212258 213766\ntable4a %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n#> # A tibble: 6 × 3\n#>   country     year   cases\n#>   <chr>       <chr>  <dbl>\n#> 1 Afghanistan 1999     745\n#> 2 Afghanistan 2000    2666\n#> 3 Brazil      1999   37737\n#> 4 Brazil      2000   80488\n#> 5 China       1999  212258\n#> 6 China       2000  213766\ntable4b %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"population\")\n#> # A tibble: 6 × 3\n#>   country     year  population\n#>   <chr>       <chr>      <dbl>\n#> 1 Afghanistan 1999    19987071\n#> 2 Afghanistan 2000    20595360\n#> 3 Brazil      1999   172006362\n#> 4 Brazil      2000   174504898\n#> 5 China       1999  1272915272\n#> 6 China       2000  1280428583\ntidy4a <- table4a %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\ntidy4b <- table4b %>% \n  pivot_longer(c(`1999`, `2000`), names_to = \"year\", values_to = \"population\")\nleft_join(tidy4a, tidy4b)\n#> Joining with `by = join_by(country, year)`\n#> # A tibble: 6 × 4\n#>   country     year   cases population\n#>   <chr>       <chr>  <dbl>      <dbl>\n#> 1 Afghanistan 1999     745   19987071\n#> 2 Afghanistan 2000    2666   20595360\n#> 3 Brazil      1999   37737  172006362\n#> 4 Brazil      2000   80488  174504898\n#> 5 China       1999  212258 1272915272\n#> 6 China       2000  213766 1280428583"},{"path":"tidy-data.html","id":"wider","chapter":"12 Tidy data","heading":"12.3.2 Wider","text":"pivot_wider() è l’opposto di pivot_longer(). Si usa quando un’osservazione è sparsa su più righe. Per esempio, prendete la table2: un’osservazione è un paese un anno, ma ogni osservazione è sparsa su due righe.Per riordinare il tutto, analizziamo prima la rappresentazione modo simile pivot_longer(). Questa volta, però, abbiamo bisogno solo di due parametri:La colonna da cui prendere nomi delle variabili. Qui è type.La colonna da cui prendere nomi delle variabili. Qui è type.La colonna da cui prendere valori. Qui è count.La colonna da cui prendere valori. Qui è count.Una volta capito questo, possiamo usare pivot_wider(), come mostrato programmaticamente qui sotto, e visivamente nella figura 12.3.\nFigure 12.3: Pivoting table2 “wider”, tidy form.\nCome avrete capito dai loro nomi, pivot_wider() e pivot_longer() sono complementari. pivot_longer() rende le tabelle larghe più strette e lunghe; pivot_wider() rende le tabelle lunghe più corte e larghe.","code":"\ntable2\n#> # A tibble: 12 × 4\n#>   country      year type           count\n#>   <chr>       <dbl> <chr>          <dbl>\n#> 1 Afghanistan  1999 cases            745\n#> 2 Afghanistan  1999 population  19987071\n#> 3 Afghanistan  2000 cases           2666\n#> 4 Afghanistan  2000 population  20595360\n#> 5 Brazil       1999 cases          37737\n#> 6 Brazil       1999 population 172006362\n#> # … with 6 more rows\ntable2 %>%\n    pivot_wider(names_from = type, values_from = count)\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <dbl>      <dbl>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583"},{"path":"tidy-data.html","id":"esercizi-24","chapter":"12 Tidy data","heading":"12.3.3 Esercizi","text":"Perché metodi pivot_longer() e pivot_wider() non sono perfettamente simmetrici?\nConsiderate attentamente il seguente esempio:\n\nstocks <- tibble(\n  year   = c(2015, 2015, 2016, 2016),\n  half  = c(   1,    2,     1,    2),\n  return = c(1.88, 0.59, 0.92, 0.17)\n)\nstocks %>% \n  pivot_wider(names_from = year, values_from = return) %>% \n  pivot_longer(`2015`:`2016`, names_to = \"year\", values_to = \"return\")\n(Suggerimento: guardate tipi di variabili e pensate ai nomi delle colonne).\npivot_longer() ha un argomento names_ptypes, per esempio\nnames_ptypes = list(year = double()). Cosa fa?Perché metodi pivot_longer() e pivot_wider() non sono perfettamente simmetrici?\nConsiderate attentamente il seguente esempio:(Suggerimento: guardate tipi di variabili e pensate ai nomi delle colonne).pivot_longer() ha un argomento names_ptypes, per esempio\nnames_ptypes = list(year = double()). Cosa fa?Perché questo codice fallisce?\n\ntable4a %>% \n  pivot_longer(c(1999, 2000), names_to = \"year\", values_to = \"cases\")\n#> Error `pivot_longer()`:\n#> ! subset columns past end.\n#> ℹ Locations 1999 2000 exist.\n#> ℹ 3 columns.Perché questo codice fallisce?Cosa succederebbe se allargassi questa tabella? Perché? Come potresti aggiungere una nuova colonna per identificare modo univoco ogni valore?\n\npeople <- tribble(\n  ~name,             ~names,  ~values,\n  #-----------------|--------|------\n  \"Phillip Woods\",   \"age\",       45,\n  \"Phillip Woods\",   \"height\",   186,\n  \"Phillip Woods\",   \"age\",       50,\n  \"Jessica Cordero\", \"age\",       37,\n  \"Jessica Cordero\", \"height\",   156\n)Cosa succederebbe se allargassi questa tabella? Perché? Come potresti aggiungere una nuova colonna per identificare modo univoco ogni valore?Metti ordine la semplice tibble qui sotto. Devi renderla più larga o più lunga, quali sono le variabili?\n\npreg <- tribble(\n  ~pregnant, ~male, ~female,\n  \"yes\",     NA,    10,\n  \"\",      20,    12\n)Metti ordine la semplice tibble qui sotto. Devi renderla più larga o più lunga, quali sono le variabili?","code":"\nstocks <- tibble(\n  year   = c(2015, 2015, 2016, 2016),\n  half  = c(   1,    2,     1,    2),\n  return = c(1.88, 0.59, 0.92, 0.17)\n)\nstocks %>% \n  pivot_wider(names_from = year, values_from = return) %>% \n  pivot_longer(`2015`:`2016`, names_to = \"year\", values_to = \"return\")\ntable4a %>% \n  pivot_longer(c(1999, 2000), names_to = \"year\", values_to = \"cases\")\n#> Error in `pivot_longer()`:\n#> ! Can't subset columns past the end.\n#> ℹ Locations 1999 and 2000 don't exist.\n#> ℹ There are only 3 columns.\npeople <- tribble(\n  ~name,             ~names,  ~values,\n  #-----------------|--------|------\n  \"Phillip Woods\",   \"age\",       45,\n  \"Phillip Woods\",   \"height\",   186,\n  \"Phillip Woods\",   \"age\",       50,\n  \"Jessica Cordero\", \"age\",       37,\n  \"Jessica Cordero\", \"height\",   156\n)\npreg <- tribble(\n  ~pregnant, ~male, ~female,\n  \"yes\",     NA,    10,\n  \"no\",      20,    12\n)"},{"path":"tidy-data.html","id":"separare-e-unire","chapter":"12 Tidy data","heading":"12.4 Separare e unire","text":"Finora hai imparato come mettere ordine table2 e table4, ma non table3. La table3 ha un problema diverso: abbiamo una colonna (rate) che contiene due variabili (casi e popolazione). Per risolvere questo problema, avremo bisogno della funzione separate(). Imparerete anche il complemento di separate(): unite(), che si usa se una singola variabile è distribuita su più colonne.","code":""},{"path":"tidy-data.html","id":"separare","chapter":"12 Tidy data","heading":"12.4.1 Separare","text":"La funzione separate() separa una colonna colonne multiple, dividendo ogni volta che appare un carattere separatore. Prendiamo ad esempio table3:La colonna rate contiene entrambe le variabili cases e population, e abbiamo bisogno di dividerla due variabili. La funzione separate() prende il nome della colonna da separare e nomi delle colonne cui separare, come mostrato nella figura 12.4 e nel codice sottostante.\nFigure 12.4: Separating table3 makes tidy\nPer default, separate() dividerà valori ovunque veda un carattere non alfanumerico (cioè un carattere che non sia un numero o una lettera). Per esempio, nel codice qui sopra, separate() divide valori di rate corrispondenza dei caratteri ‘forward slash’. Se volete usare un carattere specifico per separare una colonna, potete passare il carattere ’argomento sep di separate(). Per esempio, potremmo riscrivere il codice sopra come:(Formalmente, sep è un’espressione regolare, di cui imparerai di più stringhe).Guardate attentamente tipi di colonna: noterete che cases e population sono colonne di caratteri. Questo è il comportamento predefinito di separate(): lascia il tipo di colonna così com’è. Qui, tuttavia, non è molto utile, dato che sono davvero numeri. Possiamo chiedere separate() di provare convertire tipi migliori usando convert = TRUE.:Potete anche passare un vettore di interi sep. separate() interpreterà gli interi come posizioni cui dividere. valori positivi partono da 1 ’estrema sinistra delle stringhe; valori negativi partono da -1 ’estrema destra delle stringhe. Quando si usano gli interi per separare le stringhe, la lunghezza di sep dovrebbe essere inferiore al numero di nomi .Puoi usare questa disposizione per separare le ultime due cifre di ogni anno. Questo rende questi dati meno ordinati, ma è utile altri casi, come vedrai tra poco.","code":"\ntable3\n#> # A tibble: 6 × 3\n#>   country      year rate             \n#>   <chr>       <dbl> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"))\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"), sep = \"/\")\ntable3 %>% \n  separate(rate, into = c(\"cases\", \"population\"), convert = TRUE)\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\ntable3 %>% \n  separate(year, into = c(\"century\", \"year\"), sep = 2)\n#> # A tibble: 6 × 4\n#>   country     century year  rate             \n#>   <chr>       <chr>   <chr> <chr>            \n#> 1 Afghanistan 19      99    745/19987071     \n#> 2 Afghanistan 20      00    2666/20595360    \n#> 3 Brazil      19      99    37737/172006362  \n#> 4 Brazil      20      00    80488/174504898  \n#> 5 China       19      99    212258/1272915272\n#> 6 China       20      00    213766/1280428583"},{"path":"tidy-data.html","id":"unite","chapter":"12 Tidy data","heading":"12.4.2 Unite","text":"unite()è l’inverso di separate(): combina colonne multiple una singola colonna. Ti servirà molto meno frequentemente di separate(), ma è comunque uno strumento utile da avere tasca.\nFigure 12.5: Uniting table5 makes tidy\nPossiamo usare unite() per riunire le colonne century e year che abbiamo creato nell’ultimo esempio. Questi dati vengono salvati come tidyr::table5. unite() prende un data frame, il nome della nuova variabile da creare e un insieme di colonne da combinare, sempre specificate stile dplyr::select():questo caso dobbiamo anche usare l’argomento sep. Il default metterà un underscore (_) tra valori delle diverse colonne. Qui non vogliamo nessun separatore quindi usiamo \"\":","code":"\ntable5 %>% \n  unite(new, century, year)\n#> # A tibble: 6 × 3\n#>   country     new   rate             \n#>   <chr>       <chr> <chr>            \n#> 1 Afghanistan 19_99 745/19987071     \n#> 2 Afghanistan 20_00 2666/20595360    \n#> 3 Brazil      19_99 37737/172006362  \n#> 4 Brazil      20_00 80488/174504898  \n#> 5 China       19_99 212258/1272915272\n#> 6 China       20_00 213766/1280428583\ntable5 %>% \n  unite(new, century, year, sep = \"\")\n#> # A tibble: 6 × 3\n#>   country     new   rate             \n#>   <chr>       <chr> <chr>            \n#> 1 Afghanistan 1999  745/19987071     \n#> 2 Afghanistan 2000  2666/20595360    \n#> 3 Brazil      1999  37737/172006362  \n#> 4 Brazil      2000  80488/174504898  \n#> 5 China       1999  212258/1272915272\n#> 6 China       2000  213766/1280428583"},{"path":"tidy-data.html","id":"esercizi-25","chapter":"12 Tidy data","heading":"12.4.3 Esercizi","text":"Cosa fanno gli argomenti extra e fill separate()?\nSperimentate le varie opzioni per seguenti due set di dati giocattolo.\n\ntibble(x = c(\",b,c\", \"d,e,f,g\", \"h,,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\",b,c\", \"d,e\", \"f,g,\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))Cosa fanno gli argomenti extra e fill separate()?\nSperimentate le varie opzioni per seguenti due set di dati giocattolo.Sia unite() che separate() hanno un argomento remove. Che cosa fa\nfa? Perché dovreste impostarlo FALSE?Sia unite() che separate() hanno un argomento remove. Che cosa fa\nfa? Perché dovreste impostarlo FALSE?Confrontate e contrapponete separate() e extract(). Perché ci sono\ntre varianti di separazione (per posizione, per separatore e con\ngruppi), ma solo una unite?Confrontate e contrapponete separate() e extract(). Perché ci sono\ntre varianti di separazione (per posizione, per separatore e con\ngruppi), ma solo una unite?","code":"\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))"},{"path":"tidy-data.html","id":"valori-mancanti-3","chapter":"12 Tidy data","heading":"12.5 Valori mancanti","text":"Cambiare la rappresentazione di un set di dati fa emergere un’importante sottigliezza sui valori mancanti. Sorprendentemente, un valore può essere mancante uno dei due modi possibili:Esplicitamente, cioè contrassegnato da NA.Implicitamente, cioè semplicemente non presente nei dati.Illustriamo questa idea con un insieme di dati molto semplice:Ci sono due valori mancanti questo set di dati:Il rendimento per il quarto trimestre del 2015 è esplicitamente mancante, perché\nla cella dove dovrebbe essere il suo valore contiene invece NA.Il rendimento per il quarto trimestre del 2015 è esplicitamente mancante, perché\nla cella dove dovrebbe essere il suo valore contiene invece NA.Il rendimento per il primo trimestre del 2016 è implicitamente mancante, perché\nsemplicemente non appare nel set di dati.Il rendimento per il primo trimestre del 2016 è implicitamente mancante, perché\nsemplicemente non appare nel set di dati.Un modo per pensare alla differenza è con questo koan zen: Un valore mancante esplicito è la presenza di un’assenza; un valore mancante implicito è l’assenza di una presenza.Il modo cui un set di dati è rappresentato può rendere espliciti valori impliciti. Per esempio, possiamo rendere esplicito il valore mancante implicito mettendo gli anni nelle colonne:Poiché questi valori mancanti espliciti potrebbero non essere importanti altre rappresentazioni dei dati, potete impostare values_drop_na = TRUE pivot_longer() per rendere impliciti valori mancanti espliciti:Un altro importante strumento per rendere espliciti valori mancanti nei dati ordinati è complete():complete() prende un insieme di colonne e trova tutte le combinazioni uniche. Poi si assicura che il dataset originale contenga tutti quei valori, riempiendo NA espliciti dove necessario.C’è un altro importante strumento che dovreste conoscere per lavorare con valori mancanti. volte, quando una fonte di dati è stata usata principalmente per l’inserimento di dati, valori mancanti indicano che il valore precedente dovrebbe essere portato avanti:Potete riempire questi valori mancanti con fill(). Prende un insieme di colonne cui volete che valori mancanti siano sostituiti dal più recente valore non mancante (volte chiamato ultima osservazione portata avanti).","code":"\nstocks <- tibble(\n  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),\n  qtr    = c(   1,    2,    3,    4,    2,    3,    4),\n  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\nstocks %>% \n  pivot_wider(names_from = year, values_from = return)\n#> # A tibble: 4 × 3\n#>     qtr `2015` `2016`\n#>   <dbl>  <dbl>  <dbl>\n#> 1     1   1.88  NA   \n#> 2     2   0.59   0.92\n#> 3     3   0.35   0.17\n#> 4     4  NA      2.66\nstocks %>% \n  pivot_wider(names_from = year, values_from = return) %>% \n  pivot_longer(\n    cols = c(`2015`, `2016`), \n    names_to = \"year\", \n    values_to = \"return\", \n    values_drop_na = TRUE\n  )\n#> # A tibble: 6 × 3\n#>     qtr year  return\n#>   <dbl> <chr>  <dbl>\n#> 1     1 2015    1.88\n#> 2     2 2015    0.59\n#> 3     2 2016    0.92\n#> 4     3 2015    0.35\n#> 5     3 2016    0.17\n#> 6     4 2016    2.66\nstocks %>% \n  complete(year, qtr)\n#> # A tibble: 8 × 3\n#>    year   qtr return\n#>   <dbl> <dbl>  <dbl>\n#> 1  2015     1   1.88\n#> 2  2015     2   0.59\n#> 3  2015     3   0.35\n#> 4  2015     4  NA   \n#> 5  2016     1  NA   \n#> 6  2016     2   0.92\n#> # … with 2 more rows\ntreatment <- tribble(\n  ~ person,           ~ treatment, ~response,\n  \"Derrick Whitmore\", 1,           7,\n  NA,                 2,           10,\n  NA,                 3,           9,\n  \"Katherine Burke\",  1,           4\n)\ntreatment %>% \n  fill(person)\n#> # A tibble: 4 × 3\n#>   person           treatment response\n#>   <chr>                <dbl>    <dbl>\n#> 1 Derrick Whitmore         1        7\n#> 2 Derrick Whitmore         2       10\n#> 3 Derrick Whitmore         3        9\n#> 4 Katherine Burke          1        4"},{"path":"tidy-data.html","id":"esercizi-26","chapter":"12 Tidy data","heading":"12.5.1 Esercizi","text":"Confrontate e contrapponete gli argomenti di fill pivot_wider() e complete().Confrontate e contrapponete gli argomenti di fill pivot_wider() e complete().Cosa fa l’argomento direction di fill()?Cosa fa l’argomento direction di fill()?","code":""},{"path":"tidy-data.html","id":"caso-di-studio","chapter":"12 Tidy data","heading":"12.6 Caso di studio","text":"Per finire il capitolo, mettiamo insieme tutto quello che abbiamo imparato per affrontare un realistico problema di riordino dei dati. Il dataset tidyr::contiene casi di tubercolosi (TB) suddivisi per anno, paese, età, sesso e metodo di diagnosi. dati provengono dal 2014 World Health Organization Global Tuberculosis Report, disponibile su http://www..int/tb/country/data/download/en/.C’è una ricchezza di informazioni epidemiologiche questo set di dati, ma è impegnativo lavorare con dati nella forma cui sono forniti:Questo è un tipico set di dati della vita reale. Contiene colonne ridondanti, codici variabili strani e molti valori mancanti. breve, è disordinato, e avremo bisogno di più passi per metterlo ordine. Come dplyr, tidyr è progettato modo che ogni funzione faccia bene una cosa. Questo significa che situazioni reali avrete bisogno di mettere insieme più verbi una pipeline.Il posto migliore per iniziare è quasi sempre quello di riunire le colonne che non sono variabili. Diamo un’occhiata quello che abbiamo:Sembra che country, iso2 e iso3 siano tre variabili che\nspecificano modo ridondante il paese.Sembra che country, iso2 e iso3 siano tre variabili che\nspecificano modo ridondante il paese.Anche year è chiaramente una variabile.Anche year è chiaramente una variabile.Non sappiamo ancora quali siano tutte le altre colonne, ma data la struttura\nnei nomi delle variabili (es. new_sp_m014, new_ep_m014, new_ep_f014)\nè probabile che questi siano valori, non variabili.Non sappiamo ancora quali siano tutte le altre colonne, ma data la struttura\nnei nomi delle variabili (es. new_sp_m014, new_ep_m014, new_ep_f014)\nè probabile che questi siano valori, non variabili.Quindi abbiamo bisogno di raccogliere tutte le colonne da new_sp_m014 newrel_f65. Non sappiamo ancora cosa rappresentano questi valori, quindi daremo loro il nome generico di \"key\". Sappiamo che le celle rappresentano il numero di casi, quindi useremo la variabile cases. Ci sono molti valori mancanti nella rappresentazione attuale, quindi per ora useremo values_drop_na solo per concentrarci sui valori che sono presenti.Possiamo avere qualche indizio sulla struttura dei valori nella nuova colonna “key” contandoli:Potresti essere grado di analizzarlo da solo con un po’ di ragionamento e qualche esperimento, ma fortunatamente abbiamo il dizionario dei dati portata di mano. Ci dice:Le prime tre lettere di ogni colonna indicano se la colonna\ncontiene nuovi o vecchi casi di TBC. questo set di dati, ogni colonna contiene\nnuovi casi.Le prime tre lettere di ogni colonna indicano se la colonna\ncontiene nuovi o vecchi casi di TBC. questo set di dati, ogni colonna contiene\nnuovi casi.Le due lettere successive descrivono il tipo di TBC:\nrel sta per casi di ricaduta\nep sta per casi di TB extrapolmonare\nsn sta per casi di TB polmonare che non possono essere diagnosticati da\nuno striscio polmonare (striscio negativo)\nsp sta per casi di TB polmonare che potrebbero essere diagnosticati da\nuno striscio polmonare (striscio positivo)\nLe due lettere successive descrivono il tipo di TBC:rel sta per casi di ricadutaep sta per casi di TB extrapolmonaresn sta per casi di TB polmonare che non possono essere diagnosticati da\nuno striscio polmonare (striscio negativo)sp sta per casi di TB polmonare che potrebbero essere diagnosticati da\nuno striscio polmonare (striscio positivo)La sesta lettera indica il sesso dei pazienti con TB. Il dataset raggruppa\ncasi per maschi (m) e femmine (f).La sesta lettera indica il sesso dei pazienti con TB. Il dataset raggruppa\ncasi per maschi (m) e femmine (f).numeri rimanenti danno il gruppo di età. Il set di dati raggruppa casi \nsette gruppi di età:\n014 = 0 – 14 anni\n1524 = 15 – 24 anni\n2534 = 25 – 34 anni\n3544 = 35 – 44 anni\n4554 = 45 – 54 anni\n5564 = 55 – 64 anni\n65 = 65 anni o più\nnumeri rimanenti danno il gruppo di età. Il set di dati raggruppa casi \nsette gruppi di età:014 = 0 – 14 anni1524 = 15 – 24 anni2534 = 25 – 34 anni3544 = 35 – 44 anni4554 = 45 – 54 anni5564 = 55 – 64 anni65 = 65 anni o piùDobbiamo fare una piccola correzione al formato dei nomi delle colonne: sfortunatamente nomi sono leggermente incoerenti perché invece di new_rel abbiamo newrel (è difficile da notare qui, ma se non lo correggi avremo degli errori nei passi successivi). Imparerai conoscere str_replace() [strings], ma l’idea di base è abbastanza semplice: sostituisci caratteri “newrel” con “new_rel”. Questo rende coerenti tutti nomi delle variabili.Possiamo separare valori ogni codice con due passaggi di separate(). Il primo passaggio dividerà codici ad ogni trattino basso.Allora potremmo anche eliminare la colonna new perché è costante questo set di dati. Mentre eliminiamo le colonne, eliminiamo anche iso2 e iso3 perché sono ridondanti.Poi separeremo sexage sex e age dividendo dopo il primo carattere:dataset now tidy!Vi ho mostrato il codice un pezzo alla volta, assegnando ogni risultato intermedio ad una nuova variabile. Questo tipicamente non è il modo cui si lavora modo interattivo. Invece, costruireste gradualmente un tubo complesso:","code":"\nwho\n#> # A tibble: 7,240 × 60\n#>   country     iso2  iso3   year new_sp…¹ new_s…² new_s…³ new_s…⁴ new_s…⁵ new_s…⁶\n#>   <chr>       <chr> <chr> <dbl>    <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n#> 1 Afghanistan AF    AFG    1980       NA      NA      NA      NA      NA      NA\n#> 2 Afghanistan AF    AFG    1981       NA      NA      NA      NA      NA      NA\n#> 3 Afghanistan AF    AFG    1982       NA      NA      NA      NA      NA      NA\n#> 4 Afghanistan AF    AFG    1983       NA      NA      NA      NA      NA      NA\n#> 5 Afghanistan AF    AFG    1984       NA      NA      NA      NA      NA      NA\n#> 6 Afghanistan AF    AFG    1985       NA      NA      NA      NA      NA      NA\n#> # … with 7,234 more rows, 50 more variables: new_sp_m65 <dbl>,\n#> #   new_sp_f014 <dbl>, new_sp_f1524 <dbl>, new_sp_f2534 <dbl>,\n#> #   new_sp_f3544 <dbl>, new_sp_f4554 <dbl>, new_sp_f5564 <dbl>,\n#> #   new_sp_f65 <dbl>, new_sn_m014 <dbl>, new_sn_m1524 <dbl>,\n#> #   new_sn_m2534 <dbl>, new_sn_m3544 <dbl>, new_sn_m4554 <dbl>,\n#> #   new_sn_m5564 <dbl>, new_sn_m65 <dbl>, new_sn_f014 <dbl>,\n#> #   new_sn_f1524 <dbl>, new_sn_f2534 <dbl>, new_sn_f3544 <dbl>, …\nwho1 <- who %>% \n  pivot_longer(\n    cols = new_sp_m014:newrel_f65, \n    names_to = \"key\", \n    values_to = \"cases\", \n    values_drop_na = TRUE\n  )\nwho1\n#> # A tibble: 76,046 × 6\n#>   country     iso2  iso3   year key          cases\n#>   <chr>       <chr> <chr> <dbl> <chr>        <dbl>\n#> 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n#> 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n#> 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n#> 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n#> 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n#> 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n#> # … with 76,040 more rows\nwho1 %>% \n  count(key)\n#> # A tibble: 56 × 2\n#>   key              n\n#>   <chr>        <int>\n#> 1 new_ep_f014   1032\n#> 2 new_ep_f1524  1021\n#> 3 new_ep_f2534  1021\n#> 4 new_ep_f3544  1021\n#> 5 new_ep_f4554  1017\n#> 6 new_ep_f5564  1017\n#> # … with 50 more rows\nwho2 <- who1 %>% \n  mutate(key = stringr::str_replace(key, \"newrel\", \"new_rel\"))\nwho2\n#> # A tibble: 76,046 × 6\n#>   country     iso2  iso3   year key          cases\n#>   <chr>       <chr> <chr> <dbl> <chr>        <dbl>\n#> 1 Afghanistan AF    AFG    1997 new_sp_m014      0\n#> 2 Afghanistan AF    AFG    1997 new_sp_m1524    10\n#> 3 Afghanistan AF    AFG    1997 new_sp_m2534     6\n#> 4 Afghanistan AF    AFG    1997 new_sp_m3544     3\n#> 5 Afghanistan AF    AFG    1997 new_sp_m4554     5\n#> 6 Afghanistan AF    AFG    1997 new_sp_m5564     2\n#> # … with 76,040 more rows\nwho3 <- who2 %>% \n  separate(key, c(\"new\", \"type\", \"sexage\"), sep = \"_\")\nwho3\n#> # A tibble: 76,046 × 8\n#>   country     iso2  iso3   year new   type  sexage cases\n#>   <chr>       <chr> <chr> <dbl> <chr> <chr> <chr>  <dbl>\n#> 1 Afghanistan AF    AFG    1997 new   sp    m014       0\n#> 2 Afghanistan AF    AFG    1997 new   sp    m1524     10\n#> 3 Afghanistan AF    AFG    1997 new   sp    m2534      6\n#> 4 Afghanistan AF    AFG    1997 new   sp    m3544      3\n#> 5 Afghanistan AF    AFG    1997 new   sp    m4554      5\n#> 6 Afghanistan AF    AFG    1997 new   sp    m5564      2\n#> # … with 76,040 more rows\nwho3 %>% \n  count(new)\n#> # A tibble: 1 × 2\n#>   new       n\n#>   <chr> <int>\n#> 1 new   76046\nwho4 <- who3 %>% \n  select(-new, -iso2, -iso3)\nwho5 <- who4 %>% \n  separate(sexage, c(\"sex\", \"age\"), sep = 1)\nwho5\n#> # A tibble: 76,046 × 6\n#>   country      year type  sex   age   cases\n#>   <chr>       <dbl> <chr> <chr> <chr> <dbl>\n#> 1 Afghanistan  1997 sp    m     014       0\n#> 2 Afghanistan  1997 sp    m     1524     10\n#> 3 Afghanistan  1997 sp    m     2534      6\n#> 4 Afghanistan  1997 sp    m     3544      3\n#> 5 Afghanistan  1997 sp    m     4554      5\n#> 6 Afghanistan  1997 sp    m     5564      2\n#> # … with 76,040 more rows\nwho %>%\n  pivot_longer(\n    cols = new_sp_m014:newrel_f65, \n    names_to = \"key\", \n    values_to = \"cases\", \n    values_drop_na = TRUE\n  ) %>% \n  mutate(\n    key = stringr::str_replace(key, \"newrel\", \"new_rel\")\n  ) %>%\n  separate(key, c(\"new\", \"var\", \"sexage\")) %>% \n  select(-new, -iso2, -iso3) %>% \n  separate(sexage, c(\"sex\", \"age\"), sep = 1)"},{"path":"tidy-data.html","id":"esercizi-27","chapter":"12 Tidy data","heading":"12.6.1 Esercizi","text":"questo caso di studio ho impostato values_drop_na = TRUE solo per rendere più facile\ncontrollare che avessimo valori corretti. È ragionevole? Pensate \ncome sono rappresentati valori mancanti questo set di dati. Ci sono valori impliciti\nvalori mancanti? Qual è la differenza tra un NA e uno zero?questo caso di studio ho impostato values_drop_na = TRUE solo per rendere più facile\ncontrollare che avessimo valori corretti. È ragionevole? Pensate \ncome sono rappresentati valori mancanti questo set di dati. Ci sono valori impliciti\nvalori mancanti? Qual è la differenza tra un NA e uno zero?Cosa succede se trascurate il passo mutate()?\n(mutate(names_from = stringr::str_replace(key, \"newrel\", \"new_rel\")))Cosa succede se trascurate il passo mutate()?\n(mutate(names_from = stringr::str_replace(key, \"newrel\", \"new_rel\")))Ho affermato che iso2 e iso3 sono ridondanti con country.\nConfermate questa affermazione.Ho affermato che iso2 e iso3 sono ridondanti con country.\nConfermate questa affermazione.Per ogni paese, anno e sesso, calcola il numero totale di casi di\nTBC. Fai una visualizzazione informativa dei dati.Per ogni paese, anno e sesso, calcola il numero totale di casi di\nTBC. Fai una visualizzazione informativa dei dati.","code":""},{"path":"tidy-data.html","id":"dati-non-tidy","chapter":"12 Tidy data","heading":"12.7 Dati non Tidy","text":"Prima di continuare con altri argomenti, vale la pena di parlare brevemente dei dati non ordinati. ’inizio del capitolo, ho usato il termine peggiorativo “disordinato” per riferirmi ai dati non ordinati. Questa è una semplificazione eccessiva: ci sono molte strutture di dati utili e ben fondate che non sono dati ordinati. Ci sono due ragioni principali per usare altre strutture di dati:Rappresentazioni alternative possono avere prestazioni sostanziali o vantaggi di spazio.\nvantaggi di spazio.Rappresentazioni alternative possono avere prestazioni sostanziali o vantaggi di spazio.\nvantaggi di spazio.campi specializzati hanno sviluppato le proprie convenzioni per la memorizzazione dei dati\nche possono essere molto diverse dalle convenzioni dei dati ordinati.campi specializzati hanno sviluppato le proprie convenzioni per la memorizzazione dei dati\nche possono essere molto diverse dalle convenzioni dei dati ordinati.Ognuno di questi motivi significa che avrete bisogno di qualcosa di diverso da un tibble (o data frame). Se vostri dati si adattano naturalmente ad una struttura rettangolare composta da osservazioni e variabili, penso che tidy data dovrebbe essere la vostra scelta predefinita. Ma ci sono buone ragioni per usare altre strutture; dati ordinati non sono l’unico modo.Se volete saperne di più sui dati non ordinati, vi consiglio vivamente questo post sul blog di Jeff Leek: http://simplystatistics.org/2016/02/17/non-tidy-data/.","code":""},{"path":"dati-relazionali.html","id":"dati-relazionali","chapter":"13 Dati relazionali","heading":"13 Dati relazionali","text":"","code":""},{"path":"dati-relazionali.html","id":"introduzione-7","chapter":"13 Dati relazionali","heading":"13.1 Introduzione","text":"È raro che un’analisi dei dati coinvolga solo una singola tabella di dati. Tipicamente si hanno molte tabelle di dati, e bisogna combinarle per rispondere alle domande che interessano. Collettivamente, più tabelle di dati sono chiamate dati relazionali perché sono importanti le relazioni, non solo singoli insiemi di dati.Le relazioni sono sempre definite tra una coppia di tabelle. Tutte le altre relazioni sono costruite partire da questa semplice idea: le relazioni di tre o più tabelle sono sempre una proprietà delle relazioni tra ogni coppia. volte entrambi gli elementi di una coppia possono essere la stessa tabella! Questo è necessario se, per esempio, avete una tabella di persone, e ogni persona ha un riferimento ai suoi genitori.Per lavorare con dati relazionali avete bisogno di verbi che lavorino con coppie di tabelle. Ci sono tre famiglie di verbi progettati per lavorare con dati relazionali:Mutating joins, che aggiungono nuove variabili ad un frame di dati dalla corrispondenza\nosservazioni un altro.Mutating joins, che aggiungono nuove variabili ad un frame di dati dalla corrispondenza\nosservazioni un altro.Filtering joins, che filtrano le osservazioni di un frame di dati base\nse corrispondono o meno ad un’osservazione nell’altra tabella.Filtering joins, che filtrano le osservazioni di un frame di dati base\nse corrispondono o meno ad un’osservazione nell’altra tabella.Operazioni di set, che trattano le osservazioni come se fossero elementi di un set.Operazioni di set, che trattano le osservazioni come se fossero elementi di un set.Il posto più comune per trovare dati relazionali è un sistema di gestione di database relazionali (o RDBMS), un termine che comprende quasi tutti moderni database. Se avete usato un database prima, avete quasi certamente usato SQL. Se è così, concetti di questo capitolo dovrebbero esservi familiari, anche se la loro espressione dplyr è un po’ diversa. generale, dplyr è un po’ più facile da usare di SQL perché dplyr è specializzato nell’analisi dei dati: rende più facili le comuni operazioni di analisi dei dati, spese di rendere più difficile fare altre cose che non sono comunemente necessarie per l’analisi dei dati.","code":""},{"path":"dati-relazionali.html","id":"prerequisiti-7","chapter":"13 Dati relazionali","heading":"13.1.1 Prerequisiti","text":"Esploreremo dati relazionali di nycflights13 usando verbi due tabelle di dplyr.","code":"\nlibrary(tidyverse)\nlibrary(nycflights13)"},{"path":"dati-relazionali.html","id":"nycflights13-relational","chapter":"13 Dati relazionali","heading":"13.2 nycflights13","text":"Useremo il pacchetto nycflights13 per imparare dati relazionali. nycflights13 contiene quattro tibbie che sono collegate alla tabella flights che avete usato trasformazione:airlines ti permette di cercare il nome completo del vettore dal suo codice abbreviato:\n\nairlines\n#> # tibble: 16 × 2\n#>   carrier name                    \n#>   <chr>   <chr>                   \n#> 1 9E      Endeavor Air Inc.       \n#> 2 AA      American Airlines Inc.  \n#> 3      Alaska Airlines Inc.    \n#> 4 B6      JetBlue Airways         \n#> 5 DL      Delta Air Lines Inc.    \n#> 6 EV      ExpressJet Airlines Inc.\n#> # … 10 rowsairlines ti permette di cercare il nome completo del vettore dal suo codice abbreviato:airports dà informazioni su ogni aeroporto, identificato dal codice aeroportuale faa:\n\nairports\n#> # tibble: 1,458 × 8\n#>   faa   name                             lat   lon   alt    tz dst   tzone      \n#>   <chr> <chr>                          <dbl> <dbl> <dbl> <dbl> <chr> <chr>      \n#> 1 04G   Lansdowne Airport               41.1 -80.6  1044    -5     America/Ne…\n#> 2 06A   Moton Field Municipal Airport   32.5 -85.7   264    -6     America/Ch…\n#> 3 06C   Schaumburg Regional             42.0 -88.1   801    -6     America/Ch…\n#> 4 06N   Randall Airport                 41.4 -74.4   523    -5     America/Ne…\n#> 5 09J   Jekyll Island Airport           31.1 -81.4    11    -5     America/Ne…\n#> 6 0A9   Elizabethton Municipal Airport  36.4 -82.2  1593    -5     America/Ne…\n#> # … 1,452 rowsairports dà informazioni su ogni aeroporto, identificato dal codice aeroportuale faa:planes dà informazioni su ogni aereo, identificato dal suo tailnum:\n\nplanes\n#> # tibble: 3,322 × 9\n#>   tailnum  year type                    manuf…¹ model engines seats speed engine\n#>   <chr>   <int> <chr>                   <chr>   <chr>   <int> <int> <int> <chr> \n#> 1 N10156   2004 Fixed wing multi engine EMBRAER EMB-…       2    55    NA Turbo…\n#> 2 N102UW   1998 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 3 N103US   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 4 N104UW   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 5 N10575   2002 Fixed wing multi engine EMBRAER EMB-…       2    55    NA Turbo…\n#> 6 N105UW   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> # … 3,316 rows, abbreviated variable name ¹​manufacturerplanes dà informazioni su ogni aereo, identificato dal suo tailnum:weather dà il meteo ogni aeroporto di NYC per ogni ora:\n\nweather\n#> # tibble: 26,115 × 15\n#>   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed wind_gust\n#>   <chr>  <int> <int> <int> <int> <dbl> <dbl> <dbl>    <dbl>      <dbl>     <dbl>\n#> 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4         NA\n#> 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06        NA\n#> 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5         NA\n#> 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7         NA\n#> 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7         NA\n#> 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5         NA\n#> # … 26,109 rows, 4 variables: precip <dbl>, pressure <dbl>,\n#> #   visib <dbl>, time_hour <dttm>weather dà il meteo ogni aeroporto di NYC per ogni ora:Un modo per mostrare le relazioni tra le diverse tabelle è un disegno:Questo diagramma è un po’ travolgente, ma è semplice rispetto ad alcuni che vedrete natura! La chiave per capire diagrammi come questo è ricordare che ogni relazione riguarda sempre una coppia di tabelle. Non c’è bisogno di capire tutto, basta capire la catena di relazioni tra le tabelle cui si è interessati.Per nycflights13:flights si connette planes attraverso una singola variabile, tailnum.flights si connette planes attraverso una singola variabile, tailnum.flights si connette airlines attraverso la variabile carrier.flights si connette airlines attraverso la variabile carrier.flights si connette airports due modi: attraverso le variabili origin e\ndest.flights si connette airports due modi: attraverso le variabili origin e\ndest.voli si connettono al meteo attraverso la variabile origin (la località), e\nyear, month, day e hour (il tempo).voli si connettono al meteo attraverso la variabile origin (la località), e\nyear, month, day e hour (il tempo).","code":"\nairlines\n#> # A tibble: 16 × 2\n#>   carrier name                    \n#>   <chr>   <chr>                   \n#> 1 9E      Endeavor Air Inc.       \n#> 2 AA      American Airlines Inc.  \n#> 3 AS      Alaska Airlines Inc.    \n#> 4 B6      JetBlue Airways         \n#> 5 DL      Delta Air Lines Inc.    \n#> 6 EV      ExpressJet Airlines Inc.\n#> # … with 10 more rows\nairports\n#> # A tibble: 1,458 × 8\n#>   faa   name                             lat   lon   alt    tz dst   tzone      \n#>   <chr> <chr>                          <dbl> <dbl> <dbl> <dbl> <chr> <chr>      \n#> 1 04G   Lansdowne Airport               41.1 -80.6  1044    -5 A     America/Ne…\n#> 2 06A   Moton Field Municipal Airport   32.5 -85.7   264    -6 A     America/Ch…\n#> 3 06C   Schaumburg Regional             42.0 -88.1   801    -6 A     America/Ch…\n#> 4 06N   Randall Airport                 41.4 -74.4   523    -5 A     America/Ne…\n#> 5 09J   Jekyll Island Airport           31.1 -81.4    11    -5 A     America/Ne…\n#> 6 0A9   Elizabethton Municipal Airport  36.4 -82.2  1593    -5 A     America/Ne…\n#> # … with 1,452 more rows\nplanes\n#> # A tibble: 3,322 × 9\n#>   tailnum  year type                    manuf…¹ model engines seats speed engine\n#>   <chr>   <int> <chr>                   <chr>   <chr>   <int> <int> <int> <chr> \n#> 1 N10156   2004 Fixed wing multi engine EMBRAER EMB-…       2    55    NA Turbo…\n#> 2 N102UW   1998 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 3 N103US   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 4 N104UW   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> 5 N10575   2002 Fixed wing multi engine EMBRAER EMB-…       2    55    NA Turbo…\n#> 6 N105UW   1999 Fixed wing multi engine AIRBUS… A320…       2   182    NA Turbo…\n#> # … with 3,316 more rows, and abbreviated variable name ¹​manufacturer\nweather\n#> # A tibble: 26,115 × 15\n#>   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed wind_gust\n#>   <chr>  <int> <int> <int> <int> <dbl> <dbl> <dbl>    <dbl>      <dbl>     <dbl>\n#> 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4         NA\n#> 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06        NA\n#> 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5         NA\n#> 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7         NA\n#> 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7         NA\n#> 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5         NA\n#> # … with 26,109 more rows, and 4 more variables: precip <dbl>, pressure <dbl>,\n#> #   visib <dbl>, time_hour <dttm>"},{"path":"dati-relazionali.html","id":"esercizi-28","chapter":"13 Dati relazionali","heading":"13.2.1 Esercizi","text":"Immagina di voler disegnare (approssimativamente) la rotta che ogni aereo vola da\nsua origine alla sua destinazione. Di quali variabili avresti bisogno? Quali tabelle\navreste bisogno di combinare?Immagina di voler disegnare (approssimativamente) la rotta che ogni aereo vola da\nsua origine alla sua destinazione. Di quali variabili avresti bisogno? Quali tabelle\navreste bisogno di combinare?Ho dimenticato di disegnare la relazione tra weather e airports.\nQual è la relazione e come dovrebbe apparire nel diagramma?Ho dimenticato di disegnare la relazione tra weather e airports.\nQual è la relazione e come dovrebbe apparire nel diagramma?weather contiene solo informazioni per gli aeroporti di origine (NYC). Se\ncontenesse le informazioni meteo per tutti gli aeroporti degli USA, quale ulteriore\nrelazione aggiuntiva definirebbe con flights?weather contiene solo informazioni per gli aeroporti di origine (NYC). Se\ncontenesse le informazioni meteo per tutti gli aeroporti degli USA, quale ulteriore\nrelazione aggiuntiva definirebbe con flights?Sappiamo che alcuni giorni dell’anno sono “speciali”, e meno persone del\npersone del solito volano quei giorni. Come potresti rappresentare questi dati come un frame di dati?\nQuali sarebbero le chiavi primarie di quella tabella? Come si connetterebbe alle\ntabelle esistenti?Sappiamo che alcuni giorni dell’anno sono “speciali”, e meno persone del\npersone del solito volano quei giorni. Come potresti rappresentare questi dati come un frame di dati?\nQuali sarebbero le chiavi primarie di quella tabella? Come si connetterebbe alle\ntabelle esistenti?","code":""},{"path":"dati-relazionali.html","id":"chiavi","chapter":"13 Dati relazionali","heading":"13.3 Chiavi","text":"Le variabili usate per collegare ogni coppia di tabelle sono chiamate chiavi. Una chiave è una variabile (o un insieme di variabili) che identifica univocamente un’osservazione. casi semplici, una singola variabile è sufficiente per identificare un’osservazione. Per esempio, ogni piano è identificato univocamente dal suo tailnum. altri casi, possono essere necessarie più variabili. Per esempio, per identificare un’osservazione weather sono necessarie cinque variabili: year, month, day, hour e origin.Ci sono due tipi di chiavi:Una chiave primaria identifica univocamente un’osservazione nella propria tabella.\nPer esempio, planes$tailnum è una chiave primaria perché identifica univocamente\nogni aereo nella tabella planes.Una chiave primaria identifica univocamente un’osservazione nella propria tabella.\nPer esempio, planes$tailnum è una chiave primaria perché identifica univocamente\nogni aereo nella tabella planes.Una chiave esterna identifica univocamente un’osservazione un’altra tabella.\nPer esempio, flights$tailnum è una chiave esterna perché appare nella tabella\ntabella flights dove corrisponde ad ogni volo ad un unico aereo.Una chiave esterna identifica univocamente un’osservazione un’altra tabella.\nPer esempio, flights$tailnum è una chiave esterna perché appare nella tabella\ntabella flights dove corrisponde ad ogni volo ad un unico aereo.Una variabile può essere sia una chiave primaria e una chiave esterna. Per esempio, origin fa parte della chiave primaria weather ed è anche una chiave esterna per la tabella airports.Una volta che hai identificato le chiavi primarie nelle tue tabelle, è una buona pratica verificare che esse identifichino davvero modo univoco ogni osservazione. Un modo per farlo è quello di count() le chiavi primarie e cercare le voci dove n è maggiore di uno:volte una tabella non ha una chiave primaria esplicita: ogni riga è un’osservazione, ma nessuna combinazione di variabili la identifica modo affidabile. Per esempio, qual è la chiave primaria nella tabella flights? Si potrebbe pensare che sia la data più il numero di volo o di coda, ma nessuno dei due è unico:Quando ho iniziato lavorare con questi dati, avevo ingenuamente supposto che ogni numero di volo sarebbe stato usato solo una volta al giorno: questo avrebbe reso molto più facile comunicare problemi con un volo specifico. Purtroppo non è così! Se una tabella manca di una chiave primaria, volte è utile aggiungerne una con mutate() e row_number(). Questo rende più facile far combaciare le osservazioni se avete fatto qualche filtraggio e volete ricontrollare dati originali. Questa è chiamata una _chiave surrogata__.Una chiave primaria e la corrispondente chiave esterna un’altra tabella formano una relazione. Le relazioni sono tipicamente uno--molti. Per esempio, ogni volo ha un aereo, ma ogni aereo ha molti voli. altri dati, occasionalmente vedrete una relazione 1 1. Potete pensare questo come ad un caso speciale di 1--molti. Potete modellare le relazioni molti--molti con una relazione molti--1 più una relazione 1--molti. Per esempio, questi dati c’è una relazione molti--molti tra compagnie aeree e aeroporti: ogni compagnia aerea vola molti aeroporti; ogni aeroporto ospita molte compagnie aeree.","code":"\nplanes %>% \n  count(tailnum) %>% \n  filter(n > 1)\n#> # A tibble: 0 × 2\n#> # … with 2 variables: tailnum <chr>, n <int>\n\nweather %>% \n  count(year, month, day, hour, origin) %>% \n  filter(n > 1)\n#> # A tibble: 3 × 6\n#>    year month   day  hour origin     n\n#>   <int> <int> <int> <int> <chr>  <int>\n#> 1  2013    11     3     1 EWR        2\n#> 2  2013    11     3     1 JFK        2\n#> 3  2013    11     3     1 LGA        2\nflights %>% \n  count(year, month, day, flight) %>% \n  filter(n > 1)\n#> # A tibble: 29,768 × 5\n#>    year month   day flight     n\n#>   <int> <int> <int>  <int> <int>\n#> 1  2013     1     1      1     2\n#> 2  2013     1     1      3     2\n#> 3  2013     1     1      4     2\n#> 4  2013     1     1     11     3\n#> 5  2013     1     1     15     2\n#> 6  2013     1     1     21     2\n#> # … with 29,762 more rows\n\nflights %>% \n  count(year, month, day, tailnum) %>% \n  filter(n > 1)\n#> # A tibble: 64,928 × 5\n#>    year month   day tailnum     n\n#>   <int> <int> <int> <chr>   <int>\n#> 1  2013     1     1 N0EGMQ      2\n#> 2  2013     1     1 N11189      2\n#> 3  2013     1     1 N11536      2\n#> 4  2013     1     1 N11544      3\n#> 5  2013     1     1 N11551      2\n#> 6  2013     1     1 N12540      2\n#> # … with 64,922 more rows"},{"path":"dati-relazionali.html","id":"esercizi-29","chapter":"13 Dati relazionali","heading":"13.3.1 Esercizi","text":"Aggiungere una chiave surrogata flights.Aggiungere una chiave surrogata flights.Identifica le chiavi nei seguenti set di dati\nLahman::Batting,\nbabynames::babynames.\nnasaweather::atmos.\nfueleconomy::vehicles\nggplot2::diamonds.\n(Potrebbe essere necessario installare alcuni pacchetti e leggere un po’ di documentazione).Identifica le chiavi nei seguenti set di datiLahman::Batting,babynames::babynames.nasaweather::atmos.fueleconomy::vehiclesggplot2::diamonds.(Potrebbe essere necessario installare alcuni pacchetti e leggere un po’ di documentazione).Disegna un diagramma che illustri le connessioni tra le tabelle Batting,\nPeople e Salaries nel pacchetto Lahman. Disegna un altro diagramma\nche mostra la relazione tra People, Managers, AwardsManagers.\nCome caratterizzeresti la relazione tra le tabelle Batting,\nPitching e Fielding?Disegna un diagramma che illustri le connessioni tra le tabelle Batting,\nPeople e Salaries nel pacchetto Lahman. Disegna un altro diagramma\nche mostra la relazione tra People, Managers, AwardsManagers.Come caratterizzeresti la relazione tra le tabelle Batting,\nPitching e Fielding?","code":""},{"path":"dati-relazionali.html","id":"mutating-joins","chapter":"13 Dati relazionali","heading":"13.4 Mutating joins","text":"Il primo strumento che vedremo per combinare una coppia di tabelle è la mutating join. Una mutating join permette di combinare le variabili di due tabelle. Prima abbina le osservazioni base alle loro chiavi, poi copia le variabili da una tabella ’altra.Come mutate(), le funzioni di join aggiungono le variabili destra, quindi se avete già molte variabili, le nuove variabili non verranno stampate. Per questi esempi, renderemo più facile vedere cosa succede negli esempi creando un set di dati più ristretto:(Ricordate, quando siete RStudio, potete anche usare View() per evitare questo problema).Immaginate di voler aggiungere il nome completo della compagnia aerea ai dati di flights2. Potete combinare data frame airlines e flights2 con left_join():Il risultato dell’unione delle compagnie aeree flights2 è una variabile aggiuntiva: name. Questo è il motivo per cui chiamo questo tipo di join un join mutante. questo caso, avreste potuto arrivare allo stesso punto usando mutate() e il subsetting di base di R:Ma questo è difficile da generalizzare quando si ha bisogno di abbinare più variabili, e richiede una lettura attenta per capire l’intento generale.Le sezioni seguenti spiegano, dettaglio, come funzionano le mutating joins. Comincerete imparando un’utile rappresentazione visiva delle unioni. Poi la useremo per spiegare le quattro funzioni di mutating join: l’inner join e le tre outer join. Quando si lavora con dati reali, le chiavi non sempre identificano modo univoco le osservazioni, quindi parleremo di cosa succede quando non c’è una corrispondenza unica. Infine, imparerete come dire dplyr quali variabili sono le chiavi per una data unione.","code":"\nflights2 <- flights %>% \n  select(year:day, hour, origin, dest, tailnum, carrier)\nflights2\n#> # A tibble: 336,776 × 8\n#>    year month   day  hour origin dest  tailnum carrier\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>  \n#> 1  2013     1     1     5 EWR    IAH   N14228  UA     \n#> 2  2013     1     1     5 LGA    IAH   N24211  UA     \n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA     \n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6     \n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL     \n#> 6  2013     1     1     5 EWR    ORD   N39463  UA     \n#> # … with 336,770 more rows\nflights2 %>%\n  select(-origin, -dest) %>% \n  left_join(airlines, by = \"carrier\")\n#> # A tibble: 336,776 × 7\n#>    year month   day  hour tailnum carrier name                  \n#>   <int> <int> <int> <dbl> <chr>   <chr>   <chr>                 \n#> 1  2013     1     1     5 N14228  UA      United Air Lines Inc. \n#> 2  2013     1     1     5 N24211  UA      United Air Lines Inc. \n#> 3  2013     1     1     5 N619AA  AA      American Airlines Inc.\n#> 4  2013     1     1     5 N804JB  B6      JetBlue Airways       \n#> 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc.  \n#> 6  2013     1     1     5 N39463  UA      United Air Lines Inc. \n#> # … with 336,770 more rows\nflights2 %>%\n  select(-origin, -dest) %>% \n  mutate(name = airlines$name[match(carrier, airlines$carrier)])\n#> # A tibble: 336,776 × 7\n#>    year month   day  hour tailnum carrier name                  \n#>   <int> <int> <int> <dbl> <chr>   <chr>   <chr>                 \n#> 1  2013     1     1     5 N14228  UA      United Air Lines Inc. \n#> 2  2013     1     1     5 N24211  UA      United Air Lines Inc. \n#> 3  2013     1     1     5 N619AA  AA      American Airlines Inc.\n#> 4  2013     1     1     5 N804JB  B6      JetBlue Airways       \n#> 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc.  \n#> 6  2013     1     1     5 N39463  UA      United Air Lines Inc. \n#> # … with 336,770 more rows"},{"path":"dati-relazionali.html","id":"capire-le-unioni","chapter":"13 Dati relazionali","heading":"13.4.1 Capire le unioni","text":"Per aiutarvi ad imparare come funzionano le join, userò una rappresentazione visiva:La colonna colorata rappresenta la variabile “chiave”: questa è usata per abbinare le righe tra le tabelle. La colonna grigia rappresenta la colonna “valore” che viene portata con sé per il viaggio. questi esempi mostrerò una singola variabile chiave, ma l’idea si generalizza modo diretto chiavi multiple e valori multipli.Un join è un modo di collegare ogni riga x zero, una o più righe y. Il diagramma seguente mostra ogni potenziale corrispondenza come un’intersezione di una coppia di linee.(Se guardate attentamente, potreste notare che abbiamo cambiato l’ordine delle colonne chiave e valore x. Questo è per enfatizzare che join corrispondono base alla chiave; il valore è solo portato con sé per il viaggio).un vero join, le corrispondenze saranno indicate con dei punti. Il numero di punti = il numero di corrispondenze = il numero di righe nell’output.","code":"\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     3, \"x3\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     4, \"y3\"\n)"},{"path":"dati-relazionali.html","id":"inner-join","chapter":"13 Dati relazionali","heading":"13.4.2 Inner join","text":"Il tipo più semplice di join è l’inner join. Un join interno abbina coppie di osservazioni ogni volta che le loro chiavi sono uguali:(Per essere precisi, questa è una equijoin interna perché le chiavi sono abbinate usando l’operatore di uguaglianza. Dato che la maggior parte delle unioni sono equijoin, di solito lasciamo perdere questa specificazione).L’output di un join interno è un nuovo data frame che contiene la chiave, valori x e valori y. Usiamo per dire dplyr quale variabile è la chiave:La proprietà più importante di un inner join è che le righe non abbinate non sono incluse nel risultato. Questo significa che generalmente le inner joins non sono appropriate per l’uso analisi perché è troppo facile perdere osservazioni.","code":"\nx %>% \n  inner_join(y, by = \"key\")\n#> # A tibble: 2 × 3\n#>     key val_x val_y\n#>   <dbl> <chr> <chr>\n#> 1     1 x1    y1   \n#> 2     2 x2    y2"},{"path":"dati-relazionali.html","id":"outer-join","chapter":"13 Dati relazionali","heading":"13.4.3 Outer joins","text":"Un inner join mantiene le osservazioni che appaiono entrambe le tabelle. Una outer join mantiene le osservazioni che appaiono almeno una delle tabelle. Ci sono tre tipi di outer join:Una left join mantiene tutte le osservazioni x.Un joint destra mantiene tutte le osservazioni y.Un full join mantiene tutte le osservazioni x e y.Questi join funzionano aggiungendo un’osservazione “virtuale” addizionale ad ogni tabella. Questa osservazione ha una chiave che corrisponde sempre (se nessun’altra chiave corrisponde), e un valore riempito con NA.Graficamente, questo appare come:L’unione più comunemente usata è l’unione sinistra: la si usa ogni volta che si cercano dati aggiuntivi da un’altra tabella, perché conserva le osservazioni originali anche quando non c’è una corrispondenza. L’unione sinistra dovrebbe essere la tua unione di default: usala meno che tu non abbia una forte ragione per preferire una delle altre.Un altro modo per rappresentare diversi tipi di join è un diagramma di Venn:Tuttavia, questa non è una grande rappresentazione. Potrebbe rinfrescarvi la memoria su quale join conserva le osservazioni quale tabella, ma soffre di una grande limitazione: un diagramma di Venn non può mostrare cosa succede quando le chiavi non identificano univocamente un’osservazione.","code":""},{"path":"dati-relazionali.html","id":"join-matches","chapter":"13 Dati relazionali","heading":"13.4.4 Chiavi duplicate","text":"Finora tutti diagrammi hanno assunto che le chiavi siano uniche. Ma questo non è sempre il caso. Questa sezione spiega cosa succede quando le chiavi non sono uniche. Ci sono due possibilità:Una tabella ha chiavi duplicate. Questo è utile quando vuoi aggiungere ulteriori informazioni, dato che tipicamente c’è una relazione uno--molti.\n\nNotate che ho messo la colonna chiave una posizione leggermente diversa nell’output.\nQuesto riflette il fatto che la chiave è una chiave primaria y e una chiave esterna x.\n\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     2, \"x3\",\n     1, \"x4\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\"\n)\nleft_join(x, y, = \"key\")\n#> # tibble: 4 × 3\n#>     key val_x val_y\n#>   <dbl> <chr> <chr>\n#> 1     1 x1    y1   \n#> 2     2 x2    y2   \n#> 3     2 x3    y2   \n#> 4     1 x4    y1Una tabella ha chiavi duplicate. Questo è utile quando vuoi aggiungere ulteriori informazioni, dato che tipicamente c’è una relazione uno--molti.Notate che ho messo la colonna chiave una posizione leggermente diversa nell’output.\nQuesto riflette il fatto che la chiave è una chiave primaria y e una chiave esterna x.Entrambe le tabelle hanno chiavi duplicate. Questo è di solito un errore perché nessuna delle due tabelle le chiavi identificano univocamente un’osservazione. Quando si uniscono chiavi duplicate, si ottengono tutte le combinazioni possibili, il prodotto cartesiano:\n\n\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     2, \"x3\",\n     3, \"x4\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     2, \"y3\",\n     3, \"y4\"\n)\nleft_join(x, y, = \"key\")\n#> Warning left_join(x, y, = \"key\"): row `x` expected match 1 row `y`.\n#> ℹ Row 2 `x` matches multiple rows.\n#> ℹ multiple matches expected, set `multiple = \"\"` silence \n#>   warning.\n#> # tibble: 6 × 3\n#>     key val_x val_y\n#>   <dbl> <chr> <chr>\n#> 1     1 x1    y1   \n#> 2     2 x2    y2   \n#> 3     2 x2    y3   \n#> 4     2 x3    y2   \n#> 5     2 x3    y3   \n#> 6     3 x4    y4Entrambe le tabelle hanno chiavi duplicate. Questo è di solito un errore perché nessuna delle due tabelle le chiavi identificano univocamente un’osservazione. Quando si uniscono chiavi duplicate, si ottengono tutte le combinazioni possibili, il prodotto cartesiano:","code":"\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     2, \"x3\",\n     1, \"x4\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\"\n)\nleft_join(x, y, by = \"key\")\n#> # A tibble: 4 × 3\n#>     key val_x val_y\n#>   <dbl> <chr> <chr>\n#> 1     1 x1    y1   \n#> 2     2 x2    y2   \n#> 3     2 x3    y2   \n#> 4     1 x4    y1\nx <- tribble(\n  ~key, ~val_x,\n     1, \"x1\",\n     2, \"x2\",\n     2, \"x3\",\n     3, \"x4\"\n)\ny <- tribble(\n  ~key, ~val_y,\n     1, \"y1\",\n     2, \"y2\",\n     2, \"y3\",\n     3, \"y4\"\n)\nleft_join(x, y, by = \"key\")\n#> Warning in left_join(x, y, by = \"key\"): Each row in `x` is expected to match at most 1 row in `y`.\n#> ℹ Row 2 of `x` matches multiple rows.\n#> ℹ If multiple matches are expected, set `multiple = \"all\"` to silence this\n#>   warning.\n#> # A tibble: 6 × 3\n#>     key val_x val_y\n#>   <dbl> <chr> <chr>\n#> 1     1 x1    y1   \n#> 2     2 x2    y2   \n#> 3     2 x2    y3   \n#> 4     2 x3    y2   \n#> 5     2 x3    y3   \n#> 6     3 x4    y4"},{"path":"dati-relazionali.html","id":"join-by","chapter":"13 Dati relazionali","heading":"13.4.5 Definizione delle colonne chiave","text":"Finora, le coppie di tabelle sono sempre state unite da una singola variabile, e questa variabile ha lo stesso nome entrambe le tabelle. Questo vincolo è stato codificato da = \"key\". Puoi usare altri valori per per collegare le tabelle altri modi:Il valore predefinito, = NULL, usa tutte le variabili che appaiono entrambe le tabelle, il cosiddetto natural join. Per esempio, le tabelle dei voli e del meteo corrispondono sulle loro variabili comuni: year, month, day, hour e origin.\n\nflights2 %>% \n  left_join(weather)\n#> Joining `= join_by(year, month, day, hour, origin)`\n#> # tibble: 336,776 × 18\n#>    year month   day  hour origin dest  tailnum carrier  temp  dewp humid wind_…¹\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <dbl> <dbl> <dbl>   <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA       39.0  28.0  64.4     260\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA       39.9  25.0  54.8     250\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA       39.0  27.0  61.6     260\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6       39.0  27.0  61.6     260\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL       39.9  25.0  54.8     260\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA       39.0  28.0  64.4     260\n#> # … 336,770 rows, 6 variables: wind_speed <dbl>,\n#> #   wind_gust <dbl>, precip <dbl>, pressure <dbl>, visib <dbl>,\n#> #   time_hour <dttm>, abbreviated variable name ¹​wind_dirIl valore predefinito, = NULL, usa tutte le variabili che appaiono entrambe le tabelle, il cosiddetto natural join. Per esempio, le tabelle dei voli e del meteo corrispondono sulle loro variabili comuni: year, month, day, hour e origin.Un vettore di caratteri, = \"x\". Questo è come un join naturale, ma usa solo\nalcune delle variabili comuni. Per esempio, flights e planes hanno\nvariabili year, ma significano cose diverse, quindi vogliamo unire solo per\ntailnum.\n\nflights2 %>% \n  left_join(planes, = \"tailnum\")\n#> # tibble: 336,776 × 16\n#>   year.x month   day  hour origin dest  tailnum carrier year.y type      manuf…¹\n#>    <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>    <int> <chr>     <chr>  \n#> 1   2013     1     1     5 EWR    IAH   N14228  UA        1999 Fixed wi… BOEING \n#> 2   2013     1     1     5 LGA    IAH   N24211  UA        1998 Fixed wi… BOEING \n#> 3   2013     1     1     5 JFK    MIA   N619AA  AA        1990 Fixed wi… BOEING \n#> 4   2013     1     1     5 JFK    BQN   N804JB  B6        2012 Fixed wi… AIRBUS \n#> 5   2013     1     1     6 LGA    ATL   N668DN  DL        1991 Fixed wi… BOEING \n#> 6   2013     1     1     5 EWR    ORD   N39463  UA        2012 Fixed wi… BOEING \n#> # … 336,770 rows, 5 variables: model <chr>, engines <int>,\n#> #   seats <int>, speed <int>, engine <chr>, abbreviated variable name\n#> #   ¹​manufacturer\nSi noti che le variabili year (che appaiono entrambi data frame di input,\nma non sono costrette ad essere uguali) sono disambiguate nell’output con\nun suffisso.Un vettore di caratteri, = \"x\". Questo è come un join naturale, ma usa solo\nalcune delle variabili comuni. Per esempio, flights e planes hanno\nvariabili year, ma significano cose diverse, quindi vogliamo unire solo per\ntailnum.Si noti che le variabili year (che appaiono entrambi data frame di input,\nma non sono costrette ad essere uguali) sono disambiguate nell’output con\nun suffisso.Un vettore di caratteri con nome: = c(\"\" = \"b\"). Questo\ncorrisponde alla variabile nella tabella x alla variabile b nella tabella y. Le\nvariabili da x saranno usate nell’output.\nPer esempio, se vogliamo disegnare una mappa abbiamo bisogno di combinare dati dei voli\ncon dati degli aeroporti che contengono la posizione (lat e lon) di\nogni aeroporto. Ogni volo ha un airport di origine e uno di destinazione, quindi\nbisogno di specificare quale vogliamo unire dati:\n\nflights2 %>% \n  left_join(airports, c(\"dest\" = \"faa\"))\n#> # tibble: 336,776 × 15\n#>    year month   day  hour origin dest  tailnum carrier name      lat   lon   alt\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <chr>   <dbl> <dbl> <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA      George…  30.0 -95.3    97\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA      George…  30.0 -95.3    97\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      Miami …  25.8 -80.3     8\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      <NA>     NA    NA      NA\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      Hartsf…  33.6 -84.4  1026\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Chicag…  42.0 -87.9   668\n#> # … 336,770 rows, 3 variables: tz <dbl>, dst <chr>,\n#> #   tzone <chr>\n\nflights2 %>% \n  left_join(airports, c(\"origin\" = \"faa\"))\n#> # tibble: 336,776 × 15\n#>    year month   day  hour origin dest  tailnum carrier name      lat   lon   alt\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <chr>   <dbl> <dbl> <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA      Newark…  40.7 -74.2    18\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA      La Gua…  40.8 -73.9    22\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      John F…  40.6 -73.8    13\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      John F…  40.6 -73.8    13\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      La Gua…  40.8 -73.9    22\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Newark…  40.7 -74.2    18\n#> # … 336,770 rows, 3 variables: tz <dbl>, dst <chr>,\n#> #   tzone <chr>Un vettore di caratteri con nome: = c(\"\" = \"b\"). Questo\ncorrisponde alla variabile nella tabella x alla variabile b nella tabella y. Le\nvariabili da x saranno usate nell’output.Per esempio, se vogliamo disegnare una mappa abbiamo bisogno di combinare dati dei voli\ncon dati degli aeroporti che contengono la posizione (lat e lon) di\nogni aeroporto. Ogni volo ha un airport di origine e uno di destinazione, quindi\nbisogno di specificare quale vogliamo unire dati:","code":"\nflights2 %>% \n  left_join(weather)\n#> Joining with `by = join_by(year, month, day, hour, origin)`\n#> # A tibble: 336,776 × 18\n#>    year month   day  hour origin dest  tailnum carrier  temp  dewp humid wind_…¹\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <dbl> <dbl> <dbl>   <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA       39.0  28.0  64.4     260\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA       39.9  25.0  54.8     250\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA       39.0  27.0  61.6     260\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6       39.0  27.0  61.6     260\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL       39.9  25.0  54.8     260\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA       39.0  28.0  64.4     260\n#> # … with 336,770 more rows, 6 more variables: wind_speed <dbl>,\n#> #   wind_gust <dbl>, precip <dbl>, pressure <dbl>, visib <dbl>,\n#> #   time_hour <dttm>, and abbreviated variable name ¹​wind_dir\nflights2 %>% \n  left_join(planes, by = \"tailnum\")\n#> # A tibble: 336,776 × 16\n#>   year.x month   day  hour origin dest  tailnum carrier year.y type      manuf…¹\n#>    <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>    <int> <chr>     <chr>  \n#> 1   2013     1     1     5 EWR    IAH   N14228  UA        1999 Fixed wi… BOEING \n#> 2   2013     1     1     5 LGA    IAH   N24211  UA        1998 Fixed wi… BOEING \n#> 3   2013     1     1     5 JFK    MIA   N619AA  AA        1990 Fixed wi… BOEING \n#> 4   2013     1     1     5 JFK    BQN   N804JB  B6        2012 Fixed wi… AIRBUS \n#> 5   2013     1     1     6 LGA    ATL   N668DN  DL        1991 Fixed wi… BOEING \n#> 6   2013     1     1     5 EWR    ORD   N39463  UA        2012 Fixed wi… BOEING \n#> # … with 336,770 more rows, 5 more variables: model <chr>, engines <int>,\n#> #   seats <int>, speed <int>, engine <chr>, and abbreviated variable name\n#> #   ¹​manufacturer\nflights2 %>% \n  left_join(airports, c(\"dest\" = \"faa\"))\n#> # A tibble: 336,776 × 15\n#>    year month   day  hour origin dest  tailnum carrier name      lat   lon   alt\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <chr>   <dbl> <dbl> <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA      George…  30.0 -95.3    97\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA      George…  30.0 -95.3    97\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      Miami …  25.8 -80.3     8\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      <NA>     NA    NA      NA\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      Hartsf…  33.6 -84.4  1026\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Chicag…  42.0 -87.9   668\n#> # … with 336,770 more rows, and 3 more variables: tz <dbl>, dst <chr>,\n#> #   tzone <chr>\n\nflights2 %>% \n  left_join(airports, c(\"origin\" = \"faa\"))\n#> # A tibble: 336,776 × 15\n#>    year month   day  hour origin dest  tailnum carrier name      lat   lon   alt\n#>   <int> <int> <int> <dbl> <chr>  <chr> <chr>   <chr>   <chr>   <dbl> <dbl> <dbl>\n#> 1  2013     1     1     5 EWR    IAH   N14228  UA      Newark…  40.7 -74.2    18\n#> 2  2013     1     1     5 LGA    IAH   N24211  UA      La Gua…  40.8 -73.9    22\n#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      John F…  40.6 -73.8    13\n#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      John F…  40.6 -73.8    13\n#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      La Gua…  40.8 -73.9    22\n#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Newark…  40.7 -74.2    18\n#> # … with 336,770 more rows, and 3 more variables: tz <dbl>, dst <chr>,\n#> #   tzone <chr>"},{"path":"dati-relazionali.html","id":"esercizi-30","chapter":"13 Dati relazionali","heading":"13.4.6 Esercizi","text":"Calcola il ritardo medio per destinazione, poi unisciti al data frame airport modo da poter mostrare la distribuzione spaziale dei ritardi. Ecco un modo semplice per disegnare una mappa degli Stati Uniti:\n\nairports %>%\n  semi_join(flights, c(\"faa\" = \"dest\")) %>%\n  ggplot(aes(lon, lat)) +\n    borders(\"state\") +\n    geom_point() +\n    coord_quickmap()\n(Non preoccupatevi se non capite cosa fa semi_join() — lo imparerete\nimparerete dopo).\nPotreste voler usare la dimensione o il colore dei punti per visualizzare\nil ritardo medio per ogni aeroporto.Calcola il ritardo medio per destinazione, poi unisciti al data frame airport modo da poter mostrare la distribuzione spaziale dei ritardi. Ecco un modo semplice per disegnare una mappa degli Stati Uniti:(Non preoccupatevi se non capite cosa fa semi_join() — lo imparerete\nimparerete dopo).Potreste voler usare la dimensione o il colore dei punti per visualizzare\nil ritardo medio per ogni aeroporto.Aggiungi la posizione dell’origine e della destinazione (cioè la lat e la lon)\nflights.Aggiungi la posizione dell’origine e della destinazione (cioè la lat e la lon)\nflights.Esiste una relazione tra l’età di un aereo e suoi ritardi?Esiste una relazione tra l’età di un aereo e suoi ritardi?Quali condizioni meteorologiche rendono più probabile un ritardo?Quali condizioni meteorologiche rendono più probabile un ritardo?Cosa è successo il 13 giugno 2013? Visualizza lo schema spaziale dei ritardi,\ne poi usa Google per fare un riferimento incrociato con le condizionir.Cosa è successo il 13 giugno 2013? Visualizza lo schema spaziale dei ritardi,\ne poi usa Google per fare un riferimento incrociato con le condizionir.","code":"\nairports %>%\n  semi_join(flights, c(\"faa\" = \"dest\")) %>%\n  ggplot(aes(lon, lat)) +\n    borders(\"state\") +\n    geom_point() +\n    coord_quickmap()"},{"path":"dati-relazionali.html","id":"altre-implementazioni","chapter":"13 Dati relazionali","heading":"13.4.7 Altre implementazioni","text":"base::merge() può eseguire tutti e quattro tipi di mutating join:Il vantaggio dei verbi specifici di dplyr è che trasmettono più chiaramente l’intento del vostro codice: la differenza tra join è davvero importante ma nascosta negli argomenti di merge(). join di dplyr sono considerevolmente più veloci e non incasinano l’ordine delle righe.SQL è l’ispirazione per le convenzioni di dplyr, quindi la traduzione è semplice:Si noti che “INNER” e “OUTER” sono opzionali, e spesso omessi.Unire diverse variabili tra le tabelle, per esempio inner_join(x, y, = c(\"\" = \"b\")) usa una sintassi leggermente diversa SQL: SELECT * x INNER JOIN y x.= y.b. Come suggerisce questa sintassi, SQL supporta una gamma più ampia di tipi di join rispetto dplyr perché è possibile collegare le tabelle usando vincoli diversi dall’uguaglianza (volte chiamati non-equijoin).","code":""},{"path":"dati-relazionali.html","id":"filtering-joins","chapter":"13 Dati relazionali","heading":"13.5 Filtering joins","text":"Le filtering joins fanno corrispondere le osservazioni allo stesso modo delle mutating joins, ma influenzano le osservazioni, non le variabili. Ne esistono due tipi:semi_join(x, y) tiene tutte le osservazioni x che hanno una corrispondenza y.anti_join(x, y) drops tutte le osservazioni x che hanno una corrispondenza y.Le semi-join sono utili per far corrispondere tabelle di riepilogo filtrate alle righe originali. Per esempio, immaginate di aver trovato le prime dieci destinazioni più popolari:Ora vuoi trovare ogni volo che è andato una di queste destinazioni. Potresti costruire tu stesso un filtro:Ma è difficile estendere questo approccio più variabili. Per esempio, immagina di aver trovato 10 giorni con più alti ritardi medi. Come costruireste la dichiarazione del filtro che usa year, month e day per abbinarlo flight?Invece puoi usare una semi-join, che collega le due tabelle come una mutating join, ma invece di aggiungere nuove colonne, mantiene solo le righe x che hanno una corrispondenza y:Graficamente, una semi-unione appare così:Solo l’esistenza di una corrispondenza è importante; non ha importanza quale osservazione viene abbinata. Questo significa che filtering joins non duplicano mai le righe come fanno mutating joins:L’inverso di una semi-join è un anti-join. Un anti-join mantiene le righe che non hanno una corrispondenza:Gli anti-join sono utili per diagnosticare le mancate corrispondenze. Per esempio, quando si collegano flights e planes, si potrebbe essere interessati sapere che ci sono molti flights che non hanno una corrispondenza planes:","code":"\ntop_dest <- flights %>%\n  count(dest, sort = TRUE) %>%\n  head(10)\ntop_dest\n#> # A tibble: 10 × 2\n#>   dest      n\n#>   <chr> <int>\n#> 1 ORD   17283\n#> 2 ATL   17215\n#> 3 LAX   16174\n#> 4 BOS   15508\n#> 5 MCO   14082\n#> 6 CLT   14064\n#> # … with 4 more rows\nflights %>% \n  filter(dest %in% top_dest$dest)\n#> # A tibble: 141,145 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      542         540       2     923     850      33 AA     \n#> 2  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 3  2013     1     1      554         558      -4     740     728      12 UA     \n#> 4  2013     1     1      555         600      -5     913     854      19 B6     \n#> 5  2013     1     1      557         600      -3     838     846      -8 B6     \n#> 6  2013     1     1      558         600      -2     753     745       8 AA     \n#> # … with 141,139 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\nflights %>% \n  semi_join(top_dest)\n#> Joining with `by = join_by(dest)`\n#> # A tibble: 141,145 × 19\n#>    year month   day dep_time sched_dep…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier\n#>   <int> <int> <int>    <int>       <int>   <dbl>   <int>   <int>   <dbl> <chr>  \n#> 1  2013     1     1      542         540       2     923     850      33 AA     \n#> 2  2013     1     1      554         600      -6     812     837     -25 DL     \n#> 3  2013     1     1      554         558      -4     740     728      12 UA     \n#> 4  2013     1     1      555         600      -5     913     854      19 B6     \n#> 5  2013     1     1      557         600      -3     838     846      -8 B6     \n#> 6  2013     1     1      558         600      -2     753     745       8 AA     \n#> # … with 141,139 more rows, 9 more variables: flight <int>, tailnum <chr>,\n#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names\n#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay\nflights %>%\n  anti_join(planes, by = \"tailnum\") %>%\n  count(tailnum, sort = TRUE)\n#> # A tibble: 722 × 2\n#>   tailnum     n\n#>   <chr>   <int>\n#> 1 <NA>     2512\n#> 2 N725MQ    575\n#> 3 N722MQ    513\n#> 4 N723MQ    507\n#> 5 N713MQ    483\n#> 6 N735MQ    396\n#> # … with 716 more rows"},{"path":"dati-relazionali.html","id":"esercizi-31","chapter":"13 Dati relazionali","heading":"13.5.1 Esercizi","text":"Cosa significa che un volo ha un tailnum mancante? Cosa hanno comune \nnumeri di coda che non hanno un record corrispondente planes hanno comune?\n(Suggerimento: una variabile spiega il ~90% dei problemi).Cosa significa che un volo ha un tailnum mancante? Cosa hanno comune \nnumeri di coda che non hanno un record corrispondente planes hanno comune?\n(Suggerimento: una variabile spiega il ~90% dei problemi).Filtra voli per mostrare solo voli con aerei che hanno volato almeno 100\nvoli.Filtra voli per mostrare solo voli con aerei che hanno volato almeno 100\nvoli.Combina fueleconomy::vehicles e fueleconomy::common per trovare solo \nrecord per modelli più comuni.Combina fueleconomy::vehicles e fueleconomy::common per trovare solo \nrecord per modelli più comuni.Trova le 48 ore (nel corso dell’intero anno) che hanno peggiori\nritardi. Fai un riferimento incrociato con dati weather. Puoi vedere qualche\nmodelli?Trova le 48 ore (nel corso dell’intero anno) che hanno peggiori\nritardi. Fai un riferimento incrociato con dati weather. Puoi vedere qualche\nmodelli?Cosa ti dice anti_join(flights, airports, = c(\"dest\" = \"faa\"))?\nChe cosa ti dice anti_join(airports, flights, = c(\"faa\" = \"dest\"))?\nCosa ti dice anti_join(flights, airports, = c(\"dest\" = \"faa\"))?Che cosa ti dice anti_join(airports, flights, = c(\"faa\" = \"dest\"))?Ci si potrebbe aspettare che ci sia una relazione implicita tra aereo\ne compagnia aerea, perché ogni aereo è pilotato da una sola compagnia aerea. Confermate\no rifiutare questa ipotesi usando gli strumenti che hai imparato sopra.Ci si potrebbe aspettare che ci sia una relazione implicita tra aereo\ne compagnia aerea, perché ogni aereo è pilotato da una sola compagnia aerea. Confermate\no rifiutare questa ipotesi usando gli strumenti che hai imparato sopra.","code":""},{"path":"dati-relazionali.html","id":"problemi-di-join","chapter":"13 Dati relazionali","heading":"13.6 Problemi di join","text":"dati con cui avete lavorato questo capitolo sono stati puliti modo che abbiate meno problemi possibili. E’ improbabile che vostri dati siano così belli, quindi ci sono alcune cose che dovreste fare con vostri dati per far sì che le vostre unioni vadano lisce.Iniziate identificando le variabili che formano la chiave primaria ogni tabella.\nDi solito dovreste farlo basandovi sulla vostra comprensione dei dati, non\nempiricamente cercando una combinazione di variabili che dia un\nidentificatore unico. Se cercate solo le variabili senza pensare \nal loro significato, potreste essere (dis)fortunati e trovare una combinazione che è\nunica nei vostri dati attuali, ma la relazione potrebbe non essere vera \ngenerale.\nPer esempio, l’altitudine e la longitudine identificano modo unico ogni aeroporto,\nma non sono buoni identificatori!\n\nairports %>% count(alt, lon) %>% filter(n > 1)\n#> # tibble: 0 × 3\n#> # … 3 variables: alt <dbl>, lon <dbl>, n <int>Iniziate identificando le variabili che formano la chiave primaria ogni tabella.\nDi solito dovreste farlo basandovi sulla vostra comprensione dei dati, non\nempiricamente cercando una combinazione di variabili che dia un\nidentificatore unico. Se cercate solo le variabili senza pensare \nal loro significato, potreste essere (dis)fortunati e trovare una combinazione che è\nunica nei vostri dati attuali, ma la relazione potrebbe non essere vera \ngenerale.Per esempio, l’altitudine e la longitudine identificano modo unico ogni aeroporto,\nma non sono buoni identificatori!Controllare che nessuna delle variabili della chiave primaria sia mancante. Se\nun valore è mancante allora non può identificare un’osservazione!Controllare che nessuna delle variabili della chiave primaria sia mancante. Se\nun valore è mancante allora non può identificare un’osservazione!Controlla che le tue chiavi esterne corrispondano alle chiavi primarie di un’altra tabella. Il\nmodo migliore per farlo è con un anti_join(). È comune che le chiavi\nnon corrispondano causa di errori nell’inserimento dei dati. Correggere questi errori è spesso un sacco di\nlavoro.\nSe avete delle chiavi mancanti, dovrete essere attenti ’uso\nl’uso delle unioni interne rispetto quelle esterne, valutando attentamente se\nse volete eliminare le righe che non hanno una corrispondenza.Controlla che le tue chiavi esterne corrispondano alle chiavi primarie di un’altra tabella. Il\nmodo migliore per farlo è con un anti_join(). È comune che le chiavi\nnon corrispondano causa di errori nell’inserimento dei dati. Correggere questi errori è spesso un sacco di\nlavoro.Se avete delle chiavi mancanti, dovrete essere attenti ’uso\nl’uso delle unioni interne rispetto quelle esterne, valutando attentamente se\nse volete eliminare le righe che non hanno una corrispondenza.Siate consapevoli che controllare semplicemente il numero di righe prima e dopo l’unione non è sufficiente ad assicurare che la vostra unione sia andata bene. Se hai un join interno con chiavi duplicate entrambe le tabelle, potresti essere sfortunato perché il numero di righe eliminate potrebbe essere esattamente uguale al numero di righe duplicate!","code":"\nairports %>% count(alt, lon) %>% filter(n > 1)\n#> # A tibble: 0 × 3\n#> # … with 3 variables: alt <dbl>, lon <dbl>, n <int>"},{"path":"dati-relazionali.html","id":"set-operations","chapter":"13 Dati relazionali","heading":"13.7 Operazioni di set","text":"L’ultimo tipo di verbo di due tabelle sono le operazioni di set. Generalmente sono quelle che uso meno frequentemente, ma sono occasionalmente utili quando si vuole spezzare un singolo filtro complesso pezzi più semplici. Tutte queste operazioni lavorano con una riga completa, confrontando valori di ogni variabile. Queste si aspettano che gli input x e y abbiano le stesse variabili, e trattano le osservazioni come insiemi:intersect(x, y): restituisce solo le osservazioni sia x che y.union(x, y): restituisce osservazioni uniche x e y.setdiff(x, y): restituisce le osservazioni x, ma non y.Dati questi semplici dati:Le quattro possibilità sono:","code":"\ndf1 <- tribble(\n  ~x, ~y,\n   1,  1,\n   2,  1\n)\ndf2 <- tribble(\n  ~x, ~y,\n   1,  1,\n   1,  2\n)\nintersect(df1, df2)\n#> # A tibble: 1 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1     1\n\n# Notate che otteniamo 3 righe, non 4\nunion(df1, df2)\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1     1\n#> 2     2     1\n#> 3     1     2\n\nsetdiff(df1, df2)\n#> # A tibble: 1 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     2     1\n\nsetdiff(df2, df1)\n#> # A tibble: 1 × 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1     1     2"},{"path":"stringhe.html","id":"stringhe","chapter":"14 Stringhe","heading":"14 Stringhe","text":"","code":""},{"path":"stringhe.html","id":"introduzione-8","chapter":"14 Stringhe","heading":"14.1 Introduzione","text":"Questo capitolo vi introduce alla manipolazione delle stringhe R. Imparerete le basi di come funzionano le stringhe e come crearle mano, ma il focus di questo capitolo sarà sulle espressioni regolari, o regexps breve. Le espressioni regolari sono utili perché le stringhe di solito contengono dati non strutturati o semi-strutturati, e le regexp sono un linguaggio conciso per descrivere modelli nelle stringhe. Quando guardi per la prima volta una regexp, penserai che un gatto abbia camminato sulla tua tastiera, ma man mano che la tua comprensione migliora cominceranno presto ad avere senso.","code":""},{"path":"stringhe.html","id":"prerequisiti-8","chapter":"14 Stringhe","heading":"14.1.1 Prerequisiti","text":"Questo capitolo si concentrerà sul pacchetto stringr per la manipolazione delle stringhe, che fa parte del core tidyverse.","code":"\nlibrary(tidyverse)"},{"path":"stringhe.html","id":"nozioni-di-base-sulle-stringhe","chapter":"14 Stringhe","heading":"14.2 Nozioni di base sulle stringhe","text":"È possibile creare stringhe con apici singoli o doppi. differenza di altri linguaggi, non c’è differenza di comportamento. Raccomando di usare sempre \", meno che non vogliate creare una stringa che contenga più \".Se dimenticate di chiudere una citazione, vedrete +, il carattere di continuazione:Se ti succede questo, premi Escape e prova di nuovo!Per includere una citazione singola o doppia letterale una stringa puoi usare \\ per “escape”:Ciò significa che se volete includere un backslash letterale, dovrete raddoppiarlo: \"\\\\\".Attenzione che la rappresentazione stampata di una stringa non è la stessa della stringa stessa, perché la rappresentazione stampata mostra gli escape. Per vedere il contenuto grezzo della stringa, usa writeLines():Ci sono una manciata di altri caratteri speciali. più comuni sono \"\\n\", newline, e \"\\t\", tab, ma puoi vedere la lista completa chiedendo aiuto su \": ?'\"', o ?\"'\". volte vedrai anche stringhe come \"\\u00b5\", questo è un modo di scrivere caratteri non inglesi che funziona su tutte le piattaforme:Le stringhe multiple sono spesso memorizzate un vettore di caratteri, che puoi creare con c():","code":"\nstring1 <- \"Questa è una stringa\"\nstring2 <- 'If I want to include a \"quote\" inside a string, I use single quotes' \n# non traducibile (altrimenti non si capisce l'esempio)> \"Questa è una stringa senza virgolette di chiusura\n+ \n+ \n+ AIUTO SONO BLOCCATO\ndouble_quote <- \"\\\"\" # o '\"'\nsingle_quote <- '\\'' # o \"'\"\nx <- c(\"\\\"\", \"\\\\\")\nx\n#> [1] \"\\\"\" \"\\\\\"\nwriteLines(x)\n#> \"\n#> \\\nx <- \"\\u00b5\"\nx\n#> [1] \"µ\"\nc(\"una\", \"due\", \"tre\")\n#> [1] \"una\" \"due\" \"tre\""},{"path":"stringhe.html","id":"lunghezza-della-stringa","chapter":"14 Stringhe","heading":"14.2.1 Lunghezza della stringa","text":"Base R contiene molte funzioni per lavorare con le stringhe, ma le eviteremo perché possono essere incoerenti, il che le rende difficili da ricordare. Invece useremo le funzioni di stringr. Queste hanno nomi più intuitivi e iniziano tutte con str_. Per esempio, str_length() vi dice il numero di caratteri una stringa:Il prefisso comune str_ è particolarmente utile se usate RStudio, perché digitando str_ si attiva il completamento automatico, permettendovi di vedere tutte le funzioni di stringr:","code":"\nstr_length(c(\"a\", \"R per data science\", NA))\n#> [1]  1 18 NA"},{"path":"stringhe.html","id":"combinazione-di-stringhe","chapter":"14 Stringhe","heading":"14.2.2 Combinazione di stringhe","text":"Per combinare due o più stringhe, usate str_c():Usa l’argomento sep per controllare come sono separati:Come molte altre funzioni R, valori mancanti sono contagiosi. Se volete stamparli come \"NA\", usate str_replace_na():Come mostrato sopra, str_c() è vettorializzata, e ricicla automaticamente vettori più corti alla stessa lunghezza del più lungo:Gli oggetti di lunghezza 0 vengono eliminati silenziosamente. Questo è particolarmente utile insieme :Per far collassare un vettore di stringhe una singola stringa, usate collapse:","code":"\nstr_c(\"x\", \"y\")\n#> [1] \"xy\"\nstr_c(\"x\", \"y\", \"z\")\n#> [1] \"xyz\"\nstr_c(\"x\", \"y\", sep = \", \")\n#> [1] \"x, y\"\nx <- c(\"abc\", NA)\nstr_c(\"|-\", x, \"-|\")\n#> [1] \"|-abc-|\" NA\nstr_c(\"|-\", str_replace_na(x), \"-|\")\n#> [1] \"|-abc-|\" \"|-NA-|\"\nstr_c(\"prefix-\", c(\"a\", \"b\", \"c\"), \"-suffix\")\n#> [1] \"prefix-a-suffix\" \"prefix-b-suffix\" \"prefix-c-suffix\"\nname <- \"Hadley\"\ntime_of_day <- \"morning\"\nbirthday <- FALSE\n\nstr_c(\n  \"Good \", time_of_day, \" \", name,\n  if (birthday) \" and HAPPY BIRTHDAY\",\n  \".\"\n)\n#> [1] \"Good morning Hadley.\"\nstr_c(c(\"x\", \"y\", \"z\"), collapse = \", \")\n#> [1] \"x, y, z\""},{"path":"stringhe.html","id":"sottoscrizione-di-stringhe","chapter":"14 Stringhe","heading":"14.2.3 Sottoscrizione di stringhe","text":"Potete estrarre parti di una stringa usando str_sub(). Oltre alla stringa, str_sub() prende gli argomenti start e end che danno la posizione (inclusa) della sottostringa:Si noti che str_sub() non fallirà se la stringa è troppo corta: semplicemente restituirà il più possibile:Potete anche usare la forma di assegnazione di str_sub() per modificare le stringhe:","code":"\nx <- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n#> [1] \"App\" \"Ban\" \"Pea\"\n# i numeri negativi contano all'indietro dalla fine\nstr_sub(x, -3, -1)\n#> [1] \"ple\" \"ana\" \"ear\"\nstr_sub(\"a\", 1, 5)\n#> [1] \"a\"\nstr_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))\nx\n#> [1] \"apple\"  \"banana\" \"pear\""},{"path":"stringhe.html","id":"locale","chapter":"14 Stringhe","heading":"14.2.4 Locale","text":"Sopra ho usato str_to_lower() per cambiare il testo minuscolo. Puoi anche usare str_to_upper() o str_to_title(). Tuttavia, cambiare le maiuscole è più complicato di quanto possa sembrare prima vista, perché lingue diverse hanno regole diverse per cambiare le maiuscole. Puoi scegliere quale insieme di regole usare specificando un locale:Il locale è specificato come codice di lingua ISO 639, che è un’abbreviazione di due o tre lettere. Se non conosci già il codice della tua lingua, Wikipedia ha una buona lista. Se lasciate vuoto il locale, verrà usato il locale corrente, come fornito dal vostro sistema operativo.Un’altra importante operazione che è influenzata dal locale è l’ordinamento. Le funzioni di base R order() e sort() ordinano le stringhe usando il locale corrente. Se volete un comportamento robusto su diversi computer, potreste voler usare str_sort() e str_order() che prendono un argomento aggiuntivo locale:","code":"\n# Il turco ha due \"i\": con e senza punto, e ha una regola diversa per la loro capitalizzazione:\nstr_to_upper(c(\"i\", \"ı\"))\n#> [1] \"I\" \"I\"\nstr_to_upper(c(\"i\", \"ı\"), locale = \"tr\")\n#> [1] \"İ\" \"I\"\nx <- c(\"apple\", \"eggplant\", \"banana\")\n\nstr_sort(x, locale = \"en\")  # English\n#> [1] \"apple\"    \"banana\"   \"eggplant\"\n\nstr_sort(x, locale = \"haw\") # Hawaiian\n#> [1] \"apple\"    \"eggplant\" \"banana\""},{"path":"stringhe.html","id":"esercizi-32","chapter":"14 Stringhe","heading":"14.2.5 Esercizi","text":"Nel codice che non usa stringr, vedrete spesso paste() e paste0().\nQual è la differenza tra le due funzioni? quale funzione di stringr sono\nsono equivalenti? che modo le funzioni differiscono nella gestione di\nNA?Nel codice che non usa stringr, vedrete spesso paste() e paste0().\nQual è la differenza tra le due funzioni? quale funzione di stringr sono\nsono equivalenti? che modo le funzioni differiscono nella gestione di\nNA?Con parole tue, descrivi la differenza tra gli argomenti sep e collapse     distr_c()`.Con parole tue, descrivi la differenza tra gli argomenti sep e collapse     distr_c()`.Usate str_length() e str_sub() per estrarre il carattere centrale da\nuna stringa. Cosa farete se la stringa ha un numero pari di caratteri?Usate str_length() e str_sub() per estrarre il carattere centrale da\nuna stringa. Cosa farete se la stringa ha un numero pari di caratteri?Cosa fa str_wrap()? Quando potreste volerlo usare?Cosa fa str_wrap()? Quando potreste volerlo usare?Cosa fa str_trim()? Qual è l’opposto di str_trim()?Cosa fa str_trim()? Qual è l’opposto di str_trim()?Scrivi una funzione che trasformi (per esempio) un vettore c(\"\", \"b\", \"c\") \nla stringa `, b, e c``. Pensa attentamente cosa dovrebbe fare se\ndato un vettore di lunghezza 0, 1, o 2.Scrivi una funzione che trasformi (per esempio) un vettore c(\"\", \"b\", \"c\") \nla stringa `, b, e c``. Pensa attentamente cosa dovrebbe fare se\ndato un vettore di lunghezza 0, 1, o 2.","code":""},{"path":"stringhe.html","id":"corrispondenza-di-schemi-con-le-espressioni-regolari","chapter":"14 Stringhe","heading":"14.3 Corrispondenza di schemi con le espressioni regolari","text":"Le espressioni regolari sono un linguaggio molto conciso che permette di descrivere schemi nelle stringhe. Ci vuole un po’ di tempo per capirle, ma una volta che le avete capite, le troverete estremamente utili.Per imparare le espressioni regolari, useremo str_view() e str_view_all(). Queste funzioni prendono un vettore di caratteri e un’espressione regolare, e vi mostrano come corrispondono. Inizieremo con espressioni regolari molto semplici e poi gradualmente diventeremo sempre più complicati. Una volta che hai imparato la corrispondenza dei pattern, imparerai come applicare queste idee con varie funzioni di stringr.","code":""},{"path":"stringhe.html","id":"corrispondenze-di-base","chapter":"14 Stringhe","heading":"14.3.1 Corrispondenze di base","text":"pattern più semplici corrispondono stringhe esatte:Il passo successivo termini di complessità è ., che corrisponde qualsiasi carattere (eccetto un newline):“.” matches character, match character “.”? need use “escape” tell regular expression want match exactly, use special behaviour. Like strings, regexps use backslash, \\, escape special behaviour. match ., need regexp \\.. Unfortunately creates problem. use strings represent regular expressions, \\ also used escape symbol strings. create regular expression \\. need string \"\\\\.\". `Se \\ è usato come carattere di escape nelle espressioni regolari, come si fa far corrispondere un letterale \\? Beh, devi fare l’escape, creando l’espressione regolare \\\\. Per creare questa espressione regolare, hai bisogno di usare una stringa, che deve anche fare l’escape di \\. Questo significa che per far corrispondere un letterale \\ hai bisogno di scrivere \"\\\\\\\\\" — hai bisogno di quattro backslash per corrispondere uno!questo libro, scriverò l’espressione regolare come “\" e le stringhe che rappresentano l’espressione regolare come”\".","code":"\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_view(x, \"an\")\n#> [2] │ b<an><an>a\nstr_view(x, \".a.\")\n#> [2] │ <ban>ana\n#> [3] │ p<ear>\n# Per creare l'espressione regolare, abbiamo bisogno di \\\ndot <- \"\\\\.\"\n\n# Ma l'espressione stessa ne contiene solo uno:\nwriteLines(dot)\n#> \\.\n\n# E questo dice a R di cercare un esplicito .\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n#> [2] │ <a.c>\nx <- \"a\\\\b\"\nwriteLines(x)\n#> a\\b\n\nstr_view(x, \"\\\\\\\\\")\n#> [1] │ a<\\>b"},{"path":"stringhe.html","id":"esercizi-33","chapter":"14 Stringhe","heading":"14.3.1.1 Esercizi","text":"Spiega perché ognuna di queste stringhe non corrisponde un’espressione regolare: \\: \"\\\", \"\\\\\", \"\\\\\\\".Spiega perché ognuna di queste stringhe non corrisponde un’espressione regolare: \\: \"\\\", \"\\\\\", \"\\\\\\\".Come faresti far corrispondere la sequenza \"'\\?Come faresti far corrispondere la sequenza \"'\\?quali schemi corrisponderà l’espressione regolare \\..\\..\\.. ?\nCome la rappresenteresti come stringa?quali schemi corrisponderà l’espressione regolare \\..\\..\\.. ?\nCome la rappresenteresti come stringa?","code":""},{"path":"stringhe.html","id":"ancore","chapter":"14 Stringhe","heading":"14.3.2 Ancore","text":"Per default, le espressioni regolari corrispondono qualsiasi parte di una stringa. E’ spesso utile ancorare l’espressione regolare modo che corrisponda ’inizio o alla fine della stringa. Puoi usare:^ per far corrispondere l’inizio della stringa.$ per corrispondere alla fine della stringa.Per ricordare quale sia, provate questo mnemonico che ho imparato da Evan Misshula: se iniziate con power (^), finite con money ($).Per forzare un’espressione regolare corrispondere solo ad una stringa completa, ancorala con entrambi ^ e $:Potete anche abbinare il confine tra le parole con \\b. Non lo uso spesso R, ma volte lo uso quando faccio una ricerca RStudio quando voglio trovare il nome di una funzione che è un componente di altre funzioni. Per esempio, cercherò \\bsum\\b per evitare di abbinare summarise, summary, rowsum e così via.","code":"\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_view(x, \"^a\")\n#> [1] │ <a>pple\nstr_view(x, \"a$\")\n#> [2] │ banan<a>\nx <- c(\"apple pie\", \"apple\", \"apple cake\")\nstr_view(x, \"apple\")\n#> [1] │ <apple> pie\n#> [2] │ <apple>\n#> [3] │ <apple> cake\nstr_view(x, \"^apple$\")\n#> [2] │ <apple>"},{"path":"stringhe.html","id":"esercizi-34","chapter":"14 Stringhe","heading":"14.3.2.1 Esercizi","text":"Come faresti ad abbinare la stringa letterale \"$^$\"?Come faresti ad abbinare la stringa letterale \"$^$\"?Dato il corpus di parole comuni stringr::words, create espressioni regolari\nespressioni regolari che trovino tutte le parole che:\nInizia con “y”.\nFinisce con “x”.\nSono esattamente tre lettere. (Non barare usando str_length()!)\nHanno sette o più lettere.\nPoiché questa lista è lunga, potresti voler usare l’argomento match \nstr_view() per mostrare solo le parole corrispondenti o non corrispondenti.Dato il corpus di parole comuni stringr::words, create espressioni regolari\nespressioni regolari che trovino tutte le parole che:Inizia con “y”.Finisce con “x”.Sono esattamente tre lettere. (Non barare usando str_length()!)Hanno sette o più lettere.Poiché questa lista è lunga, potresti voler usare l’argomento match \nstr_view() per mostrare solo le parole corrispondenti o non corrispondenti.","code":""},{"path":"stringhe.html","id":"classi-di-caratteri-e-alternative","chapter":"14 Stringhe","heading":"14.3.3 Classi di caratteri e alternative","text":"Ci sono un certo numero di modelli speciali che corrispondono più di un carattere. Hai già visto ., che corrisponde qualsiasi carattere parte un newline. Ci sono altri quattro utili strumenti:\\d: corrisponde qualsiasi cifra.\\s: corrisponde qualsiasi spazio bianco (es. spazio, tabulazione, newline).[abc]: corrisponde ad , b, o c.[^abc]: corrisponde qualsiasi cosa tranne , b, o c.Ricorda, per creare un’espressione regolare che contenga \\d o \\s, dovrai fare l’escape del \\d per la stringa, quindi digiterai \"\\\\d\" o \"\\\\s\".Una classe di caratteri contenente un singolo carattere è una buona alternativa alle escape di backslash quando vuoi includere un singolo metacarattere una regex. Molte persone lo trovano più leggibile.Questo funziona per la maggior parte (ma non per tutti) metacaratteri regex: $ . | ? * + ( ) [ {. Sfortunatamente, alcuni caratteri hanno un significato speciale anche ’interno di una classe di caratteri e devono essere gestiti con escape di backslash: ] \\ ^ e -.Puoi usare alternation per scegliere tra uno o più schemi alternativi. Per esempio, abc|d..f corrisponderà sia ‘“abc”’, sia \"deaf\". Nota che la precedenza per | è bassa, così che abc|xyz`` corrisponde aabcoxyz, non aabcyzoabxyz`. Come con le espressioni matematiche, se la precedenza dovesse confondere, usate le parentesi per rendere chiaro ciò che volete:","code":"\n# Cerca un carattere letterale che normalmente ha un significato speciale in una regex\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[.]c\")\n#> [2] │ <a.c>\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \".[*]c\")\n#> [3] │ <a*c>\nstr_view(c(\"abc\", \"a.c\", \"a*c\", \"a c\"), \"a[ ]\")\n#> [4] │ <a >c\nstr_view(c(\"grey\", \"gray\"), \"gr(e|a)y\")\n#> [1] │ <grey>\n#> [2] │ <gray>"},{"path":"stringhe.html","id":"esercizi-35","chapter":"14 Stringhe","heading":"14.3.3.1 Esercizi","text":"Creare espressioni regolari per trovare tutte le parole che:\nInizia con una vocale.\nChe contengono solo consonanti. (Suggerimento: pensare di abbinare\n“non” vocali).\n\nFiniscono con ed, ma non con eed.\nTermina con ing o ise.\nCreare espressioni regolari per trovare tutte le parole che:Inizia con una vocale.Inizia con una vocale.Che contengono solo consonanti. (Suggerimento: pensare di abbinare\n“non” vocali).\nChe contengono solo consonanti. (Suggerimento: pensare di abbinare\n“non” vocali).Finiscono con ed, ma non con eed.Finiscono con ed, ma non con eed.Termina con ing o ise.Termina con ing o ise.Verificare empiricamente la regola “prima di e tranne dopo c”.Verificare empiricamente la regola “prima di e tranne dopo c”.La “q” è sempre seguita da una “u”?La “q” è sempre seguita da una “u”?Scrivi un’espressione regolare che corrisponda ad una parola se è probabilmente scritta\ninglese britannico e non inglese americano.Scrivi un’espressione regolare che corrisponda ad una parola se è probabilmente scritta\ninglese britannico e non inglese americano.Crea un’espressione regolare che corrisponda ai numeri di telefono come comunemente\nscritto nel tuo paese.Crea un’espressione regolare che corrisponda ai numeri di telefono come comunemente\nscritto nel tuo paese.","code":""},{"path":"stringhe.html","id":"ripetizione","chapter":"14 Stringhe","heading":"14.3.4 Ripetizione","text":"Il prossimo passo termini di potenza coinvolge il controllo di quante volte un pattern corrisponde:?: 0 o 1+: 1 o più*: 0 o piùNotate che la precedenza di questi operatori è alta, quindi potete scrivere: colou?r per abbinare sia l’ortografia americana che quella britannica. Ciò significa che la maggior parte degli usi avrà bisogno di parentesi, come bana(na)+.Puoi anche specificare il numero di corrispondenze modo preciso:{n}: esattamente n{n,}: n o più{,m}: al massimo m{n,m}: tra n e mPer default queste corrispondenze sono “avide”: corrisponderanno alla stringa più lunga possibile. Potete renderle “pigre”, facendo corrispondere la stringa più corta possibile mettendo un ? dopo di esse. Questa è una caratteristica avanzata delle espressioni regolari, ma è utile sapere che esiste:","code":"\nx <- \"1888 è l'anno più lungo in numeri romani: MDCCCLXXXVIII\"\nstr_view(x, \"CC?\")\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CC><C>LXXXVIII\nstr_view(x, \"CC+\")\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CCC>LXXXVIII\nstr_view(x, 'C[LX]+')\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MDCC<CLXXX>VIII\nstr_view(x, \"C{2}\")\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CC>CLXXXVIII\nstr_view(x, \"C{2,}\")\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CCC>LXXXVIII\nstr_view(x, \"C{2,3}\")\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CCC>LXXXVIII\nstr_view(x, 'C{2,3}?')\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MD<CC>CLXXXVIII\nstr_view(x, 'C[LX]+?')\n#> [1] │ 1888 è l'anno più lungo in numeri romani: MDCC<CL>XXXVIII"},{"path":"stringhe.html","id":"esercizi-36","chapter":"14 Stringhe","heading":"14.3.4.1 Esercizi","text":"Descrivi gli equivalenti di ?, +, * forma {m,n}.Descrivi gli equivalenti di ?, +, * forma {m,n}.Descrivi parole cosa corrispondono queste espressioni regolari:\n(leggi attentamente per vedere se sto usando un’espressione regolare o una stringa che definisce un’espressione regolare).\nche definisce un’espressione regolare).\n^.*$\n\"\\\\{.+\\\\}\"\n“4” - “2” - “2\n\n\"\\\\\\\\{4}\"\nDescrivi parole cosa corrispondono queste espressioni regolari:\n(leggi attentamente per vedere se sto usando un’espressione regolare o una stringa che definisce un’espressione regolare).\nche definisce un’espressione regolare).^.*$\"\\\\{.+\\\\}\"“4” - “2” - “2\n“4” - “2” - “2\"\\\\\\\\{4}\"Creare espressioni regolari per trovare tutte le parole che:\nIniziano con tre consonanti.\nHanno tre o più vocali fila.\n\nAvere due o più coppie vocale-consonante fila.\nCreare espressioni regolari per trovare tutte le parole che:Iniziano con tre consonanti.Hanno tre o più vocali fila.\nHanno tre o più vocali fila.Avere due o più coppie vocale-consonante fila.Risolvi cruciverba regexp per principianti su\nhttps://regexcrossword.com/challenges/beginner.Risolvi cruciverba regexp per principianti su\nhttps://regexcrossword.com/challenges/beginner.","code":""},{"path":"stringhe.html","id":"raggruppamento-e-backreferences","chapter":"14 Stringhe","heading":"14.3.5 Raggruppamento e backreferences","text":"Prima hai imparato conoscere le parentesi come un modo per disambiguare espressioni complesse. Le parentesi creano anche un gruppo di cattura numerato (numero 1, 2 ecc.). Un gruppo di cattura memorizza la parte di stringa cui corrisponde la parte dell’espressione regolare ’interno delle parentesi. Si può fare riferimento allo stesso testo precedentemente trovato da un gruppo di cattura con backreferences, come 1`,2`` ecc. Per esempio, la seguente espressione regolare trova tutti frutti che hanno una coppia di lettere ripetute.(breve, vedrete anche come sono utili insieme str_match().)","code":"\nstr_view(fruit, \"(..)\\\\1\", match = TRUE)\n#>  [4] │ b<anan>a\n#> [20] │ <coco>nut\n#> [22] │ <cucu>mber\n#> [41] │ <juju>be\n#> [56] │ <papa>ya\n#> [73] │ s<alal> berry"},{"path":"stringhe.html","id":"esercizi-37","chapter":"14 Stringhe","heading":"14.3.5.1 Esercizi","text":"Descrivete, parole, cosa corrispondono queste espressioni:\n(.)\\1\\1\n\"(.)(.)\\\\2\\\\1\"\n(..)\\1\n\"(.).\\\\1.\\\\1\"\n\"(.)(.)(.).*\\\\3\\\\2\\\\1\"\nDescrivete, parole, cosa corrispondono queste espressioni:(.)\\1\\1\"(.)(.)\\\\2\\\\1\"(..)\\1\"(.).\\\\1.\\\\1\"\"(.)(.)(.).*\\\\3\\\\2\\\\1\"Costruire espressioni regolari per far corrispondere parole che:\nIniziano e finiscono con lo stesso carattere.\nContengono una coppia di lettere ripetute\n(es. “church” contiene “ch” ripetuto due volte).\n\nContiene una lettera ripetuta almeno tre punti\n(es. “eleven” contiene tre “e”).\nCostruire espressioni regolari per far corrispondere parole che:Iniziano e finiscono con lo stesso carattere.Iniziano e finiscono con lo stesso carattere.Contengono una coppia di lettere ripetute\n(es. “church” contiene “ch” ripetuto due volte).\nContengono una coppia di lettere ripetute\n(es. “church” contiene “ch” ripetuto due volte).Contiene una lettera ripetuta almeno tre punti\n(es. “eleven” contiene tre “e”).Contiene una lettera ripetuta almeno tre punti\n(es. “eleven” contiene tre “e”).","code":""},{"path":"stringhe.html","id":"strumenti","chapter":"14 Stringhe","heading":"14.4 Strumenti","text":"Ora che avete imparato le basi delle espressioni regolari, è il momento di imparare come applicarle ai problemi reali. questa sezione imparerete una vasta gamma di funzioni di stringr che vi permettono di:Determinare quali stringhe corrispondono ad uno schema.Trovare le posizioni delle corrispondenze.Estrarre il contenuto delle corrispondenze.Sostituire le corrispondenze con nuovi valori.Dividere una stringa sulla base di una corrispondenza.Una parola di cautela prima di continuare: poiché le espressioni regolari sono così potenti, è facile provare risolvere ogni problema con una singola espressione regolare. Nelle parole di Jamie Zawinski:Alcune persone, di fronte ad un problema pensano: “Lo , userò le espressioni regolari”. Ora hanno due problemi.Come racconto ammonitore, guardate questa espressione regolare che controlla se un indirizzo email è valido:Questo è un esempio un po’ patologico (perché gli indirizzi e-mail sono realtà sorprendentemente complessi), ma è usato nel codice reale. Vedi la discussione su stackoverflow http://stackoverflow.com//201378 per maggiori dettagli.Non dimenticate che siete un linguaggio di programmazione e avete altri strumenti vostra disposizione. Invece di creare un’espressione regolare complessa, spesso è più facile scrivere una serie di regexp più semplici. Se vi bloccate cercando di creare una singola espressione regolare che risolva il vostro problema, fate un passo indietro e pensate se potete suddividere il problema pezzi più piccoli, risolvendo ogni sfida prima di passare quella successiva.","code":"(?:(?:\\r\\n)?[ \\t])*(?:(?:(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t]\n)+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\n\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(\n?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \n\\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\0\n31]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\\n](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+\n(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:\n(?:\\r\\n)?[ \\t])*))*|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z\n|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)\n?[ \\t])*)*\\<(?:(?:\\r\\n)?[ \\t])*(?:@(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\\nr\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[\n \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)\n?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t]\n)*))*(?:,@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[\n \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*\n)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t]\n)+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)\n*:(?:(?:\\r\\n)?[ \\t])*)?(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+\n|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\n\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\n\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t\n]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031\n]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](\n?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?\n:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?\n:\\r\\n)?[ \\t])*))*\\>(?:(?:\\r\\n)?[ \\t])*)|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?\n:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?\n[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*:(?:(?:\\r\\n)?[ \\t])*(?:(?:(?:[^()<>@,;:\\\\\".\\[\\] \n\\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\n\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>\n@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"\n(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t]\n)*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?\n:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\n\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*|(?:[^()<>@,;:\\\\\".\\[\\] \\000-\n\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(\n?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*\\<(?:(?:\\r\\n)?[ \\t])*(?:@(?:[^()<>@,;\n:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([\n^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\"\n.\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\\n]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*(?:,@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\\n[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\\nr\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \n\\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]\n|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)*:(?:(?:\\r\\n)?[ \\t])*)?(?:[^()<>@,;:\\\\\".\\[\\] \\0\n00-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\\n.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,\n;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?\n:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*))*@(?:(?:\\r\\n)?[ \\t])*\n(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\n\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t])*(?:[\n^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]\n]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*\\>(?:(?:\\r\\n)?[ \\t])*)(?:,\\s*(\n?:(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(\n?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\n\\[\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t\n])*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t\n])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?\n:\\.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\n\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*|(?:\n[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\\n]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)*\\<(?:(?:\\r\\n)\n?[ \\t])*(?:@(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"\n()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)\n?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>\n@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*(?:,@(?:(?:\\r\\n)?[\n \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,\n;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\\r\\n)?[ \\t]\n)*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\n\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*)*:(?:(?:\\r\\n)?[ \\t])*)?\n(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\n\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])*)(?:\\.(?:(?:\n\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z|(?=[\\[\n\"()<>@,;:\\\\\".\\[\\]]))|\"(?:[^\\\"\\r\\\\]|\\\\.|(?:(?:\\r\\n)?[ \\t]))*\"(?:(?:\\r\\n)?[ \\t])\n*))*@(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])\n+|\\Z|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*)(?:\\\n.(?:(?:\\r\\n)?[ \\t])*(?:[^()<>@,;:\\\\\".\\[\\] \\000-\\031]+(?:(?:(?:\\r\\n)?[ \\t])+|\\Z\n|(?=[\\[\"()<>@,;:\\\\\".\\[\\]]))|\\[([^\\[\\]\\r\\\\]|\\\\.)*\\](?:(?:\\r\\n)?[ \\t])*))*\\>(?:(\n?:\\r\\n)?[ \\t])*))*)?;\\s*)"},{"path":"stringhe.html","id":"rilevare-le-corrispondenze","chapter":"14 Stringhe","heading":"14.4.1 Rilevare le corrispondenze","text":"Per determinare se un vettore di caratteri corrisponde ad un pattern, usate str_detect(). Restituisce un vettore logico della stessa lunghezza dell’input:Ricordate che quando usate un vettore logico un contesto numerico, FALSE diventa 0 e TRUE diventa 1. Questo rende sum() e mean() utili se volete rispondere domande sulle corrispondenze un vettore più grande:Quando si hanno condizioni logiche complesse (ad es. corrisponde o b ma non c meno che d) è spesso più facile combinare più chiamate str_detect() con operatori logici, piuttosto che cercare di creare una singola espressione regolare. Per esempio, ecco due modi per trovare tutte le parole che non contengono alcuna vocale:risultati sono identici, ma penso che il primo approccio sia significativamente più facile da capire. Se la vostra espressione regolare diventa troppo complicata, provate scomporla pezzi più piccoli, dando ad ogni pezzo un nome, e poi combinando pezzi con operazioni logiche.Un uso comune di str_detect() è quello di selezionare gli elementi che corrispondono ad un pattern. Potete farlo con il sottoinsieme logico o con il comodo wrapper str_subset():Tipicamente, però, le vostre stringhe saranno una colonna di un frame di dati, e vorrete invece usare filter:Una variazione di str_detect() è str_count(): piuttosto che un semplice sì o , vi dice quante corrispondenze ci sono una stringa:È naturale usare str_count() con mutate():Notate che le corrispondenze non si sovrappongono mai. Per esempio, \"abababa\", quante volte corrisponderà il pattern \"aba\"? Le espressioni regolari dicono due, non tre:Notate l’uso di str_view_all(). Come imparerete breve, molte funzioni di stringr sono coppia: una funzione lavora con una singola corrispondenza, e l’altra lavora con tutte le corrispondenze. La seconda funzione avrà il suffisso _all.","code":"\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_detect(x, \"e\")\n#> [1]  TRUE FALSE  TRUE\n# Quante parole comuni iniziano con la t?\nsum(str_detect(words, \"^t\"))\n#> [1] 65\n# Quale proporzione di parole comuni finisce con una vocale?\nmean(str_detect(words, \"[aeiou]$\"))\n#> [1] 0.2765306\n# Trova tutte le parole che contengono almeno una vocale e nega\nno_vowels_1 <- !str_detect(words, \"[aeiou]\")\n# Trova tutte le parole composte solo da consonanti (non vocali)\nno_vowels_2 <- str_detect(words, \"^[^aeiou]+$\")\nidentical(no_vowels_1, no_vowels_2)\n#> [1] TRUE\nwords[str_detect(words, \"x$\")]\n#> [1] \"box\" \"sex\" \"six\" \"tax\"\nstr_subset(words, \"x$\")\n#> [1] \"box\" \"sex\" \"six\" \"tax\"\ndf <- tibble(\n  word = words, \n  i = seq_along(word)\n)\ndf %>% \n  filter(str_detect(word, \"x$\"))\n#> # A tibble: 4 × 2\n#>   word      i\n#>   <chr> <int>\n#> 1 box     108\n#> 2 sex     747\n#> 3 six     772\n#> 4 tax     841\nx <- c(\"apple\", \"banana\", \"pear\")\nstr_count(x, \"a\")\n#> [1] 1 3 1\n\n# In media, quante vocali per parola?\nmean(str_count(words, \"[aeiou]\"))\n#> [1] 1.991837\ndf %>% \n  mutate(\n    vowels = str_count(word, \"[aeiou]\"),\n    consonants = str_count(word, \"[^aeiou]\")\n  )\n#> # A tibble: 980 × 4\n#>   word         i vowels consonants\n#>   <chr>    <int>  <int>      <int>\n#> 1 a            1      1          0\n#> 2 able         2      2          2\n#> 3 about        3      3          2\n#> 4 absolute     4      4          4\n#> 5 accept       5      2          4\n#> 6 account      6      3          4\n#> # … with 974 more rows\nstr_count(\"abababa\", \"aba\")\n#> [1] 2\nstr_view_all(\"abababa\", \"aba\")\n#> Warning: `str_view()` was deprecated in stringr 1.5.0.\n#> ℹ Please use `str_view_all()` instead.\n#> [1] │ <aba>b<aba>"},{"path":"stringhe.html","id":"esercizi-38","chapter":"14 Stringhe","heading":"14.4.1.1 Esercizi","text":"Per ciascuna delle seguenti sfide, prova risolverla usando sia una singola\nespressione regolare che una combinazione di chiamate multiple str_detect().\nTrova tutte le parole che iniziano o finiscono con x.\nTrova tutte le parole che iniziano con una vocale e finiscono con una consonante.\nCi sono parole che contengono almeno una di ogni diversa\nvocale?\nPer ciascuna delle seguenti sfide, prova risolverla usando sia una singola\nespressione regolare che una combinazione di chiamate multiple str_detect().Trova tutte le parole che iniziano o finiscono con x.Trova tutte le parole che iniziano o finiscono con x.Trova tutte le parole che iniziano con una vocale e finiscono con una consonante.Trova tutte le parole che iniziano con una vocale e finiscono con una consonante.Ci sono parole che contengono almeno una di ogni diversa\nvocale?Ci sono parole che contengono almeno una di ogni diversa\nvocale?Quale parola ha il maggior numero di vocali? Quale parola ha la più alta\nproporzione di vocali? (Suggerimento: qual è il denominatore?)Quale parola ha il maggior numero di vocali? Quale parola ha la più alta\nproporzione di vocali? (Suggerimento: qual è il denominatore?)","code":""},{"path":"stringhe.html","id":"estrarre-le-corrispondenze","chapter":"14 Stringhe","heading":"14.4.2 Estrarre le corrispondenze","text":"Per estrarre il testo effettivo di una corrispondenza, usa str_extract(). Per mostrarlo, avremo bisogno di un esempio più complicato. Userò le frasi di Harvard, che sono state progettate per testare sistemi VOIP, ma sono anche utili per fare pratica con le regexp. Queste sono fornite stringr::sentences:Immaginiamo di voler trovare tutte le frasi che contengono un colore. Creiamo prima un vettore di nomi di colori e poi lo trasformiamo un’unica espressione regolare:Ora possiamo selezionare le frasi che contengono un colore, e poi estrarre il colore per capire qual è:Notate che str_extract() estrae solo la prima corrispondenza. Possiamo vederlo più facilmente selezionando prima tutte le frasi che hanno più di 1 corrispondenza:Questo è uno schema comune per le funzioni di stringr, perché lavorare con una singola corrispondenza vi permette di usare strutture dati molto più semplici. Per ottenere tutte le corrispondenze, usate str_extract_all(). Restituisce una lista:Imparerai di più sulle liste liste e iterazioni.Se usate simplify = TRUE, str_extract_all() restituirà una matrice con le corrispondenze brevi espanse alla stessa lunghezza della più lunga:","code":"\nlength(sentences)\n#> [1] 720\nhead(sentences)\n#> [1] \"The birch canoe slid on the smooth planks.\" \n#> [2] \"Glue the sheet to the dark blue background.\"\n#> [3] \"It's easy to tell the depth of a well.\"     \n#> [4] \"These days a chicken leg is a rare dish.\"   \n#> [5] \"Rice is often served in round bowls.\"       \n#> [6] \"The juice of lemons makes fine punch.\"\ncolours <- c(\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\")\ncolour_match <- str_c(colours, collapse = \"|\")\ncolour_match\n#> [1] \"red|orange|yellow|green|blue|purple\"\nhas_colour <- str_subset(sentences, colour_match)\nmatches <- str_extract(has_colour, colour_match)\nhead(matches)\n#> [1] \"blue\" \"blue\" \"red\"  \"red\"  \"red\"  \"blue\"\nmore <- sentences[str_count(sentences, colour_match) > 1]\nstr_view_all(more, colour_match)\n#> [1] │ It is hard to erase <blue> or <red> ink.\n#> [2] │ The <green> light in the brown box flicke<red>.\n#> [3] │ The sky in the west is tinged with <orange> <red>.\n\nstr_extract(more, colour_match)\n#> [1] \"blue\"   \"green\"  \"orange\"\nstr_extract_all(more, colour_match)\n#> [[1]]\n#> [1] \"blue\" \"red\" \n#> \n#> [[2]]\n#> [1] \"green\" \"red\"  \n#> \n#> [[3]]\n#> [1] \"orange\" \"red\"\nstr_extract_all(more, colour_match, simplify = TRUE)\n#>      [,1]     [,2] \n#> [1,] \"blue\"   \"red\"\n#> [2,] \"green\"  \"red\"\n#> [3,] \"orange\" \"red\"\n\nx <- c(\"a\", \"a b\", \"a b c\")\nstr_extract_all(x, \"[a-z]\", simplify = TRUE)\n#>      [,1] [,2] [,3]\n#> [1,] \"a\"  \"\"   \"\"  \n#> [2,] \"a\"  \"b\"  \"\"  \n#> [3,] \"a\"  \"b\"  \"c\""},{"path":"stringhe.html","id":"esercizi-39","chapter":"14 Stringhe","heading":"14.4.2.1 Esercizi","text":"Nell’esempio precedente, potreste aver notato che l’espressione regolare\ncorrispondeva “flickered”, che non è un colore. Modificate la\nregex per risolvere il problema.Nell’esempio precedente, potreste aver notato che l’espressione regolare\ncorrispondeva “flickered”, che non è un colore. Modificate la\nregex per risolvere il problema.Dai dati delle frasi di Harvard, estrai:\nLa prima parola di ogni frase.\nTutte le parole che finiscono ing.\nTutti plurali.\nDai dati delle frasi di Harvard, estrai:La prima parola di ogni frase.Tutte le parole che finiscono ing.Tutti plurali.","code":""},{"path":"stringhe.html","id":"corrispondenze-raggruppate","chapter":"14 Stringhe","heading":"14.4.3 Corrispondenze raggruppate","text":"’inizio di questo capitolo abbiamo parlato dell’uso delle parentesi per chiarire le precedenze e per rinvii durante la corrispondenza. Si possono anche usare le parentesi per estrarre parti di una corrispondenza complessa. Per esempio, immaginiamo di voler estrarre nomi dalle frasi. Come euristica, cercheremo qualsiasi parola che viene dopo “” o “”. Definire una “parola” un’espressione regolare è un po’ complicato, quindi qui uso una semplice approssimazione: una sequenza di almeno un carattere che non sia uno spazio.str_extract() ci dà la corrispondenza completa; str_match() dà ogni singolo componente. Invece di un vettore di caratteri, restituisce una matrice, con una colonna per la corrispondenza completa seguita da una colonna per ogni gruppo:(Non sorprende che la nostra euristica per individuare sostantivi sia povera, e che raccolga anche aggettivi come smooth e parked).Se vostri dati sono un tibble, è spesso più facile usare tidyr::extract(). Funziona come str_match() ma richiede di dare un nome alle corrispondenze, che vengono poi inserite nuove colonne:Come str_extract(), se volete tutte le corrispondenze per ogni stringa, avrete bisogno di str_match_all().","code":"\nnoun <- \"(a|the) ([^ ]+)\"\n\nhas_noun <- sentences %>%\n  str_subset(noun) %>%\n  head(10)\nhas_noun %>% \n  str_extract(noun)\n#>  [1] \"the smooth\" \"the sheet\"  \"the depth\"  \"a chicken\"  \"the parked\"\n#>  [6] \"the sun\"    \"the huge\"   \"the ball\"   \"the woman\"  \"a helps\"\nhas_noun %>% \n  str_match(noun)\n#>       [,1]         [,2]  [,3]     \n#>  [1,] \"the smooth\" \"the\" \"smooth\" \n#>  [2,] \"the sheet\"  \"the\" \"sheet\"  \n#>  [3,] \"the depth\"  \"the\" \"depth\"  \n#>  [4,] \"a chicken\"  \"a\"   \"chicken\"\n#>  [5,] \"the parked\" \"the\" \"parked\" \n#>  [6,] \"the sun\"    \"the\" \"sun\"    \n#>  [7,] \"the huge\"   \"the\" \"huge\"   \n#>  [8,] \"the ball\"   \"the\" \"ball\"   \n#>  [9,] \"the woman\"  \"the\" \"woman\"  \n#> [10,] \"a helps\"    \"a\"   \"helps\"\ntibble(sentence = sentences) %>% \n  tidyr::extract(\n    sentence, c(\"article\", \"noun\"), \"(a|the) ([^ ]+)\", \n    remove = FALSE\n  )\n#> # A tibble: 720 × 3\n#>   sentence                                    article noun   \n#>   <chr>                                       <chr>   <chr>  \n#> 1 The birch canoe slid on the smooth planks.  the     smooth \n#> 2 Glue the sheet to the dark blue background. the     sheet  \n#> 3 It's easy to tell the depth of a well.      the     depth  \n#> 4 These days a chicken leg is a rare dish.    a       chicken\n#> 5 Rice is often served in round bowls.        <NA>    <NA>   \n#> 6 The juice of lemons makes fine punch.       <NA>    <NA>   \n#> # … with 714 more rows"},{"path":"stringhe.html","id":"esercizi-40","chapter":"14 Stringhe","heading":"14.4.3.1 Esercizi","text":"Trova tutte le parole che vengono dopo un “numero” come “uno”, “due”, “tre” ecc. Estrai sia il numero che la parola.Trova tutte le parole che vengono dopo un “numero” come “uno”, “due”, “tre” ecc. Estrai sia il numero che la parola.Trova tutte le contrazioni. Separa pezzi prima e dopo l’apostrofo.Trova tutte le contrazioni. Separa pezzi prima e dopo l’apostrofo.","code":""},{"path":"stringhe.html","id":"sostituzione-delle-corrispondenze","chapter":"14 Stringhe","heading":"14.4.4 Sostituzione delle corrispondenze","text":"str_replace() e str_replace_all() vi permettono di sostituire le corrispondenze con nuove stringhe. L’uso più semplice è quello di sostituire un pattern con una stringa fissa:Con str_replace_all() potete eseguire sostituzioni multiple fornendo un vettore con nome:Invece di sostituire con una stringa fissa potete usare backreferences per inserire componenti della corrispondenza. Nel codice seguente, inverto l’ordine della seconda e della terza parola.","code":"\nx <- c(\"apple\", \"pear\", \"banana\")\nstr_replace(x, \"[aeiou]\", \"-\")\n#> [1] \"-pple\"  \"p-ar\"   \"b-nana\"\nstr_replace_all(x, \"[aeiou]\", \"-\")\n#> [1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\nx <- c(\"1 house\", \"2 cars\", \"3 people\")\nstr_replace_all(x, c(\"1\" = \"one\", \"2\" = \"two\", \"3\" = \"three\"))\n#> [1] \"one house\"    \"two cars\"     \"three people\"\nsentences %>% \n  str_replace(\"([^ ]+) ([^ ]+) ([^ ]+)\", \"\\\\1 \\\\3 \\\\2\") %>% \n  head(5)\n#> [1] \"The canoe birch slid on the smooth planks.\" \n#> [2] \"Glue sheet the to the dark blue background.\"\n#> [3] \"It's to easy tell the depth of a well.\"     \n#> [4] \"These a days chicken leg is a rare dish.\"   \n#> [5] \"Rice often is served in round bowls.\""},{"path":"stringhe.html","id":"esercizi-41","chapter":"14 Stringhe","heading":"14.4.4.1 Esercizi","text":"Sostituisci tutte le barre avanti una stringa con barre rovesciate.Sostituisci tutte le barre avanti una stringa con barre rovesciate.Implementare una semplice versione di str_to_lower() usando replace_all().Implementare una semplice versione di str_to_lower() usando replace_all().Cambiate la prima e l’ultima lettera words. Quali di queste stringhe sono ancora parole?Cambiate la prima e l’ultima lettera words. Quali di queste stringhe sono ancora parole?","code":""},{"path":"stringhe.html","id":"divisione","chapter":"14 Stringhe","heading":"14.4.5 Divisione","text":"Usa str_split() per dividere una stringa pezzi. Per esempio, possiamo dividere le frasi parole:Poiché ogni componente potrebbe contenere un numero diverso di pezzi, questo restituisce una lista. Se state lavorando con un vettore di lunghezza-1, la cosa più semplice è semplicemente estrarre il primo elemento della lista:Altrimenti, come le altre funzioni di stringr che restituiscono una lista, potete usare simplify = TRUE per restituire una matrice:Puoi anche richiedere un numero massimo di pezzi:Invece di dividere le stringhe per pattern, potete anche dividere per carattere, linea, frase e parola boundary():","code":"\nsentences %>%\n  head(5) %>% \n  str_split(\" \")\n#> [[1]]\n#> [1] \"The\"     \"birch\"   \"canoe\"   \"slid\"    \"on\"      \"the\"     \"smooth\" \n#> [8] \"planks.\"\n#> \n#> [[2]]\n#> [1] \"Glue\"        \"the\"         \"sheet\"       \"to\"          \"the\"        \n#> [6] \"dark\"        \"blue\"        \"background.\"\n#> \n#> [[3]]\n#> [1] \"It's\"  \"easy\"  \"to\"    \"tell\"  \"the\"   \"depth\" \"of\"    \"a\"     \"well.\"\n#> \n#> [[4]]\n#> [1] \"These\"   \"days\"    \"a\"       \"chicken\" \"leg\"     \"is\"      \"a\"      \n#> [8] \"rare\"    \"dish.\"  \n#> \n#> [[5]]\n#> [1] \"Rice\"   \"is\"     \"often\"  \"served\" \"in\"     \"round\"  \"bowls.\"\n\"a|b|c|d\" %>% \n  str_split(\"\\\\|\") %>% \n  .[[1]]\n#> [1] \"a\" \"b\" \"c\" \"d\"\nsentences %>%\n  head(5) %>% \n  str_split(\" \", simplify = TRUE)\n#>      [,1]    [,2]    [,3]    [,4]      [,5]  [,6]    [,7]     [,8]         \n#> [1,] \"The\"   \"birch\" \"canoe\" \"slid\"    \"on\"  \"the\"   \"smooth\" \"planks.\"    \n#> [2,] \"Glue\"  \"the\"   \"sheet\" \"to\"      \"the\" \"dark\"  \"blue\"   \"background.\"\n#> [3,] \"It's\"  \"easy\"  \"to\"    \"tell\"    \"the\" \"depth\" \"of\"     \"a\"          \n#> [4,] \"These\" \"days\"  \"a\"     \"chicken\" \"leg\" \"is\"    \"a\"      \"rare\"       \n#> [5,] \"Rice\"  \"is\"    \"often\" \"served\"  \"in\"  \"round\" \"bowls.\" \"\"           \n#>      [,9]   \n#> [1,] \"\"     \n#> [2,] \"\"     \n#> [3,] \"well.\"\n#> [4,] \"dish.\"\n#> [5,] \"\"\nfields <- c(\"Name: Hadley\", \"Country: NZ\", \"Age: 35\")\nfields %>% str_split(\": \", n = 2, simplify = TRUE)\n#>      [,1]      [,2]    \n#> [1,] \"Name\"    \"Hadley\"\n#> [2,] \"Country\" \"NZ\"    \n#> [3,] \"Age\"     \"35\"\nx <- \"This is a sentence.  This is another sentence.\"\nstr_view_all(x, boundary(\"word\"))\n#> [1] │ <This> <is> <a> <sentence>.  <This> <is> <another> <sentence>.\n\nstr_split(x, \" \")[[1]]\n#> [1] \"This\"      \"is\"        \"a\"         \"sentence.\" \"\"          \"This\"     \n#> [7] \"is\"        \"another\"   \"sentence.\"\nstr_split(x, boundary(\"word\"))[[1]]\n#> [1] \"This\"     \"is\"       \"a\"        \"sentence\" \"This\"     \"is\"       \"another\" \n#> [8] \"sentence\""},{"path":"stringhe.html","id":"esercizi-42","chapter":"14 Stringhe","heading":"14.4.5.1 Esercizi","text":"Dividete una stringa come “mele, pere e banane” singoli\ncomponenti.Dividete una stringa come “mele, pere e banane” singoli\ncomponenti.Perché è meglio dividere per limite(\"parola\") che per \"\"?Perché è meglio dividere per limite(\"parola\") che per \"\"?Cosa fa la divisione con una stringa vuota (\"\")? Sperimentate, e\npoi leggete la documentazione.Cosa fa la divisione con una stringa vuota (\"\")? Sperimentate, e\npoi leggete la documentazione.","code":""},{"path":"stringhe.html","id":"trova-le-corrispondenze","chapter":"14 Stringhe","heading":"14.4.6 Trova le corrispondenze","text":"str_locate() e str_locate_all() vi danno la posizione iniziale e finale di ogni corrispondenza. Queste sono particolarmente utili quando nessuna delle altre funzioni fa esattamente quello che vuoi. Puoi usare str_locate() per trovare il pattern corrispondente, str_sub() per estrarlo e/o modificarlo.","code":""},{"path":"stringhe.html","id":"altri-tipi-di-pattern","chapter":"14 Stringhe","heading":"14.5 Altri tipi di pattern","text":"Quando si usa un pattern che è una stringa, esso viene automaticamente avvolto una chiamata regex():Potete usare gli altri argomenti di regex() per controllare dettagli della corrispondenza:ignore_case = TRUE permette ai caratteri di corrispondere sia alla loro forma maiuscola che quella minuscola. Questo usa sempre il locale corrente.\n\nbananas <- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#> [1] │ <banana>\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#> [1] │ <banana>\n#> [2] │ <Banana>\n#> [3] │ <BANANA>ignore_case = TRUE permette ai caratteri di corrispondere sia alla loro forma maiuscola che quella minuscola. Questo usa sempre il locale corrente.multiline = TRUE permette ^ e $ di corrispondere ’inizio e alla fine di ogni linea piuttosto che ’inizio e alla fine della stringa completa.\n\nx <- \"Line 1\\nLine 2\\nLine 3\"\nstr_extract_all(x, \"^Line\")[[1]]\n#> [1] \"Line\"\nstr_extract_all(x, regex(\"^Line\", multiline = TRUE))[[1]]\n#> [1] \"Line\" \"Line\" \"Line\"multiline = TRUE permette ^ e $ di corrispondere ’inizio e alla fine di ogni linea piuttosto che ’inizio e alla fine della stringa completa.commenti = TRUE ti permette di usare commenti e spazi bianchi per rendere le espressioni regolari complesse più comprensibili. Gli spazi sono ignorati, così come tutto ciò che viene dopo #. Per far corrispondere uno spazio letterale, dovrai fare l’escape: \"\\\".\n\nphone <- regex(\"\n  \\\\(? # parentesi di apertura opzionale\n  (\\\\d{3}) # codice di zona\n  [) -]?   # parentesi di chiusura opzionale, spazio o trattino\n  (\\\\d{3}) # altri tre numeri\n  [ -]?    # spazio o trattino opzionale\n  (\\\\d{3}) # altri tre numeri\n  \", comments = TRUE)\n\nstr_match(\"514-791-8141\", phone)\n#>      [,1]          [,2]  [,3]  [,4] \n#> [1,] \"514-791-814\" \"514\" \"791\" \"814\"commenti = TRUE ti permette di usare commenti e spazi bianchi per rendere le espressioni regolari complesse più comprensibili. Gli spazi sono ignorati, così come tutto ciò che viene dopo #. Per far corrispondere uno spazio letterale, dovrai fare l’escape: \"\\\".dotall = TRUE permette . di corrispondere tutto, incluso \\n.dotall = TRUE permette . di corrispondere tutto, incluso \\n.Ci sono altre tre funzioni che puoi usare al posto di regex():fixed(): corrisponde esattamente alla sequenza di byte specificata. Ignora\ntutte le espressioni regolari speciali e opera ad un livello molto basso.\nQuesto permette di evitare complessi escaping e può essere molto più veloce delle\ndelle espressioni regolari. Il seguente microbenchmark mostra che è circa\n3 volte più veloce per un semplice esempio.\n\nmicrobenchmark::microbenchmark(\n  fixed = str_detect(sentences, fixed(\"\")),\n  regex = str_detect(sentences, \"\"),\n  times = 20\n)\n#> Unit: microseconds\n#>   expr   min     lq    mean median     uq   max neval\n#>  fixed  62.2  67.55 100.620  79.05  89.85 498.8    20\n#>  regex 273.4 280.35 296.135 285.35 289.95 489.5    20\nAttenzione ’uso di fixed() con dati non inglesi. È problematico perché ci sono spesso più modi di rappresentare lo stesso carattere. Per esempio, ci sono due modi per definire “á”: o come un singolo carattere o come una “” più un accento:\n\na1 <- \"\\u00e1\"\na2 <- \"\\u0301\"\nc(a1, a2)\n#> [1] \"á\" \"́\"\na1 == a2\n#> [1] FALSE\nEssi rendono modo identico, ma poiché sono definiti modo diverso, fixed() non trova una corrispondenza. Invece, puoi usare coll(), definito seguito, per rispettare le regole di confronto dei caratteri umani:\n\nstr_detect(a1, fixed(a2))\n#> [1] FALSE\nstr_detect(a1, coll(a2))\n#> [1] TRUEfixed(): corrisponde esattamente alla sequenza di byte specificata. Ignora\ntutte le espressioni regolari speciali e opera ad un livello molto basso.\nQuesto permette di evitare complessi escaping e può essere molto più veloce delle\ndelle espressioni regolari. Il seguente microbenchmark mostra che è circa\n3 volte più veloce per un semplice esempio.Attenzione ’uso di fixed() con dati non inglesi. È problematico perché ci sono spesso più modi di rappresentare lo stesso carattere. Per esempio, ci sono due modi per definire “á”: o come un singolo carattere o come una “” più un accento:Essi rendono modo identico, ma poiché sono definiti modo diverso, fixed() non trova una corrispondenza. Invece, puoi usare coll(), definito seguito, per rispettare le regole di confronto dei caratteri umani:coll(): confronta le stringhe usando le regole standard di collazione. Questo è utile per fare confronti insensibili alle maiuscole e alle minuscole. Si noti che coll() accetta un parametro locale che controlla quali regole sono usate per confrontare caratteri. Sfortunatamente le diverse parti del mondo usano regole diverse!\n\n# Questo significa che devi anche essere consapevole della differenza\n# quando si fanno corrispondenze insensibili alle maiuscole e alle minuscole:\n<- c(\"\", \"İ\", \"\", \"ı\")\n\n#> [1] \"\" \"İ\" \"\" \"ı\"\n\nstr_subset(, coll(\"\", ignore_case = TRUE))\n#> [1] \"\" \"\"\nstr_subset(, coll(\"\", ignore_case = TRUE, locale = \"tr\"))\n#> [1] \"İ\" \"\"\nSia fixed() che regex() hanno argomenti ignore_case, ma non vi permettono di scegliere il locale: usano sempre il locale di default. Potete vedere cos’è con il seguente codice; più avanti ci saranno altre stringhe.\n\nstringi::stri_locale_info()\n#> $Language\n#> [1] \"c\"\n#> \n#> $Country\n#> [1] \"\"\n#> \n#> $Variant\n#> [1] \"\"\n#> \n#> $Name\n#> [1] \"c\"\nLo svantaggio di coll() è la velocità; poiché le regole per riconoscere quali\ncaratteri sono uguali sono complicate, coll() è relativamente lento\nrispetto regex() e fixed().coll(): confronta le stringhe usando le regole standard di collazione. Questo è utile per fare confronti insensibili alle maiuscole e alle minuscole. Si noti che coll() accetta un parametro locale che controlla quali regole sono usate per confrontare caratteri. Sfortunatamente le diverse parti del mondo usano regole diverse!Sia fixed() che regex() hanno argomenti ignore_case, ma non vi permettono di scegliere il locale: usano sempre il locale di default. Potete vedere cos’è con il seguente codice; più avanti ci saranno altre stringhe.Lo svantaggio di coll() è la velocità; poiché le regole per riconoscere quali\ncaratteri sono uguali sono complicate, coll() è relativamente lento\nrispetto regex() e fixed().Come avete visto con str_split() potete usare boundary() per abbinare confini.\nPotete anche usarla con le altre funzioni:\n\nx <- \"sentence.\"\nstr_view_all(x, boundary(\"word\"))\n#> [1] │ <> <> <> <sentence>.\nstr_extract_all(x, boundary(\"word\"))\n#> [[1]]\n#> [1] \"\"     \"\"       \"\"        \"sentence\"Come avete visto con str_split() potete usare boundary() per abbinare confini.\nPotete anche usarla con le altre funzioni:","code":"\n# La chiamata regolare:\nstr_view(fruit, \"nana\")\n# È l'abbreviazione di\nstr_view(fruit, regex(\"nana\"))\nbananas <- c(\"banana\", \"Banana\", \"BANANA\")\nstr_view(bananas, \"banana\")\n#> [1] │ <banana>\nstr_view(bananas, regex(\"banana\", ignore_case = TRUE))\n#> [1] │ <banana>\n#> [2] │ <Banana>\n#> [3] │ <BANANA>\nx <- \"Line 1\\nLine 2\\nLine 3\"\nstr_extract_all(x, \"^Line\")[[1]]\n#> [1] \"Line\"\nstr_extract_all(x, regex(\"^Line\", multiline = TRUE))[[1]]\n#> [1] \"Line\" \"Line\" \"Line\"\nphone <- regex(\"\n  \\\\(? # parentesi di apertura opzionale\n  (\\\\d{3}) # codice di zona\n  [) -]?   # parentesi di chiusura opzionale, spazio o trattino\n  (\\\\d{3}) # altri tre numeri\n  [ -]?    # spazio o trattino opzionale\n  (\\\\d{3}) # altri tre numeri\n  \", comments = TRUE)\n\nstr_match(\"514-791-8141\", phone)\n#>      [,1]          [,2]  [,3]  [,4] \n#> [1,] \"514-791-814\" \"514\" \"791\" \"814\"\nmicrobenchmark::microbenchmark(\n  fixed = str_detect(sentences, fixed(\"the\")),\n  regex = str_detect(sentences, \"the\"),\n  times = 20\n)\n#> Unit: microseconds\n#>   expr   min     lq    mean median     uq   max neval\n#>  fixed  62.2  67.55 100.620  79.05  89.85 498.8    20\n#>  regex 273.4 280.35 296.135 285.35 289.95 489.5    20\na1 <- \"\\u00e1\"\na2 <- \"a\\u0301\"\nc(a1, a2)\n#> [1] \"á\" \"á\"\na1 == a2\n#> [1] FALSE\nstr_detect(a1, fixed(a2))\n#> [1] FALSE\nstr_detect(a1, coll(a2))\n#> [1] TRUE\n# Questo significa che devi anche essere consapevole della differenza\n# quando si fanno corrispondenze insensibili alle maiuscole e alle minuscole:\ni <- c(\"I\", \"İ\", \"i\", \"ı\")\ni\n#> [1] \"I\" \"İ\" \"i\" \"ı\"\n\nstr_subset(i, coll(\"i\", ignore_case = TRUE))\n#> [1] \"I\" \"i\"\nstr_subset(i, coll(\"i\", ignore_case = TRUE, locale = \"tr\"))\n#> [1] \"İ\" \"i\"\nstringi::stri_locale_info()\n#> $Language\n#> [1] \"c\"\n#> \n#> $Country\n#> [1] \"\"\n#> \n#> $Variant\n#> [1] \"\"\n#> \n#> $Name\n#> [1] \"c\"\nx <- \"This is a sentence.\"\nstr_view_all(x, boundary(\"word\"))\n#> [1] │ <This> <is> <a> <sentence>.\nstr_extract_all(x, boundary(\"word\"))\n#> [[1]]\n#> [1] \"This\"     \"is\"       \"a\"        \"sentence\""},{"path":"stringhe.html","id":"esercizi-43","chapter":"14 Stringhe","heading":"14.5.1 Esercizi","text":"Come trovereste tutte le stringhe che contengono “regex” con “regex()vs.     confixed()`?Come trovereste tutte le stringhe che contengono “regex” con “regex()vs.     confixed()`?Quali sono le cinque parole più comuni nelle sentenze?\nQuali sono le cinque parole più comuni nelle sentenze?","code":""},{"path":"stringhe.html","id":"altri-usi-delle-espressioni-regolari","chapter":"14 Stringhe","heading":"14.6 Altri usi delle espressioni regolari","text":"Ci sono due utili funzioni R base che usano anche le espressioni regolari:apropos() cerca tutti gli oggetti disponibili nell’ambiente globale. Questo\nè utile se non riuscite ricordare il nome della funzione.\n\napropos(\"replace\")\n#> [1] \"%+replace%\"       \"replace\"          \"replace_na\"       \"setReplaceMethod\"\n#> [5] \"str_replace\"      \"str_replace_all\"  \"str_replace_na\"   \"theme_replace\"apropos() cerca tutti gli oggetti disponibili nell’ambiente globale. Questo\nè utile se non riuscite ricordare il nome della funzione.dir() elenca tutti file una directory. L’argomento pattern prende\nun’espressione regolare e restituisce solo nomi dei file che corrispondono allo schema.\nPer esempio, si possono trovare tutti file R Markdown nella directory corrente\ncon:\n\nhead(dir(pattern = \"\\\\.Rmd$\"))\n#> [1] \"communicate-plots.Rmd\" \"communicate.Rmd\"       \"datetimes.Rmd\"        \n#> [4] \"EDA.Rmd\"               \"explore.Rmd\"           \"factors.Rmd\"\n(Se siete più vostro agio con “globi” come *.Rmd, potete convertirli\nespressioni regolari con glob2rx()):dir() elenca tutti file una directory. L’argomento pattern prende\nun’espressione regolare e restituisce solo nomi dei file che corrispondono allo schema.\nPer esempio, si possono trovare tutti file R Markdown nella directory corrente\ncon:(Se siete più vostro agio con “globi” come *.Rmd, potete convertirli\nespressioni regolari con glob2rx()):","code":"\napropos(\"replace\")\n#> [1] \"%+replace%\"       \"replace\"          \"replace_na\"       \"setReplaceMethod\"\n#> [5] \"str_replace\"      \"str_replace_all\"  \"str_replace_na\"   \"theme_replace\"\nhead(dir(pattern = \"\\\\.Rmd$\"))\n#> [1] \"communicate-plots.Rmd\" \"communicate.Rmd\"       \"datetimes.Rmd\"        \n#> [4] \"EDA.Rmd\"               \"explore.Rmd\"           \"factors.Rmd\""},{"path":"stringhe.html","id":"stringi","chapter":"14 Stringhe","heading":"14.7 stringi","text":"stringr è costruito sopra il pacchetto stringi. stringr è utile quando si sta imparando perché espone un insieme minimo di funzioni, che sono state accuratamente scelte per gestire le più comuni funzioni di manipolazione delle stringhe. stringi, d’altra parte, è progettato per essere completo. Contiene quasi tutte le funzioni di cui potreste aver bisogno: stringi ha funzioni 256 per stringr 59.Se ti trovi lottare per fare qualcosa stringr, vale la pena dare un’occhiata stringi. pacchetti funzionano modo molto simile, quindi dovresti essere grado di tradurre la tua conoscenza di stringr modo naturale. La differenza principale è il prefisso: str_ contro stri_.","code":""},{"path":"stringhe.html","id":"esercizi-44","chapter":"14 Stringhe","heading":"14.7.1 Esercizi","text":"Trova le funzioni di stringi che:\nConta il numero di parole.\nTrova le stringhe duplicate.\nGenera un testo casuale.\nTrova le funzioni di stringi che:Conta il numero di parole.Trova le stringhe duplicate.Genera un testo casuale.Come controllate il linguaggio che stri_sort() utilizza per\nl’ordinamento?Come controllate il linguaggio che stri_sort() utilizza per\nl’ordinamento?","code":""},{"path":"fattori.html","id":"fattori","chapter":"15 Fattori","heading":"15 Fattori","text":"","code":""},{"path":"fattori.html","id":"introduzione-9","chapter":"15 Fattori","heading":"15.1 Introduzione","text":"R, fattori sono usati per lavorare con variabili categoriche, variabili che hanno un insieme fisso e noto di possibili valori. Sono anche utili quando si vogliono visualizzare vettori di caratteri un ordine non alfabetico.Storicamente, fattori erano molto più facili da lavorare rispetto ai caratteri. Di conseguenza, molte delle funzioni R base convertono automaticamente caratteri fattori. Questo significa che fattori spesso compaiono posti dove non sono effettivamente utili. Fortunatamente, non dovete preoccuparvi di questo nel tidyverse, e potete concentrarvi sulle situazioni cui fattori sono veramente utili.","code":""},{"path":"fattori.html","id":"prerequisiti-9","chapter":"15 Fattori","heading":"15.1.1 Prerequisiti","text":"Per lavorare con fattori, useremo il pacchetto forcats, che fa parte del nucleo del tidyverse. Fornisce strumenti per trattare con le variabili categoriche (ed è un anagramma di factors!) usando una vasta gamma di helper per lavorare con fattori.","code":"\nlibrary(tidyverse)"},{"path":"fattori.html","id":"imparare-di-più","chapter":"15 Fattori","heading":"15.1.2 Imparare di più","text":"Se volete saperne di più sui fattori, vi consiglio di leggere il documento di Amelia McNamara e Nicholas Horton, Wrangling categorical data R. Questo articolo espone parte della storia discussa stringsAsFactors: unauthorized biography e stringsAsFactors = <sigh>, e confronta gli approcci ordinati ai dati categorici delineati questo libro con metodi base di R. Una prima versione dell’articolo ha aiutato motivare e dare un ambito al pacchetto forcats; grazie Amelia & Nick!","code":""},{"path":"fattori.html","id":"creazione-di-fattori","chapter":"15 Fattori","heading":"15.2 Creazione di fattori","text":"Immaginate di avere una variabile che registra il mese:Usare una stringa per registrare questa variabile ha due problemi:Ci sono solo dodici mesi possibili, e non c’è niente che vi salvi\ndagli errori di battitura:\n\nx2 <- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")Ci sono solo dodici mesi possibili, e non c’è niente che vi salvi\ndagli errori di battitura:Non ordina modo utile:\n\nsort(x1)\n#> [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"Non ordina modo utile:Potete risolvere entrambi questi problemi con un fattore. Per creare un fattore dovete iniziare creando una lista dei livelli validi:Ora potete creare un fattore:E tutti valori non presenti nel set saranno silenziosamente convertiti NA:Se vuoi un avvertimento, puoi usare readr::parse_factor():Se ometti livelli, saranno presi dai dati ordine alfabetico:volte si preferisce che l’ordine dei livelli corrisponda ’ordine della prima apparizione nei dati. Potete farlo quando create il fattore impostando livelli su unique(x), o dopo il fatto, con fct_inorder():Se hai bisogno di accedere direttamente ’insieme dei livelli validi, puoi farlo con levels():","code":"\nx1 <- c(\"Dec\", \"Apr\", \"Jan\", \"Mar\")\nx2 <- c(\"Dec\", \"Apr\", \"Jam\", \"Mar\")\nsort(x1)\n#> [1] \"Apr\" \"Dec\" \"Jan\" \"Mar\"\nmonth_levels <- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\ny1 <- factor(x1, levels = month_levels)\ny1\n#> [1] Dec Apr Jan Mar\n#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\nsort(y1)\n#> [1] Jan Mar Apr Dec\n#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\ny2 <- factor(x2, levels = month_levels)\ny2\n#> [1] Dec  Apr  <NA> Mar \n#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\ny2 <- parse_factor(x2, levels = month_levels)\n#> Warning: 1 parsing failure.\n#> row col           expected actual\n#>   3  -- value in level set    Jam\nfactor(x1)\n#> [1] Dec Apr Jan Mar\n#> Levels: Apr Dec Jan Mar\nf1 <- factor(x1, levels = unique(x1))\nf1\n#> [1] Dec Apr Jan Mar\n#> Levels: Dec Apr Jan Mar\n\nf2 <- x1 %>% factor() %>% fct_inorder()\nf2\n#> [1] Dec Apr Jan Mar\n#> Levels: Dec Apr Jan Mar\nlevels(f2)\n#> [1] \"Dec\" \"Apr\" \"Jan\" \"Mar\""},{"path":"fattori.html","id":"indagine-sociale-generale","chapter":"15 Fattori","heading":"15.3 Indagine sociale generale","text":"Per il resto di questo capitolo, ci concentreremo su forcats::gss_cat. Si tratta di un campione di dati dal General Social Survey, che è un sondaggio di lunga data negli Stati Uniti condotto dall’organizzazione di ricerca indipendente NORC dell’Università di Chicago. Il sondaggio ha migliaia di domande, quindi gss_cat ne ho selezionate alcune che illustrano alcune sfide comuni che incontrerete quando lavorate con fattori.(Ricorda, poiché questo set di dati è fornito da un pacchetto, puoi ottenere maggiori informazioni sulle variabili con ?gss_cat).Quando fattori sono memorizzati una tibble, non puoi vedere loro livelli così facilmente. Un modo per vederli è con count():O con un grafico barre:Per impostazione predefinita, ggplot2 elimina livelli che non hanno alcun valore. Potete forzarne la visualizzazione con:Questi livelli rappresentano valori validi che semplicemente non si sono verificati questo set di dati. Sfortunatamente, dplyr non ha ancora un’opzione drop, ma la avrà futuro.Quando si lavora con fattori, le due operazioni più comuni sono cambiare l’ordine dei livelli e cambiare valori dei livelli. Queste operazioni sono descritte nelle sezioni seguenti.","code":"\ngss_cat\n#> # A tibble: 21,483 × 9\n#>    year marital         age race  rincome        partyid     relig denom tvhours\n#>   <int> <fct>         <int> <fct> <fct>          <fct>       <fct> <fct>   <int>\n#> 1  2000 Never married    26 White $8000 to 9999  Ind,near r… Prot… Sout…      12\n#> 2  2000 Divorced         48 White $8000 to 9999  Not str re… Prot… Bapt…      NA\n#> 3  2000 Widowed          67 White Not applicable Independent Prot… No d…       2\n#> 4  2000 Never married    39 White Not applicable Ind,near r… Orth… Not …       4\n#> 5  2000 Divorced         25 White Not applicable Not str de… None  Not …       1\n#> 6  2000 Married          25 White $20000 - 24999 Strong dem… Prot… Sout…      NA\n#> # … with 21,477 more rows\ngss_cat %>%\n  count(race)\n#> # A tibble: 3 × 2\n#>   race      n\n#>   <fct> <int>\n#> 1 Other  1959\n#> 2 Black  3129\n#> 3 White 16395\nggplot(gss_cat, aes(race)) +\n  geom_bar()\nggplot(gss_cat, aes(race)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)"},{"path":"fattori.html","id":"esercizio","chapter":"15 Fattori","heading":"15.3.1 Esercizio","text":"Esplora la distribuzione del reddito (reddito dichiarato). Cosa rende il\ngrafico barre predefinito difficile da capire? Come potresti migliorare il grafico?Esplora la distribuzione del reddito (reddito dichiarato). Cosa rende il\ngrafico barre predefinito difficile da capire? Come potresti migliorare il grafico?Qual è il relig più comune questo sondaggio? Qual è il più\ncomune partyid?Qual è il relig più comune questo sondaggio? Qual è il più\ncomune partyid?quale relig si applica il denom (denominazione)? Come puoi scoprirlo\ncon una tabella? Come puoi scoprirlo con una visualizzazione?\nquale relig si applica il denom (denominazione)? Come puoi scoprirlo\ncon una tabella? Come puoi scoprirlo con una visualizzazione?","code":""},{"path":"fattori.html","id":"modificare-lordine-dei-fattori","chapter":"15 Fattori","heading":"15.4 Modificare l’ordine dei fattori","text":"Spesso è utile cambiare l’ordine dei livelli dei fattori una visualizzazione. Per esempio, immaginate di voler esplorare il numero medio di ore trascorse guardare la TV al giorno nelle varie religioni:È difficile interpretare questo grafico perché non c’è uno schema generale. Possiamo migliorarlo riordinando livelli di relig usando fct_reorder(). fct_reorder() prende tre argomenti:f, il fattore di cui volete modificare livelli.x, un vettore numerico che volete usare per riordinare livelli.Opzionalmente, fun, una funzione che viene usata se ci sono più valori di\nx per ogni valore di f. Il valore predefinito è median.Riordinare la religione rende molto più facile vedere che le persone nella categoria “Non ” guardano molta più TV, e l’Induismo e altre religioni orientali ne guardano molto meno.Quando cominciate fare trasformazioni più complicate, vi consiglio di spostarle fuori da aes() e un passo separato mutate(). Per esempio, potreste riscrivere il grafico di cui sopra come:E se creassimo un grafico simile guardando come l’età media varia seconda del livello di reddito dichiarato?Qui, riordinare arbitrariamente livelli non è una buona idea! Questo perché rincome ha già un ordine di principio con cui non dovremmo scherzare. Riservate fct_reorder() ai fattori cui livelli sono ordinati arbitrariamente.Tuttavia, ha senso mettere “Non applicabile” davanti agli altri livelli speciali. Potete usare fct_relevel(). Prende un fattore, f, e poi un qualsiasi numero di livelli che volete spostare ’inizio della riga.Perché pensi che l’età media per “Non applicabile” sia così alta?Un altro tipo di riordino è utile quando si colorano le linee di un grafico. fct_reorder2() riordina il fattore base ai valori y associati ai valori x più grandi. Questo rende il grafico più facile da leggere perché colori delle linee si allineano alla legenda.Infine, per grafici barre, puoi usare fct_infreq() per ordinare livelli frequenza crescente: questo è il tipo più semplice di riordino perché non ha bisogno di variabili extra. Potreste volerlo combinare con fct_rev().","code":"\nrelig_summary <- gss_cat %>%\n  group_by(relig) %>%\n  summarise(\n    age = mean(age, na.rm = TRUE),\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(relig_summary, aes(tvhours, relig)) + geom_point()\nggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +\n  geom_point()\nrelig_summary %>%\n  mutate(relig = fct_reorder(relig, tvhours)) %>%\n  ggplot(aes(tvhours, relig)) +\n    geom_point()\nrincome_summary <- gss_cat %>%\n  group_by(rincome) %>%\n  summarise(\n    age = mean(age, na.rm = TRUE),\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()\nggplot(rincome_summary, aes(age, fct_relevel(rincome, \"Not applicable\"))) +\n  geom_point()\nby_age <- gss_cat %>%\n  filter(!is.na(age)) %>%\n  count(age, marital) %>%\n  group_by(age) %>%\n  mutate(prop = n / sum(n))\n\nggplot(by_age, aes(age, prop, colour = marital)) +\n  geom_line(na.rm = TRUE)\n\nggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +\n  geom_line() +\n  labs(colour = \"marital\")\ngss_cat %>%\n  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%\n  ggplot(aes(marital)) +\n    geom_bar()"},{"path":"fattori.html","id":"esercizi-45","chapter":"15 Fattori","heading":"15.4.1 Esercizi","text":"Ci sono alcuni numeri sospettosamente alti tvhours. La media è un buon\nriassunto?Ci sono alcuni numeri sospettosamente alti tvhours. La media è un buon\nriassunto?Per ogni fattore gss_cat identifica se l’ordine dei livelli è\narbitrario o di principio.Per ogni fattore gss_cat identifica se l’ordine dei livelli è\narbitrario o di principio.Perché lo spostamento di “Non applicabile” ’inizio dei livelli lo ha spostato \nfondo al grafico?Perché lo spostamento di “Non applicabile” ’inizio dei livelli lo ha spostato \nfondo al grafico?","code":""},{"path":"fattori.html","id":"modificare-i-livelli-dei-fattori","chapter":"15 Fattori","heading":"15.5 Modificare i livelli dei fattori","text":"Più potente che cambiare l’ordine dei livelli è cambiare loro valori. Questo ti permette di chiarire le etichette per la pubblicazione e di far collassare livelli per visualizzazioni di alto livello. Lo strumento più generale e potente è fct_recode(). Ti permette di ricodificare, o cambiare, il valore di ogni livello. Per esempio, prendete il gss_cat$partyid:livelli sono concisi e incoerenti. Modifichiamoli per essere più lunghi e usare una costruzione parallela.fct_recode() lascerà livelli che non sono esplicitamente menzionati così come sono, e ti avvertirà se accidentalmente fai riferimento ad un livello che non esiste.Per combinare gruppi, puoi assegnare più livelli vecchi allo stesso livello nuovo:Dovete usare questa tecnica con attenzione: se raggruppate insieme categorie che sono veramente diverse finirete per ottenere risultati fuorvianti.Se volete collassare molti livelli, fct_collapse() è un’utile variante di fct_recode(). Per ogni nuova variabile, potete fornire un vettore di vecchi livelli:volte si vuole semplicemente mettere insieme tutti piccoli gruppi per rendere più semplice un grafico o una tabella. Questo è il compito di fct_lump():Il comportamento predefinito è quello di raggruppare progressivamente gruppi più piccoli, assicurandosi che l’aggregato sia ancora il gruppo più piccolo. questo caso non è molto utile: è vero che la maggioranza degli americani questo sondaggio sono protestanti, ma probabilmente abbiamo esagerato.Invece, possiamo usare il parametro n per specificare quanti gruppi (esclusi gli altri) vogliamo mantenere:","code":"\ngss_cat %>% count(partyid)\n#> # A tibble: 10 × 2\n#>   partyid                n\n#>   <fct>              <int>\n#> 1 No answer            154\n#> 2 Don't know             1\n#> 3 Other party          393\n#> 4 Strong republican   2314\n#> 5 Not str republican  3032\n#> 6 Ind,near rep        1791\n#> # … with 4 more rows\ngss_cat %>%\n  mutate(partyid = fct_recode(partyid,\n    \"Republican, strong\"    = \"Strong republican\",\n    \"Republican, weak\"      = \"Not str republican\",\n    \"Independent, near rep\" = \"Ind,near rep\",\n    \"Independent, near dem\" = \"Ind,near dem\",\n    \"Democrat, weak\"        = \"Not str democrat\",\n    \"Democrat, strong\"      = \"Strong democrat\"\n  )) %>%\n  count(partyid)\n#> # A tibble: 10 × 2\n#>   partyid                   n\n#>   <fct>                 <int>\n#> 1 No answer               154\n#> 2 Don't know                1\n#> 3 Other party             393\n#> 4 Republican, strong     2314\n#> 5 Republican, weak       3032\n#> 6 Independent, near rep  1791\n#> # … with 4 more rows\ngss_cat %>%\n  mutate(partyid = fct_recode(partyid,\n    \"Republican, strong\"    = \"Strong republican\",\n    \"Republican, weak\"      = \"Not str republican\",\n    \"Independent, near rep\" = \"Ind,near rep\",\n    \"Independent, near dem\" = \"Ind,near dem\",\n    \"Democrat, weak\"        = \"Not str democrat\",\n    \"Democrat, strong\"      = \"Strong democrat\",\n    \"Other\"                 = \"No answer\",\n    \"Other\"                 = \"Don't know\",\n    \"Other\"                 = \"Other party\"\n  )) %>%\n  count(partyid)\n#> # A tibble: 8 × 2\n#>   partyid                   n\n#>   <fct>                 <int>\n#> 1 Other                   548\n#> 2 Republican, strong     2314\n#> 3 Republican, weak       3032\n#> 4 Independent, near rep  1791\n#> 5 Independent            4119\n#> 6 Independent, near dem  2499\n#> # … with 2 more rows\ngss_cat %>%\n  mutate(partyid = fct_collapse(partyid,\n    other = c(\"No answer\", \"Don't know\", \"Other party\"),\n    rep = c(\"Strong republican\", \"Not str republican\"),\n    ind = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n    dem = c(\"Not str democrat\", \"Strong democrat\")\n  )) %>%\n  count(partyid)\n#> # A tibble: 4 × 2\n#>   partyid     n\n#>   <fct>   <int>\n#> 1 other     548\n#> 2 rep      5346\n#> 3 ind      8409\n#> 4 dem      7180\ngss_cat %>%\n  mutate(relig = fct_lump(relig)) %>%\n  count(relig)\n#> # A tibble: 2 × 2\n#>   relig          n\n#>   <fct>      <int>\n#> 1 Protestant 10846\n#> 2 Other      10637\ngss_cat %>%\n  mutate(relig = fct_lump(relig, n = 10)) %>%\n  count(relig, sort = TRUE) %>%\n  print(n = Inf)\n#> # A tibble: 10 × 2\n#>    relig                       n\n#>    <fct>                   <int>\n#>  1 Protestant              10846\n#>  2 Catholic                 5124\n#>  3 None                     3523\n#>  4 Christian                 689\n#>  5 Other                     458\n#>  6 Jewish                    388\n#>  7 Buddhism                  147\n#>  8 Inter-nondenominational   109\n#>  9 Moslem/islam              104\n#> 10 Orthodox-christian         95"},{"path":"fattori.html","id":"esercizi-46","chapter":"15 Fattori","heading":"15.5.1 Esercizi","text":"Come sono cambiate nel tempo le proporzioni di persone che si identificano come Democratici, Repubblicani e\nindipendenti sono cambiate nel tempo?Come sono cambiate nel tempo le proporzioni di persone che si identificano come Democratici, Repubblicani e\nindipendenti sono cambiate nel tempo?Come si può far collassare il “reddito” un piccolo insieme di categorie?\nCome si può far collassare il “reddito” un piccolo insieme di categorie?","code":""},{"path":"date-e-tempi.html","id":"date-e-tempi","chapter":"16 Date e tempi","heading":"16 Date e tempi","text":"","code":""},{"path":"date-e-tempi.html","id":"introduzione-10","chapter":"16 Date e tempi","heading":"16.1 Introduzione","text":"Questo capitolo vi mostrerà come lavorare con date e orari R. prima vista, date e orari sembrano semplici. Li usate tutto il tempo nella vostra vita normale e non sembrano causare molta confusione. Tuttavia, più si impara su date e orari, più sembra che diventino complicati. Per scaldarti, prova queste tre domande apparentemente semplici:Ogni anno ha 365 giorni?Ogni giorno ha 24 ore?Ogni minuto ha 60 secondi?Sono sicuro che sai che non tutti gli anni hanno 365 giorni, ma conosci la regola completa per determinare se un anno è bisestile? (Potresti aver ricordato che molte parti del mondo usano l’ora legale, per cui alcuni giorni hanno 23 ore e altri 25. Potresti non aver saputo che alcuni minuti hanno 61 secondi perché ogni tanto vengono aggiunti secondi bisestili perché la rotazione terrestre sta gradualmente rallentando.Le date e gli orari sono difficili perché devono conciliare due fenomeni fisici (la rotazione della Terra e la sua orbita intorno al sole) con tutta una serie di fenomeni geopolitici tra cui mesi, fusi orari e l’ora legale. Questo capitolo non vi insegnerà ogni minimo dettaglio su date e orari, ma vi darà una solida base di abilità pratiche che vi aiuteranno nelle comuni sfide dell’analisi dei dati.","code":""},{"path":"date-e-tempi.html","id":"prerequisiti-10","chapter":"16 Date e tempi","heading":"16.1.1 Prerequisiti","text":"Questo capitolo si concentrerà sul pacchetto lubridate, che rende più facile lavorare con le date e gli orari R. lubridate non fa parte del core tidyverse perché ne avete bisogno solo quando lavorate con le date/gli orari. Avremo anche bisogno di nycflights13 per dati di pratica.","code":"\nlibrary(tidyverse)\n\nlibrary(lubridate)\nlibrary(nycflights13)"},{"path":"date-e-tempi.html","id":"creare-dateore","chapter":"16 Date e tempi","heading":"16.2 Creare date/ore","text":"Ci sono tre tipi di dati data/ora che si riferiscono ad un istante nel tempo:Un date. Tibbles lo stampa come <date>.Un date. Tibbles lo stampa come <date>.Un time ’interno di un giorno. Tibbles lo stampa come <time>.Un time ’interno di un giorno. Tibbles lo stampa come <time>.Un date-time è una data più un’ora: identifica univocamente un\nistante nel tempo (tipicamente al secondo più vicino). Tibbles lo stampa\ncome <dttm>. Altrove R questi sono chiamati POSIXct, ma non credo\nche sia un nome molto utile.Un date-time è una data più un’ora: identifica univocamente un\nistante nel tempo (tipicamente al secondo più vicino). Tibbles lo stampa\ncome <dttm>. Altrove R questi sono chiamati POSIXct, ma non credo\nche sia un nome molto utile.questo capitolo ci concentreremo solo su date e date-ora, poiché R non ha una classe nativa per la memorizzazione dei tempi. Se ne avete bisogno, potete usare il pacchetto hms.Dovreste sempre usare il tipo di dati più semplice possibile che funzioni per le vostre esigenze. Questo significa che se potete usare una data invece di una data-ora, dovreste farlo. Le date-ora sono sostanzialmente più complicate causa della necessità di gestire fusi orari, su cui torneremo alla fine del capitolo.Per ottenere la data o la data-ora corrente potete usare today() o now():Altrimenti, ci sono tre modi per creare una data/ora:Da una stringa.Da componenti individuali di data/ora.Da un oggetto data/ora esistente.Funzionano come segue.","code":"\ntoday()\n#> [1] \"2023-02-17\"\nnow()\n#> [1] \"2023-02-17 23:18:48 UTC\""},{"path":"date-e-tempi.html","id":"da-stringhe","chapter":"16 Date e tempi","heading":"16.2.1 Da stringhe","text":"dati di data/ora spesso si presentano come stringhe. Hai visto un approccio per analizzare le stringhe date-ora date-ore. Un altro approccio è quello di usare gli helper forniti da lubridate. Essi elaborano automaticamente il formato una volta che si specifica l’ordine del componente. Per usarli, identificate l’ordine cui anno, mese e giorno appaiono nelle vostre date, poi disponete “y”, “m” e “d” nello stesso ordine. Questo vi dà il nome della funzione lubridate che analizzerà la vostra data. Per esempio:Queste funzioni accettano anche numeri non quotati. Questo è il modo più conciso per creare un singolo oggetto data/ora, come potrebbe essere necessario quando si filtrano dati data/ora. La funzione ymd() è breve e non ambigua:ymd() e amici creano date. Per creare una data-ora, aggiungete un trattino basso e uno o più di “h”, “m” e “s” al nome della funzione di analisi:Potete anche forzare la creazione di una data-ora da una data fornendo un fuso orario:","code":"\nymd(\"2017-01-31\")\n#> [1] \"2017-01-31\"\nmdy(\"January 31st, 2017\")\n#> [1] \"2017-01-31\"\ndmy(\"31-Jan-2017\")\n#> [1] \"2017-01-31\"\nymd(20170131)\n#> [1] \"2017-01-31\"\nymd_hms(\"2017-01-31 20:11:59\")\n#> [1] \"2017-01-31 20:11:59 UTC\"\nmdy_hm(\"01/31/2017 08:01\")\n#> [1] \"2017-01-31 08:01:00 UTC\"\nymd(20170131, tz = \"UTC\")\n#> [1] \"2017-01-31 UTC\""},{"path":"date-e-tempi.html","id":"da-componenti-individuali","chapter":"16 Date e tempi","heading":"16.2.2 Da componenti individuali","text":"Invece di una singola stringa, volte avrete singoli componenti della data-ora sparsi su più colonne. Questo è quello che abbiamo nei dati dei voli:Per creare una data/ora da questo tipo di input, usate make_date() per le date, o make_datetime() per le date-ora:Facciamo la stessa cosa per ciascuna delle quattro colonne del tempo flights. tempi sono rappresentati un formato un po’ strano, quindi usiamo l’aritmetica dei moduli per estrarre le componenti di ore e minuti. Una volta create le variabili data-ora, mi concentro sulle variabili che esploreremo nel resto del capitolo.Con questi dati, posso visualizzare la distribuzione degli orari di partenza durante l’anno:Notate che quando usate date-ora un contesto numerico (come un istogramma), 1 significa 1 secondo, quindi una larghezza di banda di 86400 significa un giorno. Per le date, 1 significa 1 giorno.","code":"\nflights %>% \n  select(year, month, day, hour, minute)\n#> # A tibble: 336,776 × 5\n#>    year month   day  hour minute\n#>   <int> <int> <int> <dbl>  <dbl>\n#> 1  2013     1     1     5     15\n#> 2  2013     1     1     5     29\n#> 3  2013     1     1     5     40\n#> 4  2013     1     1     5     45\n#> 5  2013     1     1     6      0\n#> 6  2013     1     1     5     58\n#> # … with 336,770 more rows\nflights %>% \n  select(year, month, day, hour, minute) %>% \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n#> # A tibble: 336,776 × 6\n#>    year month   day  hour minute departure          \n#>   <int> <int> <int> <dbl>  <dbl> <dttm>             \n#> 1  2013     1     1     5     15 2013-01-01 05:15:00\n#> 2  2013     1     1     5     29 2013-01-01 05:29:00\n#> 3  2013     1     1     5     40 2013-01-01 05:40:00\n#> 4  2013     1     1     5     45 2013-01-01 05:45:00\n#> 5  2013     1     1     6      0 2013-01-01 06:00:00\n#> 6  2013     1     1     5     58 2013-01-01 05:58:00\n#> # … with 336,770 more rows\nmake_datetime_100 <- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt <- flights %>% \n  filter(!is.na(dep_time), !is.na(arr_time)) %>% \n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    arr_time = make_datetime_100(year, month, day, arr_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)\n  ) %>% \n  select(origin, dest, ends_with(\"delay\"), ends_with(\"time\"))\n\nflights_dt\n#> # A tibble: 328,063 × 9\n#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             \n#> 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00\n#> 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00\n#> 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00\n#> 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00\n#> 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00\n#> 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00\n#> # … with 328,057 more rows, and 3 more variables: arr_time <dttm>,\n#> #   sched_arr_time <dttm>, air_time <dbl>\nflights_dt %>% \n  ggplot(aes(dep_time)) + \n  geom_freqpoly(binwidth = 86400) # 86400 secondi = 1 giorno\nflights_dt %>% \n  filter(dep_time < ymd(20130102)) %>% \n  ggplot(aes(dep_time)) + \n  geom_freqpoly(binwidth = 600) # 600 s = 10 minuti"},{"path":"date-e-tempi.html","id":"da-altri-tipi","chapter":"16 Date e tempi","heading":"16.2.3 Da altri tipi","text":"Potresti voler passare da una data-ora una data. Questo è il lavoro di as_datetime() e as_date():volte otterrete data/ora come offset numerico dalla “Unix Epoch”, 1970-01-01. Se l’offset è secondi, usate as_datetime(); se è giorni, usate as_date().","code":"\nas_datetime(today())\n#> [1] \"2023-02-17 UTC\"\nas_date(now())\n#> [1] \"2023-02-17\"\nas_datetime(60 * 60 * 10)\n#> [1] \"1970-01-01 10:00:00 UTC\"\nas_date(365 * 10 + 2)\n#> [1] \"1980-01-01\""},{"path":"date-e-tempi.html","id":"esercizi-47","chapter":"16 Date e tempi","heading":"16.2.4 Esercizi","text":"Cosa succede se analizzi una stringa che contiene date non valide?\n\nymd(c(\"2010-10-10\", \"bananas\"))Cosa succede se analizzi una stringa che contiene date non valide?Cosa fa l’argomento tzone di today()? Perché è importante?Cosa fa l’argomento tzone di today()? Perché è importante?Usa la funzione lubridate appropriata per analizzare ciascuna delle seguenti date:\n\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 2014Usa la funzione lubridate appropriata per analizzare ciascuna delle seguenti date:","code":"\nymd(c(\"2010-10-10\", \"bananas\"))\nd1 <- \"January 1, 2010\"\nd2 <- \"2015-Mar-07\"\nd3 <- \"06-Jun-2017\"\nd4 <- c(\"August 19 (2015)\", \"July 1 (2015)\")\nd5 <- \"12/30/14\" # Dec 30, 2014"},{"path":"date-e-tempi.html","id":"componenti-data-ora","chapter":"16 Date e tempi","heading":"16.3 Componenti data-ora","text":"Ora che sapete come ottenere dati data-ora nelle strutture dati data-ora di R, esploriamo cosa potete fare con esse. Questa sezione si concentrerà sulle funzioni di accesso che vi permettono di ottenere e impostare componenti individuali. La prossima sezione esaminerà come funziona l’aritmetica con le date-ora.","code":""},{"path":"date-e-tempi.html","id":"ottenere-componenti","chapter":"16 Date e tempi","heading":"16.3.1 Ottenere componenti","text":"Potete estrarre singole parti della data con le funzioni di accesso year(), month(), mday() (giorno del mese), yday() (giorno dell’anno), wday() (giorno della settimana), hour(), minute(), e second().Per month() e day() potete impostare label = TRUE per restituire il nome abbreviato del mese o del giorno della settimana. Impostate abbr = FALSE per restituire il nome completo.Possiamo usare wday() per vedere che più voli partono durante la settimana che nel fine settimana:C’è un modello interessante se guardiamo il ritardo medio di partenza per minuto ’interno dell’ora. Sembra che voli che partono nei minuti 20-30 e 50-60 abbiano ritardi molto più bassi rispetto al resto dell’ora!È interessante notare che se guardiamo l’orario di partenza programmato non vediamo un modello così forte:Allora perché vediamo questo schema con gli orari di partenza effettivi? Beh, come molti dati raccolti da esseri umani, c’è un forte pregiudizio verso voli che partono orari di partenza “piacevoli”. Fai sempre attenzione questo tipo di schema ogni volta che lavori con dati che coinvolgono il giudizio umano!","code":"\ndatetime <- ymd_hms(\"2016-07-08 12:34:56\")\n\nyear(datetime)\n#> [1] 2016\nmonth(datetime)\n#> [1] 7\nmday(datetime)\n#> [1] 8\n\nyday(datetime)\n#> [1] 190\nwday(datetime)\n#> [1] 6\nmonth(datetime, label = TRUE)\n#> [1] Jul\n#> 12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec\nwday(datetime, label = TRUE, abbr = FALSE)\n#> [1] Friday\n#> 7 Levels: Sunday < Monday < Tuesday < Wednesday < Thursday < ... < Saturday\nflights_dt %>% \n  mutate(wday = wday(dep_time, label = TRUE)) %>% \n  ggplot(aes(x = wday)) +\n    geom_bar()\nflights_dt %>% \n  mutate(minute = minute(dep_time)) %>% \n  group_by(minute) %>% \n  summarise(\n    avg_delay = mean(arr_delay, na.rm = TRUE),\n    n = n()) %>% \n  ggplot(aes(minute, avg_delay)) +\n    geom_line()\nsched_dep <- flights_dt %>% \n  mutate(minute = minute(sched_dep_time)) %>% \n  group_by(minute) %>% \n  summarise(\n    avg_delay = mean(arr_delay, na.rm = TRUE),\n    n = n())\n\nggplot(sched_dep, aes(minute, avg_delay)) +\n  geom_line()\nggplot(sched_dep, aes(minute, n)) +\n  geom_line()"},{"path":"date-e-tempi.html","id":"arrotondamento","chapter":"16 Date e tempi","heading":"16.3.2 Arrotondamento","text":"Un approccio alternativo al tracciamento di componenti individuali è quello di arrotondare la data ad un’unità di tempo vicina, con floor_date(), round_date(), e ceiling_date(). Ogni funzione prende un vettore di date da aggiustare e poi il nome dell’unità di arrotondamento per difetto (floor), per eccesso (ceiling), o per eccesso. Questo, per esempio, ci permette di tracciare il numero di voli per settimana:Calcolare la differenza tra una data arrotondata e una non arrotondata può essere particolarmente utile.","code":"\nflights_dt %>% \n  count(week = floor_date(dep_time, \"week\")) %>% \n  ggplot(aes(week, n)) +\n    geom_line()"},{"path":"date-e-tempi.html","id":"impostazione-dei-componenti","chapter":"16 Date e tempi","heading":"16.3.3 Impostazione dei componenti","text":"Potete anche usare ogni funzione di accesso per impostare componenti di una data/ora:alternativa, piuttosto che modificare sul posto, potete creare una nuova data-ora con update(). Questo permette anche di impostare più valori una volta.Se valori sono troppo grandi, si ribaltano:Potete usare update() per mostrare la distribuzione dei voli nel corso della giornata per ogni giorno dell’anno:Impostare le componenti più grandi di una data su una costante è una tecnica potente che permette di esplorare modelli nelle componenti più piccole.","code":"\n(datetime <- ymd_hms(\"2016-07-08 12:34:56\"))\n#> [1] \"2016-07-08 12:34:56 UTC\"\n\nyear(datetime) <- 2020\ndatetime\n#> [1] \"2020-07-08 12:34:56 UTC\"\nmonth(datetime) <- 01\ndatetime\n#> [1] \"2020-01-08 12:34:56 UTC\"\nhour(datetime) <- hour(datetime) + 1\ndatetime\n#> [1] \"2020-01-08 13:34:56 UTC\"\nupdate(datetime, year = 2020, month = 2, mday = 2, hour = 2)\n#> [1] \"2020-02-02 02:34:56 UTC\"\nymd(\"2015-02-01\") %>% \n  update(mday = 30)\n#> [1] \"2015-03-02\"\nymd(\"2015-02-01\") %>% \n  update(hour = 400)\n#> [1] \"2015-02-17 16:00:00 UTC\"\nflights_dt %>% \n  mutate(dep_hour = update(dep_time, yday = 1)) %>% \n  ggplot(aes(dep_hour)) +\n    geom_freqpoly(binwidth = 300)"},{"path":"date-e-tempi.html","id":"esercizi-48","chapter":"16 Date e tempi","heading":"16.3.4 Esercizi","text":"Come cambia la distribuzione dei tempi di volo un giorno nel\ncorso dell’anno?Come cambia la distribuzione dei tempi di volo un giorno nel\ncorso dell’anno?Confronta dep_time, sched_dep_time e dep_delay. Sono coerenti?\nSpiega tuoi risultati.Confronta dep_time, sched_dep_time e dep_delay. Sono coerenti?\nSpiega tuoi risultati.Confronta air_time con la durata tra la partenza e l’arrivo.\nSpiega tuoi risultati. (Suggerimento: considera la posizione dell’aeroporto).Confronta air_time con la durata tra la partenza e l’arrivo.\nSpiega tuoi risultati. (Suggerimento: considera la posizione dell’aeroporto).Come cambia il tempo medio di ritardo nel corso di una giornata?\nDovresti usare dep_time o sched_dep_time? Perché?Come cambia il tempo medio di ritardo nel corso di una giornata?\nDovresti usare dep_time o sched_dep_time? Perché?quale giorno della settimana dovresti partire se vuoi minimizzare la\nla possibilità di un ritardo?quale giorno della settimana dovresti partire se vuoi minimizzare la\nla possibilità di un ritardo?Cosa rende la distribuzione di diamonds$carat e\nflights$sched_dep_time?Cosa rende la distribuzione di diamonds$carat e\nflights$sched_dep_time?Confermate la mia ipotesi che le partenze anticipate dei voli nei minuti\n20-30 e 50-60 sono causate da voli di linea che partono anticipo.\nSuggerimento: create una variabile binaria che vi dica se un volo\nè stato ritardato.Confermate la mia ipotesi che le partenze anticipate dei voli nei minuti\n20-30 e 50-60 sono causate da voli di linea che partono anticipo.\nSuggerimento: create una variabile binaria che vi dica se un volo\nè stato ritardato.","code":""},{"path":"date-e-tempi.html","id":"intervalli-di-tempo","chapter":"16 Date e tempi","heading":"16.4 Intervalli di tempo","text":"Ora imparerete come funziona l’aritmetica con le date, incluse la sottrazione, l’addizione e la divisione. Lungo la strada, imparerete conoscere tre importanti classi che rappresentano intervalli di tempo:durations, che rappresentano un numero esatto di secondi.periodi, che rappresentano unità umane come settimane e mesi.intervalli, che rappresentano un punto iniziale e uno finale.","code":""},{"path":"date-e-tempi.html","id":"durate","chapter":"16 Date e tempi","heading":"16.4.1 Durate","text":"R, quando si sottraggono due date, si ottiene un oggetto difftime:Un oggetto di classe difftime registra un intervallo di tempo di secondi, minuti, ore, giorni o settimane. Questa ambiguità può rendere difftime un po’ doloroso lavorarci, così lubridate fornisce un’alternativa che usa sempre secondi: la durata.Le durate hanno un mucchio di costruttori convenienti:Le durate registrano sempre l’intervallo di tempo secondi. Unità più grandi sono create convertendo minuti, ore, giorni, settimane e anni secondi al tasso standard (60 secondi un minuto, 60 minuti un’ora, 24 ore un giorno, 7 giorni una settimana, 365 giorni un anno).È possibile aggiungere e moltiplicare le durate:È possibile aggiungere e sottrarre durate e da giorni:Tuttavia, poiché le durate rappresentano un numero esatto di secondi, volte si potrebbe ottenere un risultato inaspettato:Perché un giorno dopo le 13 del 12 marzo ci sono le 14 del 13 marzo?! Se guardi attentamente la data potresti anche notare che fusi orari sono cambiati. causa del DST, il 12 marzo ha solo 23 ore, quindi se aggiungiamo un giorno intero di secondi ci ritroviamo con un orario diverso.","code":"\n# How old is Hadley?\nh_age <- today() - ymd(19791014)\nh_age\n#> Time difference of 15832 days\nas.duration(h_age)\n#> [1] \"1367884800s (~43.35 years)\"\ndseconds(15)\n#> [1] \"15s\"\ndminutes(10)\n#> [1] \"600s (~10 minutes)\"\ndhours(c(12, 24))\n#> [1] \"43200s (~12 hours)\" \"86400s (~1 days)\"\nddays(0:5)\n#> [1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n#> [4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\ndweeks(3)\n#> [1] \"1814400s (~3 weeks)\"\ndyears(1)\n#> [1] \"31557600s (~1 years)\"\n2 * dyears(1)\n#> [1] \"63115200s (~2 years)\"\ndyears(1) + dweeks(12) + dhours(15)\n#> [1] \"38869200s (~1.23 years)\"\ntomorrow <- today() + ddays(1)\nlast_year <- today() - dyears(1)\none_pm <- ymd_hms(\"2016-03-12 13:00:00\", tz = \"America/New_York\")\n\none_pm\n#> [1] \"2016-03-12 13:00:00 EST\"\none_pm + ddays(1)\n#> [1] \"2016-03-13 14:00:00 EDT\""},{"path":"date-e-tempi.html","id":"periodi","chapter":"16 Date e tempi","heading":"16.4.2 Periodi","text":"Per risolvere questo problema, lubridate fornisce periodi. periodi sono intervalli di tempo ma non hanno una lunghezza fissa secondi, invece lavorano con tempi “umani”, come giorni e mesi. Questo permette loro di lavorare modo più intuitivo:Come le durate, periodi possono essere creati con un certo numero di funzioni costruttrici carine.Puoi aggiungere e moltiplicare periodi:E, naturalmente, aggiungeteli alle date. Rispetto alle durate, periodi hanno più probabilità di fare ciò che vi aspettate:Usiamo periodi per risolvere una stranezza legata alle date dei nostri voli. Alcuni aerei sembrano essere arrivati destinazione prima della loro partenza da New York City.Questi sono voli notturni. Abbiamo usato le stesse informazioni sulla data sia per la partenza che per l’arrivo, ma questi voli sono arrivati il giorno successivo. Possiamo risolvere questo problema aggiungendo days(1) ’orario di arrivo di ogni volo notturno.Ora tutti nostri voli obbediscono alle leggi della fisica.","code":"\none_pm\n#> [1] \"2016-03-12 13:00:00 EST\"\none_pm + days(1)\n#> [1] \"2016-03-13 13:00:00 EDT\"\nseconds(15)\n#> [1] \"15S\"\nminutes(10)\n#> [1] \"10M 0S\"\nhours(c(12, 24))\n#> [1] \"12H 0M 0S\" \"24H 0M 0S\"\ndays(7)\n#> [1] \"7d 0H 0M 0S\"\nmonths(1:6)\n#> [1] \"1m 0d 0H 0M 0S\" \"2m 0d 0H 0M 0S\" \"3m 0d 0H 0M 0S\" \"4m 0d 0H 0M 0S\"\n#> [5] \"5m 0d 0H 0M 0S\" \"6m 0d 0H 0M 0S\"\nweeks(3)\n#> [1] \"21d 0H 0M 0S\"\nyears(1)\n#> [1] \"1y 0m 0d 0H 0M 0S\"\n10 * (months(6) + days(1))\n#> [1] \"60m 10d 0H 0M 0S\"\ndays(50) + hours(25) + minutes(2)\n#> [1] \"50d 25H 2M 0S\"\n# Un anno bisestile\nymd(\"2016-01-01\") + dyears(1)\n#> [1] \"2016-12-31 06:00:00 UTC\"\nymd(\"2016-01-01\") + years(1)\n#> [1] \"2017-01-01\"\n\n# Ora legale\none_pm + ddays(1)\n#> [1] \"2016-03-13 14:00:00 EDT\"\none_pm + days(1)\n#> [1] \"2016-03-13 13:00:00 EDT\"\nflights_dt %>% \n  filter(arr_time < dep_time) \n#> # A tibble: 10,633 × 9\n#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             \n#> 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00\n#> 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00\n#> 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00\n#> 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00\n#> 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00\n#> 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00\n#> # … with 10,627 more rows, and 3 more variables: arr_time <dttm>,\n#> #   sched_arr_time <dttm>, air_time <dbl>\nflights_dt <- flights_dt %>% \n  mutate(\n    overnight = arr_time < dep_time,\n    arr_time = arr_time + days(overnight * 1),\n    sched_arr_time = sched_arr_time + days(overnight * 1)\n  )\nflights_dt %>% \n  filter(overnight, arr_time < dep_time) \n#> # A tibble: 0 × 10\n#> # … with 10 variables: origin <chr>, dest <chr>, dep_delay <dbl>,\n#> #   arr_delay <dbl>, dep_time <dttm>, sched_dep_time <dttm>, arr_time <dttm>,\n#> #   sched_arr_time <dttm>, air_time <dbl>, overnight <lgl>"},{"path":"date-e-tempi.html","id":"intervalli","chapter":"16 Date e tempi","heading":"16.4.3 Intervalli","text":"È ovvio cosa dovrebbe restituire dyears(1) / ddays(365): uno, perché le durate sono sempre rappresentate da un numero di secondi, e la durata di un anno è definita come 365 giorni di secondi.Cosa dovrebbe restituire years(1) / days(1)? Beh, se l’anno fosse il 2015 dovrebbe restituire 365, ma se fosse il 2016, dovrebbe restituire 366! Non ci sono abbastanza informazioni per lubridate per dare una singola risposta chiara. Quello che fa invece è dare una stima, con un avvertimento:Se volete una misura più precisa, dovrete usare un intervallo. Un intervallo è una durata con un punto di partenza: questo lo rende preciso e ti permette di determinare esattamente la sua durata:Per scoprire quanti periodi rientrano un intervallo, è necessario utilizzare la divisione di interi:","code":"\nyears(1) / days(1)\n#> [1] 365.25\nnext_year <- today() + years(1)\n(today() %--% next_year) / ddays(1)\n#> [1] 365\n(today() %--% next_year) %/% days(1)\n#> [1] 365"},{"path":"date-e-tempi.html","id":"riassunto-1","chapter":"16 Date e tempi","heading":"16.4.4 Riassunto","text":"Come scegliere tra durata, periodi e intervalli? Come sempre, scegliete la struttura dati più semplice che risolve il vostro problema. Se vi interessa solo il tempo fisico, usate una durata; se avete bisogno di aggiungere tempi umani, usate un periodo; se avete bisogno di capire quanto è lungo un intervallo unità umane, usate un intervallo.La figura 16.1 riassume le operazioni aritmetiche consentite tra diversi tipi di dati.\nFigure 16.1: allowed arithmetic operations pairs date/time classes.\n","code":""},{"path":"date-e-tempi.html","id":"esercizi-49","chapter":"16 Date e tempi","heading":"16.4.5 Esercizi","text":"Perché c’è mesi() ma non mesi()?Perché c’è mesi() ma non mesi()?Spiegate days(overnight * 1) qualcuno che ha appena iniziato ad imparare R. Come funziona?\nimparare R. Come funziona?Spiegate days(overnight * 1) qualcuno che ha appena iniziato ad imparare R. Come funziona?\nimparare R. Come funziona?Create un vettore di date che dia il primo giorno di ogni mese del 2015.\nCreate un vettore di date che dia il primo giorno di ogni mese\nnell’anno corrente.\nCreate un vettore di date che dia il primo giorno di ogni mese del 2015.Create un vettore di date che dia il primo giorno di ogni mese\nnell’anno corrente.Scrivi una funzione che, dato il tuo compleanno (come data), restituisca\nquanti anni hai anni.Scrivi una funzione che, dato il tuo compleanno (come data), restituisca\nquanti anni hai anni.Perché non può (oggi() %--% (oggi() + anni(1))) / mesi(1) funziona?Perché non può (oggi() %--% (oggi() + anni(1))) / mesi(1) funziona?","code":""},{"path":"date-e-tempi.html","id":"fusi-orari","chapter":"16 Date e tempi","heading":"16.5 Fusi orari","text":"fusi orari sono un argomento enormemente complicato causa della loro interazione con entità geopolitiche. Fortunatamente non abbiamo bisogno di scavare tutti dettagli perché non sono tutti importanti per l’analisi dei dati, ma ci sono alcune sfide che dovremo affrontare di petto.La prima sfida è che nomi quotidiani dei fusi orari tendono ad essere ambigui. Per esempio, se sei americano probabilmente hai familiarità con EST, o Eastern Standard Time. Tuttavia, sia l’Australia che il Canada hanno anche EST! Per evitare confusione, R usa fusi orari standard internazionali IANA. Questi usano uno schema di denominazione coerente “/”, tipicamente nella forma “<continente>/<città>” (ci sono alcune eccezioni perché non tutti paesi si trovano su un continente). Gli esempi includono “America/New_York”, “Europa/Parigi”, e “Pacifico/Auckland”.Ci si potrebbe chiedere perché il fuso orario usa una città, quando tipicamente si pensa ai fusi orari come associati un paese o una regione ’interno di un paese. Questo perché il database IANA deve registrare decenni di regole sui fusi orari. Nel corso dei decenni, paesi cambiano nome (o si separano) abbastanza frequentemente, ma nomi delle città tendono rimanere gli stessi. Un altro problema è che il nome deve riflettere non solo il comportamento attuale, ma anche la storia completa. Per esempio, ci sono fusi orari sia per “America/New_York” che per “America/Detroit”. Queste città usano entrambe l’Eastern Standard Time, ma nel 1969-1972 il Michigan (lo stato cui si trova Detroit), non seguiva il DST, quindi ha bisogno di un nome diverso. Vale la pena leggere il database grezzo dei fusi orari (disponibile http://www.iana.org/time-zones) solo per leggere alcune di queste storie!Potete scoprire quale R pensa che sia il vostro attuale fuso orario con Sys.timezone():(Se R non lo sa, otterrai un NA).E vedere la lista completa di tutti nomi dei fusi orari con OlsonNames():R, il fuso orario è un attributo della data-ora che controlla solo la stampa. Per esempio, questi tre oggetti rappresentano lo stesso istante nel tempo:Puoi verificare che sono lo stesso tempo usando la sottrazione:Se non diversamente specificato, lubridate usa sempre UTC. UTC (Coordinated Universal Time) è il fuso orario standard usato dalla comunità scientifica e approssimativamente equivalente al suo predecessore GMT (Greenwich Mean Time). Non ha DST, il che rende una rappresentazione conveniente per il calcolo. Le operazioni che combinano date-ora, come c(), spesso non includono il fuso orario. questo caso, la data-ora sarà visualizzata nel tuo fuso orario locale:Puoi cambiare il fuso orario due modi:Mantenere l’istante nel tempo lo stesso, e cambiare il modo cui viene visualizzato. Utilizzare questo quando l’istante è corretto, ma si desidera una visualizzazione più naturale.\n\nx4a <- with_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4a\n#> [1] \"2015-06-02 02:30:00 +1030\" \"2015-06-02 02:30:00 +1030\"\n#> [3] \"2015-06-02 02:30:00 +1030\"\nx4a - x4\n#> Time differences secs\n#> [1] 0 0 0\n(Questo illustra anche un’altra sfida dei fusi orari: non sono tutti sfasamenti orari interi!)Mantenere l’istante nel tempo lo stesso, e cambiare il modo cui viene visualizzato. Utilizzare questo quando l’istante è corretto, ma si desidera una visualizzazione più naturale.(Questo illustra anche un’altra sfida dei fusi orari: non sono tutti sfasamenti orari interi!)Cambia l’istante sottostante nel tempo. Usalo quando hai un istante che è stato etichettato con un fuso orario errato, e hai bisogno di correggerlo.\n\nx4b <- force_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4b\n#> [1] \"2015-06-01 12:00:00 +1030\" \"2015-06-01 12:00:00 +1030\"\n#> [3] \"2015-06-01 12:00:00 +1030\"\nx4b - x4\n#> Time differences hours\n#> [1] -14.5 -14.5 -14.5Cambia l’istante sottostante nel tempo. Usalo quando hai un istante che è stato etichettato con un fuso orario errato, e hai bisogno di correggerlo.","code":"\nSys.timezone()\n#> [1] \"UTC\"\nlength(OlsonNames())\n#> [1] 597\nhead(OlsonNames())\n#> [1] \"Africa/Abidjan\"     \"Africa/Accra\"       \"Africa/Addis_Ababa\"\n#> [4] \"Africa/Algiers\"     \"Africa/Asmara\"      \"Africa/Asmera\"\n(x1 <- ymd_hms(\"2015-06-01 12:00:00\", tz = \"America/New_York\"))\n#> [1] \"2015-06-01 12:00:00 EDT\"\n(x2 <- ymd_hms(\"2015-06-01 18:00:00\", tz = \"Europe/Copenhagen\"))\n#> [1] \"2015-06-01 18:00:00 CEST\"\n(x3 <- ymd_hms(\"2015-06-02 04:00:00\", tz = \"Pacific/Auckland\"))\n#> [1] \"2015-06-02 04:00:00 NZST\"\nx1 - x2\n#> Time difference of 0 secs\nx1 - x3\n#> Time difference of 0 secs\nx4 <- c(x1, x2, x3)\nx4\n#> [1] \"2015-06-01 12:00:00 EDT\" \"2015-06-01 12:00:00 EDT\"\n#> [3] \"2015-06-01 12:00:00 EDT\"\nx4a <- with_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4a\n#> [1] \"2015-06-02 02:30:00 +1030\" \"2015-06-02 02:30:00 +1030\"\n#> [3] \"2015-06-02 02:30:00 +1030\"\nx4a - x4\n#> Time differences in secs\n#> [1] 0 0 0\nx4b <- force_tz(x4, tzone = \"Australia/Lord_Howe\")\nx4b\n#> [1] \"2015-06-01 12:00:00 +1030\" \"2015-06-01 12:00:00 +1030\"\n#> [3] \"2015-06-01 12:00:00 +1030\"\nx4b - x4\n#> Time differences in hours\n#> [1] -14.5 -14.5 -14.5"},{"path":"program-intro.html","id":"program-intro","chapter":"17 Introduzione","heading":"17 Introduzione","text":"questa parte del libro, migliorerai le tue abilità di programmazione. La programmazione è un’abilità trasversale necessaria per tutto il lavoro di scienza dei dati: dovete usare un computer per fare scienza dei dati; non potete farlo nella vostra testa, o con carta e penna.La programmazione produce codice, e il codice è uno strumento di comunicazione. Ovviamente il codice dice al computer cosa si vuole che faccia. Ma comunica anche il significato agli altri esseri umani. Pensare al codice come veicolo di comunicazione è importante perché ogni progetto che fate è fondamentalmente collaborativo. Anche se non stai lavorando con altre persone, stai sicuramente lavorando con il futuro! Scrivere codice chiaro è importante modo che gli altri (come futuri voi) possano capire perché avete affrontato un’analisi nel modo cui l’avete fatto. Ciò significa che migliorare nella programmazione significa anche migliorare nella comunicazione. Nel tempo, volete che il vostro codice diventi non solo più facile da scrivere, ma più facile da leggere per gli altri.Scrivere codice è simile molti modi allo scrivere prosa. Un parallelo che trovo particolarmente utile è che entrambi casi la riscrittura è la chiave per la chiarezza. La prima espressione delle vostre idee difficilmente sarà particolarmente chiara, e potreste aver bisogno di riscrivere più volte. Dopo aver risolto una sfida di analisi dei dati, spesso vale la pena guardare il tuo codice e pensare se è ovvio o meno quello che hai fatto. Se passate un po’ di tempo riscrivere il vostro codice mentre le idee sono fresche, potete risparmiare un sacco di tempo più tardi cercando di ricreare ciò che il vostro codice ha fatto. Ma questo non significa che dovreste riscrivere ogni funzione: dovete bilanciare ciò che dovete ottenere ora con il risparmio di tempo nel lungo periodo. (Ma più riscrivete le vostre funzioni e più è probabile che il vostro primo tentativo sia chiaro).Nei seguenti quattro capitoli, imparerete abilità che vi permetteranno sia di affrontare nuovi programmi che di risolvere problemi esistenti con maggiore chiarezza e facilità:[pipes], vi immergerete profondità nel pipe, %>%, e imparerete di più\nsu come funziona, quali sono le alternative e quando non usarlo.[pipes], vi immergerete profondità nel pipe, %>%, e imparerete di più\nsu come funziona, quali sono le alternative e quando non usarlo.Il copia-e-incolla è uno strumento potente, ma si dovrebbe evitare di farlo più di\ndue volte. Ripetere se stessi nel codice è pericoloso perché può facilmente portare\nerrori e incongruenze. Invece, funzioni, imparerete\ncome scrivere funzioni che permettono di estrarre il codice ripetuto modo che\npossa essere facilmente riutilizzato.Il copia-e-incolla è uno strumento potente, ma si dovrebbe evitare di farlo più di\ndue volte. Ripetere se stessi nel codice è pericoloso perché può facilmente portare\nerrori e incongruenze. Invece, funzioni, imparerete\ncome scrivere funzioni che permettono di estrarre il codice ripetuto modo che\npossa essere facilmente riutilizzato.Quando inizierete scrivere funzioni più potenti, avrete bisogno di una solida\nuna solida base nelle strutture di dati di R, fornite da vettori. Dovete padroneggiare\nquattro vettori atomici comuni, le tre importanti classi S3 costruite\nsopra di loro, e capire misteri della lista e del data frame.Quando inizierete scrivere funzioni più potenti, avrete bisogno di una solida\nuna solida base nelle strutture di dati di R, fornite da vettori. Dovete padroneggiare\nquattro vettori atomici comuni, le tre importanti classi S3 costruite\nsopra di loro, e capire misteri della lista e del data frame.Le funzioni estraggono il codice ripetuto, ma spesso è necessario ripetere le\nstesse azioni su input diversi. Avete bisogno di strumenti per l’iterazione che\nvi permettano di fare cose simili più e più volte. Questi strumenti includono cicli \ne la programmazione funzionale, che imparerete [iterazione].Le funzioni estraggono il codice ripetuto, ma spesso è necessario ripetere le\nstesse azioni su input diversi. Avete bisogno di strumenti per l’iterazione che\nvi permettano di fare cose simili più e più volte. Questi strumenti includono cicli \ne la programmazione funzionale, che imparerete [iterazione].","code":""},{"path":"program-intro.html","id":"per-saperne-di-più-1","chapter":"17 Introduzione","heading":"17.1 Per saperne di più","text":"L’obiettivo di questi capitoli è di insegnarvi il minimo di programmazione di cui avete bisogno per praticare la scienza dei dati, che risulta essere una quantità ragionevole. Una volta che avete imparato il materiale questo libro, credo fortemente che dovreste investire ulteriormente nelle vostre capacità di programmazione. Imparare di più sulla programmazione è un investimento lungo termine: non vi ripagherà immediatamente, ma lungo termine vi permetterà di risolvere nuovi problemi più rapidamente, e vi permetterà di riutilizzare le vostre intuizioni dai problemi precedenti nuovi scenari.Per imparare di più è necessario studiare R come un linguaggio di programmazione, non solo un ambiente interattivo per la scienza dei dati. Abbiamo scritto due libri che vi aiuteranno farlo:Hands Programming R,\ndi Garrett Grolemund. Questa è un’introduzione R come linguaggio di programmazione\ned è un ottimo punto di partenza se R è il vostro primo linguaggio di programmazione. Esso\ncopre materiale simile questi capitoli, ma con uno stile diverso e\ndiversi esempi di motivazione (basati sul casinò). È un utile complemento\nse trovate che questi quattro capitoli passano troppo fretta.Hands Programming R,\ndi Garrett Grolemund. Questa è un’introduzione R come linguaggio di programmazione\ned è un ottimo punto di partenza se R è il vostro primo linguaggio di programmazione. Esso\ncopre materiale simile questi capitoli, ma con uno stile diverso e\ndiversi esempi di motivazione (basati sul casinò). È un utile complemento\nse trovate che questi quattro capitoli passano troppo fretta.Advanced R di Hadley Wickham. Questo si immerge nei\ndettagli del linguaggio di programmazione R. Questo è un ottimo punto di partenza se\navete già esperienza di programmazione. È anche un ottimo passo successivo una volta che avete\ninteriorizzato le idee questi capitoli. Potete leggerlo online su\nhttp://adv-r..co.nz.Advanced R di Hadley Wickham. Questo si immerge nei\ndettagli del linguaggio di programmazione R. Questo è un ottimo punto di partenza se\navete già esperienza di programmazione. È anche un ottimo passo successivo una volta che avete\ninteriorizzato le idee questi capitoli. Potete leggerlo online su\nhttp://adv-r..co.nz.","code":""},{"path":"pipe.html","id":"pipe","chapter":"18 Pipe","heading":"18 Pipe","text":"","code":""},{"path":"pipe.html","id":"introduzione-11","chapter":"18 Pipe","heading":"18.1 Introduzione","text":"Le pipe (‘tubi’) sono uno strumento potente per esprimere chiaramente una sequenza di operazioni multiple. Finora le avete usate senza sapere come funzionano o quali sono le alternative. Ora, questo capitolo, è il momento di esplorare le pipe modo più dettagliato. Imparerai le alternative alle pipe, quando non dovresti usare le pipe e alcuni utili strumenti correlati.","code":""},{"path":"pipe.html","id":"prerequisiti-11","chapter":"18 Pipe","heading":"18.1.1 Prerequisiti","text":"Il pipe, %>%, viene dal pacchetto magrittr di Stefan Milton Bache. pacchetti nel tidyverse caricano automaticamente %>% per te, quindi di solito non carichi magrittr esplicitamente. Qui, tuttavia, ci stiamo concentrando sul piping, e non stiamo caricando nessun altro pacchetto, quindi lo caricheremo esplicitamente.","code":"\nlibrary(magrittr)"},{"path":"pipe.html","id":"alternative-di-pipe","chapter":"18 Pipe","heading":"18.2 Alternative di pipe","text":"Lo scopo del pipe è quello di aiutarvi scrivere il codice un modo che sia più facile da leggere e capire. Per vedere perché il pipe è così utile, esploreremo una serie di modi di scrivere lo stesso codice. Usiamo il codice per raccontare la storia di un coniglietto di nome Foo Foo:Il coniglietto Foo Foo\nSaltellava nella foresta\nRaccogliendo topi di campagna\nE li colpiva sulla testaQuesta è una poesia popolare per bambini che è accompagnata da azioni manuali.Inizieremo definendo un oggetto per rappresentare il coniglietto Foo Foo:E useremo una funzione per ogni verbo chiave: hop(), scoop() e bop(). Usando questo oggetto e questi verbi, ci sono (almeno) quattro modi cui potremmo raccontare la storia nel codice:Salvare ogni passo intermedio come un nuovo oggetto.Sovrascrivere l’oggetto originale molte volte.Comporre le funzioni.Usare la pipe.Lavoreremo attraverso ogni approccio, mostrandovi il codice e parlando dei vantaggi e degli svantaggi.","code":"\nfoo_foo <- little_bunny()"},{"path":"pipe.html","id":"passi-intermedi","chapter":"18 Pipe","heading":"18.2.1 Passi intermedi","text":"L’approccio più semplice è salvare ogni passo come un nuovo oggetto:Il principale svantaggio di questa forma è che ti costringe nominare ogni elemento intermedio. Se ci sono nomi naturali, questa è una buona idea, e dovreste farlo. Ma molte volte, come questo esempio, non ci sono nomi naturali, e si aggiungono suffissi numerici per rendere unici nomi. Questo porta due problemi:Il codice è ingombro di nomi poco importantiIl codice è ingombro di nomi poco importantiDevi incrementare attentamente il suffisso su ogni linea.Devi incrementare attentamente il suffisso su ogni linea.Ogni volta che scrivo codice come questo, invariabilmente uso il numero sbagliato su una linea e poi passo 10 minuti grattarmi la testa e cercare di capire cosa è andato storto nel mio codice.Potreste anche preoccuparvi che questo modulo crei molte copie dei vostri dati e occupi molta memoria. Sorprendentemente, non è questo il caso. primo luogo, notate che preoccuparsi proattivamente della memoria non è un modo utile di spendere il vostro tempo: preoccupatevene quando diventa un problema (cioè quando finite la memoria), non prima. secondo luogo, R non è stupido, e condividerà le colonne tra frame di dati, dove possibile. Diamo un’occhiata ad un’effettiva pipeline di manipolazione dei dati cui aggiungiamo una nuova colonna ggplot2::diamonds:La funzione pryr::object_size() dà la memoria occupata da tutti suoi argomenti. risultati sembrano controintuitivi ’inizio:diamonds occupa 3.46 MB,diamonds2 occupa 3.89 MB,diamonds e diamonds2 insieme occupano 3,89 MB!Come può funzionare? Beh, diamonds2 ha 10 colonne comune con diamonds: non c’è bisogno di duplicare tutti quei dati, quindi due data frame hanno variabili comune. Queste variabili vengono copiate solo se si modifica una di esse. Nell’esempio seguente, modifichiamo un singolo valore diamonds$carat. Ciò significa che la variabile carat non può più essere condivisa tra due frame di dati e deve essere fatta una copia. La dimensione di ogni data frame è invariata, ma la dimensione collettiva aumenta:(Si noti che qui usiamo pryr::object_size(), non il built-object.size(). La funzione object.size() prende solo un singolo oggetto quindi non può calcolare come dati sono condivisi tra più oggetti).","code":"\nfoo_foo_1 <- hop(foo_foo, through = forest)\nfoo_foo_2 <- scoop(foo_foo_1, up = field_mice)\nfoo_foo_3 <- bop(foo_foo_2, on = head)\ndiamonds <- ggplot2::diamonds\ndiamonds2 <- diamonds %>% \n  dplyr::mutate(price_per_carat = price / carat)\n\npryr::object_size(diamonds)\n#> 3.46 MB\npryr::object_size(diamonds2)\n#> 3.89 MB\npryr::object_size(diamonds, diamonds2)\n#> 3.89 MB\ndiamonds$carat[1] <- NA\npryr::object_size(diamonds)\n#> 3.46 MB\npryr::object_size(diamonds2)\n#> 3.89 MB\npryr::object_size(diamonds, diamonds2)\n#> 4.32 MB"},{"path":"pipe.html","id":"sovrascrivere-loriginale","chapter":"18 Pipe","heading":"18.2.2 Sovrascrivere l’originale","text":"Invece di creare oggetti intermedi ad ogni passo, potremmo sovrascrivere l’oggetto originale:Questo è meno digitare (e meno pensare), quindi hai meno probabilità di fare errori. Tuttavia, ci sono due problemi:Il debugging è doloroso: se fate un errore dovrete rieseguire l’intera\npipeline completa dall’inizio.Il debugging è doloroso: se fate un errore dovrete rieseguire l’intera\npipeline completa dall’inizio.La ripetizione dell’oggetto che viene trasformato (abbiamo scritto foo_foo sei volte!\nvolte!) oscura ciò che sta cambiando su ogni linea.La ripetizione dell’oggetto che viene trasformato (abbiamo scritto foo_foo sei volte!\nvolte!) oscura ciò che sta cambiando su ogni linea.","code":"\nfoo_foo <- hop(foo_foo, through = forest)\nfoo_foo <- scoop(foo_foo, up = field_mice)\nfoo_foo <- bop(foo_foo, on = head)"},{"path":"pipe.html","id":"composizione-di-funzioni","chapter":"18 Pipe","heading":"18.2.3 Composizione di funzioni","text":"Un altro approccio è quello di abbandonare l’assegnazione e semplicemente mettere insieme le chiamate di funzione:Qui lo svantaggio è che si deve leggere dall’interno verso l’esterno, da destra sinistra, e che gli argomenti finiscono per essere molto distanziati (chiamato evocativamente il problema dagwood sandwhich). breve, questo codice è difficile da consumare per un umano.","code":"\nbop(\n  scoop(\n    hop(foo_foo, through = forest),\n    up = field_mice\n  ), \n  on = head\n)"},{"path":"pipe.html","id":"usa-la-pipe","chapter":"18 Pipe","heading":"18.2.4 Usa la pipe","text":"Infine, possiamo usare la pipe:Questa è la mia forma preferita, perché si concentra sui verbi, non sui nomi. Potete leggere questa serie di composizioni di funzioni come se fosse un insieme di azioni imperative. Foo Foo hop, poi scoop, poi bops. L’aspetto negativo, naturalmente, è che dovete avere familiarità con il pipe. Se non avete mai visto %>% prima, non avrete idea di cosa faccia questo codice. Fortunatamente, la maggior parte delle persone capisce l’idea molto velocemente, così quando condividete il vostro codice con altri che non hanno familiarità con la pipe, potete facilmente insegnarglielo.La pipe funziona eseguendo una “trasformazione lessicale”: dietro le quinte, magrittr riassembla il codice nella pipe una forma che funziona sovrascrivendo un oggetto intermedio. Quando si esegue una pipe come quella sopra, magrittr fa qualcosa del genere:Questo significa che la pipe non funziona per due classi di funzioni:1.Funzioni che usano l’ambiente corrente. Per esempio, assign() creerà una nuova variabile con il nome dato nell’ambiente corrente:Funzioni che usano lazy evaluation. R, gli argomenti delle funzioni\nsono calcolati solo quando la funzione li usa, non prima di chiamare la\nfunzione. La pipe calcola ogni elemento turno, quindi non potete\ncontare su questo comportamento.\nUn posto cui questo è un problema è tryCatch(), che vi permette di catturare\ne gestire gli errori:\n\ntryCatch(stop(\"!\"), error = function(e) \"error\")\n#> [1] \"error\"\n\nstop(\"!\") %>% \n  tryCatch(error = function(e) \"error\")\n#> [1] \"error\"\nrelatively wide class functions behaviour,\nincluding try(), suppressMessages(), suppressWarnings()\nbase R.Funzioni che usano lazy evaluation. R, gli argomenti delle funzioni\nsono calcolati solo quando la funzione li usa, non prima di chiamare la\nfunzione. La pipe calcola ogni elemento turno, quindi non potete\ncontare su questo comportamento.Un posto cui questo è un problema è tryCatch(), che vi permette di catturare\ne gestire gli errori:relatively wide class functions behaviour,\nincluding try(), suppressMessages(), suppressWarnings()\nbase R.","code":"\nfoo_foo %>%\n  hop(through = forest) %>%\n  scoop(up = field_mice) %>%\n  bop(on = head)\nmy_pipe <- function(.) {\n  . <- hop(., through = forest)\n  . <- scoop(., up = field_mice)\n  bop(., on = head)\n}\nmy_pipe(foo_foo)```r\nassign(\"x\", 10)\nx\n#> [1] 10\n\n\"x\" %>% assign(100)\nx\n#> [1] 10\n```\n\nL'uso di assign con il pipe non funziona perché lo assegna a \nun ambiente temporaneo usato da `%>%`. Se volete usare l'assegnazione con la\npipe, dovete essere espliciti riguardo all'ambiente:\n\n\n```r\nenv <- environment()\n\"x\" %>% assign(100, envir = env)\nx\n#> [1] 100\n```\n\nAltre funzioni con questo problema sono `get()` e `load()`.\ntryCatch(stop(\"!\"), error = function(e) \"An error\")\n#> [1] \"An error\"\n\nstop(\"!\") %>% \n  tryCatch(error = function(e) \"An error\")\n#> [1] \"An error\""},{"path":"pipe.html","id":"quando-non-usare-la-pipe","chapter":"18 Pipe","heading":"18.3 Quando non usare la pipe","text":"La pipe è uno strumento potente, ma non è l’unico strumento vostra disposizione, e non risolve tutti problemi! Le pipe sono utili soprattutto per riscrivere una sequenza lineare di operazioni abbastanza breve. Penso che dovreste cercare un altro strumento quando:Le vostre pipe sono più lunghe di (diciamo) dieci passi. questo caso, create\noggetti intermedi con nomi significativi. Questo renderà il debug più facile,\nperché potete controllare più facilmente risultati intermedi, e rende\npiù facile capire il vostro codice, perché nomi delle variabili possono aiutare\ncomunicare l’intento.Le vostre pipe sono più lunghe di (diciamo) dieci passi. questo caso, create\noggetti intermedi con nomi significativi. Questo renderà il debug più facile,\nperché potete controllare più facilmente risultati intermedi, e rende\npiù facile capire il vostro codice, perché nomi delle variabili possono aiutare\ncomunicare l’intento.Avete più ingressi o uscite. Se non c’è un oggetto primario\nche viene trasformato, ma due o più oggetti che vengono combinati insieme,\nnon usate la pipe.Avete più ingressi o uscite. Se non c’è un oggetto primario\nche viene trasformato, ma due o più oggetti che vengono combinati insieme,\nnon usate la pipe.State iniziando pensare ad un grafo diretto con una complessa struttura di dipendenza.\nstruttura di dipendenza complessa. Le pipe sono fondamentalmente lineari ed esprimere\nrelazioni complesse con esse produrrà tipicamente codice confuso.State iniziando pensare ad un grafo diretto con una complessa struttura di dipendenza.\nstruttura di dipendenza complessa. Le pipe sono fondamentalmente lineari ed esprimere\nrelazioni complesse con esse produrrà tipicamente codice confuso.","code":""},{"path":"pipe.html","id":"altri-strumenti-di-magrittr","chapter":"18 Pipe","heading":"18.4 Altri strumenti di magrittr","text":"Tutti pacchetti del tidyverse rendono automaticamente disponibile %>%, quindi normalmente non si carica magrittr esplicitamente. Tuttavia, ci sono alcuni altri strumenti utili ’interno di magrittr che potresti voler provare:Quando si lavora con tubi più complessi, volte è utile chiamare una\nfunzione per suoi effetti collaterali. Forse volete stampare l’oggetto corrente\ncorrente, o tracciarlo, o salvarlo su disco. Molte volte, tali funzioni non\nnon restituiscono nulla, terminando effettivamente la pipe.\nPer aggirare questo problema, potete usare la pipe “tee”. %T>% funziona come\n%>% eccetto che restituisce il lato sinistro invece del lato destro\nlato destro. Si chiama “tee” perché è come un tubo letterale forma di T.\n\nrnorm(100) %>%\n  matrix(ncol = 2) %>%\n  plot() %>%\n  str()\n#>  NULL\n\nrnorm(100) %>%\n  matrix(ncol = 2) %T>%\n  plot() %>%\n  str()\n#>  num [1:50, 1:2] -0.387 -0.785 -1.057 -0.796 -1.756 ...\nQuando si lavora con tubi più complessi, volte è utile chiamare una\nfunzione per suoi effetti collaterali. Forse volete stampare l’oggetto corrente\ncorrente, o tracciarlo, o salvarlo su disco. Molte volte, tali funzioni non\nnon restituiscono nulla, terminando effettivamente la pipe.Per aggirare questo problema, potete usare la pipe “tee”. %T>% funziona come\n%>% eccetto che restituisce il lato sinistro invece del lato destro\nlato destro. Si chiama “tee” perché è come un tubo letterale forma di T.Se state lavorando con funzioni che non hanno un’API basata su data frame\n(cioè gli passate singoli vettori, non un frame di dati ed espressioni\nda valutare nel contesto di quel frame di dati), potreste trovare %$%\nutile. Esso “esplode” le variabili un frame di dati modo che possiate\nriferirsi ad esse modo esplicito. Questo è utile quando si lavora con molte funzioni\nR di base:\n\nmtcars %$%\n  cor(disp, mpg)\n#> [1] -0.8475514Se state lavorando con funzioni che non hanno un’API basata su data frame\n(cioè gli passate singoli vettori, non un frame di dati ed espressioni\nda valutare nel contesto di quel frame di dati), potreste trovare %$%\nutile. Esso “esplode” le variabili un frame di dati modo che possiate\nriferirsi ad esse modo esplicito. Questo è utile quando si lavora con molte funzioni\nR di base:Per l’assegnazione magrittr fornisce l’operatore %<>% che permette di\nsostituire il codice come:\n\nmtcars <- mtcars %>% \n  transform(cyl = cyl * 2)\ncon\n\nmtcars %<>% transform(cyl = cyl * 2)\nNon sono un fan di questo operatore perché penso che l’assegnazione sia un’operazione così\nspeciale che dovrebbe essere sempre chiaro quando avviene.\nSecondo , un po’ di duplicazione (cioè ripetere il\nnome dell’oggetto due volte) va bene per rendere l’assegnazione\npiù esplicito.Per l’assegnazione magrittr fornisce l’operatore %<>% che permette di\nsostituire il codice come:conNon sono un fan di questo operatore perché penso che l’assegnazione sia un’operazione così\nspeciale che dovrebbe essere sempre chiaro quando avviene.\nSecondo , un po’ di duplicazione (cioè ripetere il\nnome dell’oggetto due volte) va bene per rendere l’assegnazione\npiù esplicito.","code":"\nrnorm(100) %>%\n  matrix(ncol = 2) %>%\n  plot() %>%\n  str()\n#>  NULL\n\nrnorm(100) %>%\n  matrix(ncol = 2) %T>%\n  plot() %>%\n  str()\n#>  num [1:50, 1:2] -0.387 -0.785 -1.057 -0.796 -1.756 ...\nmtcars %$%\n  cor(disp, mpg)\n#> [1] -0.8475514\nmtcars <- mtcars %>% \n  transform(cyl = cyl * 2)\nmtcars %<>% transform(cyl = cyl * 2)"},{"path":"funzioni.html","id":"funzioni","chapter":"19 Funzioni","heading":"19 Funzioni","text":"","code":""},{"path":"funzioni.html","id":"introduzione-12","chapter":"19 Funzioni","heading":"19.1 Introduzione","text":"Uno dei modi migliori per migliorare il proprio raggio d’azione come scienziato dei dati è scrivere funzioni. Le funzioni permettono di automatizzare compiti comuni un modo più potente e generale del copia-e-incolla. Scrivere una funzione ha tre grandi vantaggi rispetto al copia-e-incolla:Potete dare ad una funzione un nome evocativo che rende il vostro codice più facile da\ncapire.Potete dare ad una funzione un nome evocativo che rende il vostro codice più facile da\ncapire.Quando requisiti cambiano, hai solo bisogno di aggiornare il codice un posto, invece di\ninvece che molti.Quando requisiti cambiano, hai solo bisogno di aggiornare il codice un posto, invece di\ninvece che molti.Si elimina la possibilità di fare errori accidentali quando si copia e\nincollare (cioè aggiornare un nome di variabile un posto, ma non un altro).Si elimina la possibilità di fare errori accidentali quando si copia e\nincollare (cioè aggiornare un nome di variabile un posto, ma non un altro).Scrivere buone funzioni è un viaggio lungo una vita. Anche dopo aver usato R per molti anni, imparo ancora nuove tecniche e modi migliori di affrontare vecchi problemi. L’obiettivo di questo capitolo non è quello di insegnarvi ogni dettaglio esoterico delle funzioni, ma di farvi iniziare con alcuni consigli pragmatici che potete applicare immediatamente.Oltre consigli pratici per scrivere funzioni, questo capitolo vi dà anche alcuni suggerimenti su come stilizzare il vostro codice. Un buono stile del codice è come una corretta punteggiatura. Si può gestire anche senza, ma di sicuro rende le cose più facili da leggere! Come per gli stili di punteggiatura, ci sono molte possibili variazioni. Qui presentiamo lo stile che usiamo nel nostro codice, ma la cosa più importante è essere coerenti.","code":""},{"path":"funzioni.html","id":"prerequisiti-12","chapter":"19 Funzioni","heading":"19.1.1 Prerequisiti","text":"L’obiettivo di questo capitolo è scrivere funzioni R base, quindi non avrete bisogno di altri pacchetti.","code":""},{"path":"funzioni.html","id":"quando-dovreste-scrivere-una-funzione","chapter":"19 Funzioni","heading":"19.2 Quando dovreste scrivere una funzione?","text":"Dovreste considerare di scrivere una funzione ogni volta che avete copiato e incollato un blocco di codice più di due volte (cioè ora avete tre copie dello stesso codice). Per esempio, date un’occhiata questo codice. Cosa fa?Potreste essere grado di capire che questo ridimensiona ogni colonna per avere un intervallo da 0 1. Ma avete notato l’errore? Ho fatto un errore quando ho copiato e incollato il codice per df$b: Ho dimenticato di cambiare una con una b. Estrarre il codice ripetuto una funzione è una buona idea perché ti impedisce di fare questo tipo di errore.Per scrivere una funzione devi prima analizzare il codice. Quanti input ha?Questo codice ha solo un input: df$. (Se siete sorpresi che TRUE non sia un input, potete esplorare il perché nell’esercizio seguente). Per rendere gli input più chiari, è una buona idea riscrivere il codice usando variabili temporanee con nomi generici. Qui questo codice richiede solo un singolo vettore numerico, quindi lo chiamerò x:C’è qualche duplicazione questo codice. Stiamo calcolando l’intervallo dei dati tre volte, quindi ha senso farlo un solo passo:Tirare fuori calcoli intermedi variabili con nome è una buona pratica perché rende più chiaro cosa sta facendo il codice. Ora che ho semplificato il codice e controllato che funzioni ancora, posso trasformarlo una funzione:Ci sono tre passi chiave per creare una nuova funzione:Dovete scegliere un nome per la funzione. Qui ho usato rescale01.\nperché questa funzione ridimensiona un vettore per farlo stare tra 0 e 1.Dovete scegliere un nome per la funzione. Qui ho usato rescale01.\nperché questa funzione ridimensiona un vettore per farlo stare tra 0 e 1.Si elencano gli input, o argomenti, alla funzione ’interno di function.\nQui abbiamo solo un argomento. Se ne avessimo di più, la chiamata sarebbe come\nfunzione(x, y, z).Si elencano gli input, o argomenti, alla funzione ’interno di function.\nQui abbiamo solo un argomento. Se ne avessimo di più, la chiamata sarebbe come\nfunzione(x, y, z).Mettete il codice che avete sviluppato corpo della funzione, un blocco\n{ blocco che segue immediatamente la funzione(...).Mettete il codice che avete sviluppato corpo della funzione, un blocco\n{ blocco che segue immediatamente la funzione(...).Notate il processo generale: Ho creato la funzione solo dopo aver capito come farla funzionare con un semplice input. È più facile iniziare con del codice funzionante e trasformarlo una funzione; è più difficile creare una funzione e poi cercare di farla funzionare.questo punto è una buona idea controllare la vostra funzione con alcuni input diversi:Man mano che scrivete sempre più funzioni, alla fine vorrete convertire questi test informali e interattivi test formali e automatizzati. Questo processo è chiamato test delle unità. Sfortunatamente, va oltre lo scopo di questo libro, ma potete impararlo http://r-pkgs..co.nz/tests.html.Possiamo semplificare l’esempio originale ora che abbiamo una funzione:Rispetto ’originale, questo codice è più facile da capire e abbiamo eliminato una classe di errori di copia e incolla. C’è ancora un bel po’ di duplicazione poiché stiamo facendo la stessa cosa più colonne. Impareremo come eliminare questa duplicazione [iterazione], una volta che avrete imparato di più sulle strutture dati di R vettori.Un altro vantaggio delle funzioni è che se nostri requisiti cambiano, dobbiamo fare il cambiamento solo un posto. Per esempio, potremmo scoprire che alcune delle nostre variabili includono valori infiniti, e rescale01() fallisce:Poiché abbiamo estratto il codice una funzione, abbiamo solo bisogno di fare la correzione un posto:Questa è una parte importante del principio “non ripetersi” (o DRY, ‘Repeat ’). Più ripetizioni avete nel vostro codice, più posti dovete ricordarvi di aggiornare quando le cose cambiano (e cambiano sempre!), e più è probabile che creiate bug nel tempo.","code":"\ndf <- tibble::tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) / \n  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) / \n  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) / \n  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\n(df$a - min(df$a, na.rm = TRUE)) /\n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\nx <- df$a\n(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n#>  [1] 0.2892677 0.7509271 0.0000000 0.6781686 0.8530656 1.0000000 0.1716402\n#>  [8] 0.6107464 0.6116181 0.6008793\nrng <- range(x, na.rm = TRUE)\n(x - rng[1]) / (rng[2] - rng[1])\n#>  [1] 0.2892677 0.7509271 0.0000000 0.6781686 0.8530656 1.0000000 0.1716402\n#>  [8] 0.6107464 0.6116181 0.6008793\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\nrescale01(c(0, 5, 10))\n#> [1] 0.0 0.5 1.0\nrescale01(c(-10, 0, 10))\n#> [1] 0.0 0.5 1.0\nrescale01(c(1, 2, 3, NA, 5))\n#> [1] 0.00 0.25 0.50   NA 1.00\ndf$a <- rescale01(df$a)\ndf$b <- rescale01(df$b)\ndf$c <- rescale01(df$c)\ndf$d <- rescale01(df$d)\nx <- c(1:10, Inf)\nrescale01(x)\n#>  [1]   0   0   0   0   0   0   0   0   0   0 NaN\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE, finite = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\nrescale01(x)\n#>  [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n#>  [8] 0.7777778 0.8888889 1.0000000       Inf"},{"path":"funzioni.html","id":"esercizi-50","chapter":"19 Funzioni","heading":"19.2.1 Esercizi","text":"Perché TRUE non è un parametro di rescale01()? 2. Cosa accadrebbe se x contenesse un singolo valore mancante e na.rm fosse FALSE?Perché TRUE non è un parametro di rescale01()? 2. Cosa accadrebbe se x contenesse un singolo valore mancante e na.rm fosse FALSE?Nella seconda variante di rescale01(), valori infiniti sono lasciati invariati. Riscrivi rescale01() modo che -Inf sia mappato 0, e Inf sia mappato 1.Nella seconda variante di rescale01(), valori infiniti sono lasciati invariati. Riscrivi rescale01() modo che -Inf sia mappato 0, e Inf sia mappato 1.Esercitatevi trasformare seguenti frammenti di codice funzioni. Pensate cosa fa ogni funzione. Come la chiameresti? Di quanti argomenti ha bisogno? Puoi riscriverla per essere più espressiva o meno duplicata?\n\nmean(.na(x))\n\nx / sum(x, na.rm = TRUE)\n\nsd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)Esercitatevi trasformare seguenti frammenti di codice funzioni. Pensate cosa fa ogni funzione. Come la chiameresti? Di quanti argomenti ha bisogno? Puoi riscriverla per essere più espressiva o meno duplicata?scrivi le tue funzioni per calcolare la varianza e l’asimmetria di un vettore numerico.\nLa varianza è definita come\n\\[\n\\mathrm{Var}(x) = \\frac{1}{n - 1} \\sum_{=1}^n (x_i - \\bar{x}) ^2 \\testo{,}\n\\]\ndove \\(bar{x} = (\\sum_i^n x_i) / n\\) è la media del campione.\nL’asimmetria è definita come\n\\[\n\\mathrm{Skew}(x) = \\frac{frac{1}{n-2}\\sinistra(\\sum_{=1}^n(x_i - \\bar x)^3\\destra)}{mathrm{Var}(x)^{3/2} \\testo{.}\n\\]scrivi le tue funzioni per calcolare la varianza e l’asimmetria di un vettore numerico.\nLa varianza è definita come\n\\[\n\\mathrm{Var}(x) = \\frac{1}{n - 1} \\sum_{=1}^n (x_i - \\bar{x}) ^2 \\testo{,}\n\\]\ndove \\(bar{x} = (\\sum_i^n x_i) / n\\) è la media del campione.\nL’asimmetria è definita come\n\\[\n\\mathrm{Skew}(x) = \\frac{frac{1}{n-2}\\sinistra(\\sum_{=1}^n(x_i - \\bar x)^3\\destra)}{mathrm{Var}(x)^{3/2} \\testo{.}\n\\]Scrivere both_na(), una funzione che prende due vettori della stessa lunghezza\ne restituisce il numero di posizioni che hanno un NA entrambi vettori.Scrivere both_na(), una funzione che prende due vettori della stessa lunghezza\ne restituisce il numero di posizioni che hanno un NA entrambi vettori.Cosa fanno le seguenti funzioni? Perché sono utili anche se sono\nsono così corte?\n\nis_directory <- function(x) file.info(x)$isdir\nis_readable <- function(x) file.access(x, 4) == 0Cosa fanno le seguenti funzioni? Perché sono utili anche se sono\nsono così corte?Leggi il testo completo\ndi “Little Bunny Foo Foo”. Ci sono molti doppioni questa canzone.\nEstendete l’esempio iniziale di piping per ricreare la canzone completa, e usate\nfunzioni per ridurre la duplicazione.Leggi il testo completo\ndi “Little Bunny Foo Foo”. Ci sono molti doppioni questa canzone.\nEstendete l’esempio iniziale di piping per ricreare la canzone completa, e usate\nfunzioni per ridurre la duplicazione.","code":"\nmean(is.na(x))\n\nx / sum(x, na.rm = TRUE)\n\nsd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)\nis_directory <- function(x) file.info(x)$isdir\nis_readable <- function(x) file.access(x, 4) == 0"},{"path":"funzioni.html","id":"le-funzioni-sono-per-gli-umani-e-per-i-computer","chapter":"19 Funzioni","heading":"19.3 Le funzioni sono per gli umani e per i computer","text":"È importante ricordare che le funzioni non sono solo per il computer, ma anche per gli esseri umani. R non interessa come viene chiamata la vostra funzione, o quali commenti contiene, ma questi sono importanti per lettori umani. Questa sezione discute alcune cose che dovreste tenere mente quando scrivete funzioni che gli umani possano capire.Il nome di una funzione è importante. Idealmente, il nome della vostra funzione sarà breve, ma evocherà chiaramente ciò che la funzione fa. Questo è difficile! Ma è meglio essere chiari che brevi, poiché il completamento automatico di RStudio rende facile digitare nomi lunghi.generale, nomi delle funzioni dovrebbero essere verbi, e gli argomenti dovrebbero essere sostantivi. Ci sono alcune eccezioni: sostantivi vanno bene se la funzione calcola un sostantivo molto noto (ad esempio mean() è meglio di compute_mean()), o accede qualche proprietà di un oggetto (ad esempio coef() è meglio di get_coefficients()). Un buon segno che un sostantivo potrebbe essere una scelta migliore è se state usando un verbo molto ampio come “get”, “compute”, “calculate”, o “determine”. Usate il vostro miglior giudizio e non abbiate paura di rinominare una funzione se trovate un nome migliore seguito.Se il nome della vostra funzione è composto da più parole, vi consiglio di usare “snake_case”, dove ogni parola minuscola è separata da un underscore. camelCase è un’alternativa popolare. Non importa quale scegliete, l’importante è essere coerenti: scegliete uno o l’altro e mantenetelo. R stesso non è molto coerente, ma non puoi farci niente. Assicuratevi di non cadere nella stessa trappola rendendo il vostro codice il più coerente possibile.Se avete una famiglia di funzioni che fanno cose simili, assicuratevi che abbiano nomi e argomenti coerenti. Usate un prefisso comune per indicare che sono collegate. Questo è meglio di un suffisso comune perché il completamento automatico vi permette di digitare il prefisso e vedere tutti membri della famiglia.Un buon esempio di questo design è il pacchetto stringr: se non ricordate esattamente quale funzione vi serve, potete digitare str_ e rinfrescarvi la memoria.Dove possibile, evitate di sovrascrivere funzioni e variabili esistenti. E’ impossibile farlo generale perché tanti buoni nomi sono già presi da altri pacchetti, ma evitare nomi più comuni da R base eviterà la confusione.Usate commenti, linee che iniziano con #, per spiegare il “perché” del vostro codice. Generalmente dovreste evitare commenti che spiegano il “cosa” o il “come”. Se non riesci capire cosa fa il codice leggendolo, dovresti pensare come riscriverlo per essere più chiaro. Avete bisogno di aggiungere alcune variabili intermedie con nomi utili? Avete bisogno di separare un sottocomponente di una grande funzione modo da poterle dare un nome? Tuttavia, il vostro codice non può mai catturare il ragionamento dietro le vostre decisioni: perché avete scelto questo approccio invece di un’alternativa? Cos’altro avete provato che non ha funzionato? È una grande idea catturare questo tipo di pensiero un commento.Un altro uso importante dei commenti è quello di spezzare il tuo file pezzi facilmente leggibili. Usate lunghe linee di - e = per rendere facile individuare le interruzioni.RStudio fornisce una scorciatoia da tastiera per creare queste intestazioni (Cmd/Ctrl + Shift + R), e le mostrerà nel drop-di navigazione del codice basso sinistra dell’editor:","code":"\n# Troppo corto\nf()\n\n# Non è un verbo, o descrittivo\nmy_awesome_function()\n\n# Lungo, ma chiaro\nimpute_missing()\ncollapse_years()\n# Non farlo mai!\ncol_mins <- function(x, y) {}\nrowMaxes <- function(y, x) {}\n# Buono\ninput_select()\ninput_checkbox()\ninput_text()\n\n# Non così buono\nselect_input()\ncheckbox_input()\ntext_input()\n# Non fatelo!\nT <- FALSE\nc <- 10\nmean <- function(x) sum(x)\n# Load data --------------------------------------\n\n# Plot data --------------------------------------"},{"path":"funzioni.html","id":"esercizi-51","chapter":"19 Funzioni","heading":"19.3.1 Esercizi","text":"Leggete il codice sorgente di ciascuna delle tre funzioni seguenti, fate un puzzle di ciò che fanno, e poi fate un brainstorming di nomi migliori.\n\nf1 <- function(string, prefix) {\n  substr(string, 1, nchar(prefix)) == prefix\n}\nf2 <- function(x) {\n  (length(x) <= 1) return(NULL)\n  x[-length(x)]\n}\nf3 <- function(x, y) {\n  rep(y, length.= length(x))\n}Leggete il codice sorgente di ciascuna delle tre funzioni seguenti, fate un puzzle di ciò che fanno, e poi fate un brainstorming di nomi migliori.Prendi una funzione che hai scritto recentemente e spendi 5 minuti\nper trovare un nome migliore per essa e per suoi argomenti.Prendi una funzione che hai scritto recentemente e spendi 5 minuti\nper trovare un nome migliore per essa e per suoi argomenti.Confrontate e contrastate rnorm() e MASS::mvrnorm(). Come potreste renderli\npiù coerenti?Confrontate e contrastate rnorm() e MASS::mvrnorm(). Come potreste renderli\npiù coerenti?Spiegate perché norm_r(), norm_d() ecc. sarebbero meglio di\nrnorm(), dnorm(). 2. Inventa un caso per il contrario.Spiegate perché norm_r(), norm_d() ecc. sarebbero meglio di\nrnorm(), dnorm(). 2. Inventa un caso per il contrario.","code":"\nf1 <- function(string, prefix) {\n  substr(string, 1, nchar(prefix)) == prefix\n}\nf2 <- function(x) {\n  if (length(x) <= 1) return(NULL)\n  x[-length(x)]\n}\nf3 <- function(x, y) {\n  rep(y, length.out = length(x))\n}"},{"path":"funzioni.html","id":"esecuzione-condizionale","chapter":"19 Funzioni","heading":"19.4 Esecuzione condizionale","text":"Un’istruzione ti permette di eseguire del codice modo condizionale. Si presenta così:Per avere un aiuto su dovete circondarlo di backtick: ?``. L’aiuto non è particolarmente utile se non sei già un programmatore esperto, ma almeno sai come arrivarci!Ecco una semplice funzione che usa una dichiarazione . L’obiettivo di questa funzione è di restituire un vettore logico che descriva se ogni elemento di un vettore è nominato o meno.Questa funzione sfrutta la regola di ritorno standard: una funzione restituisce l’ultimo valore che ha calcolato. Qui si tratta di uno dei due rami dell’istruzione .","code":"\nif (condition) {\n  # codice eseguito quando la condizione è VERA\n} else {\n  # codice eseguito quando la condizione è FALSA\n}\nhas_name <- function(x) {\n  nms <- names(x)\n  if (is.null(nms)) {\n    rep(FALSE, length(x))\n  } else {\n    !is.na(nms) & nms != \"\"\n  }\n}"},{"path":"funzioni.html","id":"condizioni","chapter":"19 Funzioni","heading":"19.4.1 Condizioni","text":"La condizione deve valutare o TRUE o FALSE. Se è un vettore, avrai un messaggio di avvertimento; se è un NA, avrai un errore. Fai attenzione questi messaggi nel tuo codice:Potete usare || (o) e && (e) per combinare più espressioni logiche. Questi operatori sono “corto circuito”: non appena || vede il primo TRUE restituisce TRUE senza calcolare nient’altro. Non appena && vede il primo FALSE restituisce FALSE. Non dovreste mai usare | o & una dichiarazione : queste sono operazioni vettoriali che si applicano valori multipli (ecco perché le usate filter()). Se avete un vettore logico, potete usare () o () per farlo collassare ad un singolo valore.Fate attenzione quando testate l’uguaglianza. == è vettoriale, il che significa che è facile ottenere più di un output. Controllate che la lunghezza sia già 1, collassate con () o (), o usate la non vettorializzata identical(). identical() è molto rigoroso: restituisce sempre o un singolo TRUE o un singolo FALSE, e non coordina tipi. Questo significa che dovete fare attenzione quando confrontate interi e doppi:Bisogna anche diffidare dei numeri virgola mobile:Usate invece dplyr::near() per confronti, come descritto confronti.E ricordate, x == NA non fa nulla di utile!","code":"\nif (c(TRUE, FALSE)) {}\n\nif (NA) {}\nidentical(0L, 0)\n#> [1] FALSE\nx <- sqrt(2) ^ 2\nx\n#> [1] 2\nx == 2\n#> [1] FALSE\nx - 2\n#> [1] 4.440892e-16"},{"path":"funzioni.html","id":"condizioni-multiple","chapter":"19 Funzioni","heading":"19.4.2 Condizioni multiple","text":"Puoi concatenare più dichiarazioni insieme:Ma se vi ritrovate con una serie molto lunga di dichiarazioni concatenate, dovreste considerare la riscrittura. Una tecnica utile è la funzione switch(). Vi permette di valutare il codice selezionato base alla posizione o al nome.Un’altra funzione utile che spesso può eliminare lunghe catene di istruzioni è cut(). Viene usata per discretizzare le variabili continue.","code":"\nif (this) {\n  # fai quello\n} else if (that) {\n  # fai quell'altro\n} else {\n  # \n}#> function(x, y, op) {\n#>   switch(op,\n#>     plus = x + y,\n#>     minus = x - y,\n#>     times = x * y,\n#>     divide = x / y,\n#>     stop(\"Unknown op!\")\n#>   )\n#> }"},{"path":"funzioni.html","id":"stile-del-codice","chapter":"19 Funzioni","heading":"19.4.3 Stile del codice","text":"Sia che function dovrebbero (quasi) sempre essere seguite da parentesi graffe ({}), e il contenuto dovrebbe essere indentato di due spazi. Questo rende più facile vedere la gerarchia nel tuo codice scorrendo il margine sinistro.Una parentesi graffa di apertura non dovrebbe mai andare sulla propria linea e dovrebbe essere sempre seguita da una nuova linea. Una parentesi graffa di chiusura dovrebbe sempre andare sulla propria riga, meno che non sia seguita da else. Fai sempre rientrare il codice ’interno delle parentesi graffe.Va bene non usare le parentesi graffe se hai una dichiarazione molto breve che può stare su una sola riga:Lo raccomando solo per dichiarazioni molto brevi “”. Altrimenti, la forma completa è più facile da leggere:","code":"# Buono\nif (y < 0 && debug) {\n  message(\"Y is negative\")\n}\n\nif (y == 0) {\n  log(x)\n} else {\n  y ^ x\n}\n\n# Cattivo\nif (y < 0 && debug)\nmessage(\"Y is negative\")\n\nif (y == 0) {\n  log(x)\n} \nelse {\n  y ^ x\n}\ny <- 10\nx <- if (y < 20) \"Too low\" else \"Too high\"\nif (y < 20) {\n  x <- \"Too low\" \n} else {\n  x <- \"Too high\"\n}"},{"path":"funzioni.html","id":"esercizi-52","chapter":"19 Funzioni","heading":"19.4.4 Esercizi","text":"Qual è la differenza tra e ifelse()? Leggete attentamente l’aiuto\ne costruisci tre esempi che illustrino le differenze chiave.Qual è la differenza tra e ifelse()? Leggete attentamente l’aiuto\ne costruisci tre esempi che illustrino le differenze chiave.Scrivi una funzione di saluto che dica “buongiorno”, “buon pomeriggio”,\no “buona sera”, seconda dell’ora del giorno. (Suggerimento: usate un argomento\nche sia predefinito lubridate::now(). Questo renderà\npiù facile testare la vostra funzione).Scrivi una funzione di saluto che dica “buongiorno”, “buon pomeriggio”,\no “buona sera”, seconda dell’ora del giorno. (Suggerimento: usate un argomento\nche sia predefinito lubridate::now(). Questo renderà\npiù facile testare la vostra funzione).Implementare una funzione fizzbuzz. Prende un singolo numero come input. Se\nil numero è divisibile per tre, restituisce “fizz”. Se è divisibile per\ncinque, restituisce “buzz”. Se è divisibile per tre e per cinque, restituisce\n“fizzbuzz”. Altrimenti, restituisce il numero. Assicuratevi di scrivere prima\ncodice funzionante prima di creare la funzione.Implementare una funzione fizzbuzz. Prende un singolo numero come input. Se\nil numero è divisibile per tre, restituisce “fizz”. Se è divisibile per\ncinque, restituisce “buzz”. Se è divisibile per tre e per cinque, restituisce\n“fizzbuzz”. Altrimenti, restituisce il numero. Assicuratevi di scrivere prima\ncodice funzionante prima di creare la funzione.Come potreste usare cut() per semplificare questo insieme di dichiarazioni -else annidate?\n\n(temp <= 0) {\n  \"freezing\"\n} else (temp <= 10) {\n  \"cold\"\n} else (temp <= 20) {\n  \"cool\"\n} else (temp <= 30) {\n  \"warm\"\n} else {\n  \"hot\"\n}\nCome cambierebbe la chiamata cut() se avessi usato < invece di <=?\nQual è l’altro vantaggio principale di cut() per questo problema? (Suggerimento:\ncosa succede se hai molti valori temp?)Come potreste usare cut() per semplificare questo insieme di dichiarazioni -else annidate?Come cambierebbe la chiamata cut() se avessi usato < invece di <=?\nQual è l’altro vantaggio principale di cut() per questo problema? (Suggerimento:\ncosa succede se hai molti valori temp?)Cosa succede se usate switch() con valori numerici?Cosa succede se usate switch() con valori numerici?Cosa fa questa chiamata switch()? 2. Cosa succede se x è “e”?\n\nswitch(x, \n  = ,\n  b = \"ab\",\n  c = ,\n  d = \"cd\"\n)\nSperimentate, poi leggete attentamente la documentazione.Cosa fa questa chiamata switch()? 2. Cosa succede se x è “e”?Sperimentate, poi leggete attentamente la documentazione.","code":"\nif (temp <= 0) {\n  \"freezing\"\n} else if (temp <= 10) {\n  \"cold\"\n} else if (temp <= 20) {\n  \"cool\"\n} else if (temp <= 30) {\n  \"warm\"\n} else {\n  \"hot\"\n}\nswitch(x, \n  a = ,\n  b = \"ab\",\n  c = ,\n  d = \"cd\"\n)"},{"path":"funzioni.html","id":"argomenti-delle-funzioni","chapter":"19 Funzioni","heading":"19.5 Argomenti delle funzioni","text":"Gli argomenti di una funzione rientrano tipicamente due grandi insiemi: un insieme fornisce dati su cui calcolare, e l’altro fornisce argomenti che controllano dettagli del calcolo. Per esempio:log(), dati sono x, e il dettaglio è la base del logaritmo.log(), dati sono x, e il dettaglio è la base del logaritmo.mean(), dati sono x, e dettagli sono quanti dati tagliare\ndalle estremità (trim) e come gestire valori mancanti (na.rm).mean(), dati sono x, e dettagli sono quanti dati tagliare\ndalle estremità (trim) e come gestire valori mancanti (na.rm).t.test(), dati sono x e y, e dettagli del test sono\nalternative, mu, paired, var.equal, e conf.level.t.test(), dati sono x e y, e dettagli del test sono\nalternative, mu, paired, var.equal, e conf.level.str_c() potete fornire qualsiasi numero di stringhe ..., e dettagli\ndella concatenazione sono controllati da sep e collapse.str_c() potete fornire qualsiasi numero di stringhe ..., e dettagli\ndella concatenazione sono controllati da sep e collapse.Generalmente, gli argomenti di dati dovrebbero venire per primi. Gli argomenti di dettaglio dovrebbero andare alla fine, e di solito dovrebbero avere valori predefiniti. Si specifica un valore predefinito nello stesso modo cui si chiama una funzione con un argomento con nome:Il valore di default dovrebbe essere quasi sempre il valore più comune. Le poche eccezioni questa regola hanno che fare con la sicurezza. Per esempio, ha senso che na.rm abbia come valore predefinito FALSE perché valori mancanti sono importanti. Anche se na.rm = TRUE è quello che di solito mettete nel vostro codice, è una cattiva idea ignorare silenziosamente valori mancanti per default.Quando chiamate una funzione, di solito omettete nomi degli argomenti dei dati, perché sono usati così comunemente. Se sovrascrivete il valore predefinito di un argomento di dettaglio, dovreste usare il nome completo:Potete riferirvi ad un argomento con il suo unico prefisso (ad esempio mean(x, n = TRUE)), ma questo è generalmente meglio evitarlo, date le possibilità di confusione.Notate che quando chiamate una funzione, dovreste mettere uno spazio intorno = nelle chiamate di funzione, e mettere sempre uno spazio dopo una virgola, non prima (proprio come nel normale inglese). Usare gli spazi bianchi rende più facile scremare la funzione per componenti importanti.","code":"\n# Calcolare l'intervallo di confidenza intorno alla media usando l'approssimazione normale\nmean_ci <- function(x, conf = 0.95) {\n  se <- sd(x) / sqrt(length(x))\n  alpha <- 1 - conf\n  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))\n}\n\nx <- runif(100)\nmean_ci(x)\n#> [1] 0.4976111 0.6099594\nmean_ci(x, conf = 0.99)\n#> [1] 0.4799599 0.6276105\n# Good\nmean(1:10, na.rm = TRUE)\n\n# Bad\nmean(x = 1:10, , FALSE)\nmean(, TRUE, x = c(1:10, NA))\n# Buono\naverage <- mean(feet / 12 + inches, na.rm = TRUE)\n\n# Cattivo\naverage<-mean(feet/12+inches,na.rm=TRUE)"},{"path":"funzioni.html","id":"scegliere-i-nomi","chapter":"19 Funzioni","heading":"19.5.1 Scegliere i nomi","text":"Anche nomi degli argomenti sono importanti. R non importa, ma ai lettori del vostro codice (compresi futuri voi!) sì. Generalmente dovreste preferire nomi più lunghi e descrittivi, ma ci sono una manciata di nomi molto comuni e molto brevi. Vale la pena memorizzarli:x, y, z: vettori. * w: un vettore di pesi. * df: un data frame. * , j: indici numerici (tipicamente righe e colonne). * n: lunghezza, o numero di righe. * p: numero di colonne.Altrimenti, considerate la corrispondenza dei nomi degli argomenti nelle funzioni R esistenti. Per esempio, usate na.rm per determinare se valori mancanti devono essere rimossi.","code":""},{"path":"funzioni.html","id":"controllo-dei-valori","chapter":"19 Funzioni","heading":"19.5.2 Controllo dei valori","text":"Quando inizierete scrivere più funzioni, alla fine arriverete al punto cui non ricorderete esattamente come funziona la vostra funzione. questo punto è facile chiamare la vostra funzione con input non validi. Per evitare questo problema, è spesso utile rendere espliciti vincoli. Per esempio, immaginate di aver scritto alcune funzioni per calcolare statistiche sommarie ponderate:Cosa succede se x e w non hanno la stessa lunghezza?questo caso, causa delle regole di riciclaggio dei vettori di R, non otteniamo un errore.È buona pratica controllare le precondizioni importanti e lanciare un errore (con stop()), se non sono vere:Fate attenzione non esagerare. C’è un compromesso tra quanto tempo spendete per rendere la vostra funzione robusta e quanto tempo spendete per scriverla. Per esempio, se hai aggiunto anche un argomento na.rm, probabilmente non lo controllerei attentamente:Questo è un sacco di lavoro extra per un piccolo guadagno aggiuntivo. Un utile compromesso è il built-stopifnot(): controlla che ogni argomento sia TRUE, e produce un generico messaggio di errore caso contrario.Si noti che quando si usa stopifnot() si afferma ciò che dovrebbe essere vero piuttosto che controllare ciò che potrebbe essere sbagliato.","code":"\nwt_mean <- function(x, w) {\n  sum(x * w) / sum(w)\n}\nwt_var <- function(x, w) {\n  mu <- wt_mean(x, w)\n  sum(w * (x - mu) ^ 2) / sum(w)\n}\nwt_sd <- function(x, w) {\n  sqrt(wt_var(x, w))\n}\nwt_mean(1:6, 1:3)\n#> [1] 7.666667\nwt_mean <- function(x, w) {\n  if (length(x) != length(w)) {\n    stop(\"`x` and `w` must be the same length\", call. = FALSE)\n  }\n  sum(w * x) / sum(w)\n}\nwt_mean <- function(x, w, na.rm = FALSE) {\n  if (!is.logical(na.rm)) {\n    stop(\"`na.rm` must be logical\")\n  }\n  if (length(na.rm) != 1) {\n    stop(\"`na.rm` must be length 1\")\n  }\n  if (length(x) != length(w)) {\n    stop(\"`x` and `w` must be the same length\", call. = FALSE)\n  }\n  \n  if (na.rm) {\n    miss <- is.na(x) | is.na(w)\n    x <- x[!miss]\n    w <- w[!miss]\n  }\n  sum(w * x) / sum(w)\n}\nwt_mean <- function(x, w, na.rm = FALSE) {\n  stopifnot(is.logical(na.rm), length(na.rm) == 1)\n  stopifnot(length(x) == length(w))\n  \n  if (na.rm) {\n    miss <- is.na(x) | is.na(w)\n    x <- x[!miss]\n    w <- w[!miss]\n  }\n  sum(w * x) / sum(w)\n}\nwt_mean(1:6, 6:1, na.rm = \"foo\")\n#> Error in wt_mean(1:6, 6:1, na.rm = \"foo\"): is.logical(na.rm) is not TRUE"},{"path":"funzioni.html","id":"dot-dot-dot","chapter":"19 Funzioni","heading":"19.5.3 Dot-dot-dot (…)","text":"Molte funzioni R accettano un numero arbitrario di input:Come funzionano queste funzioni? Si basano su un argomento speciale: ... (pronunciato dot-dot-dot). Questo argomento speciale cattura qualsiasi numero di argomenti che non sono altrimenti abbinati.È utile perché è possibile inviare questi ... ad un’altra funzione. Questo è un utile catch-se la vostra funzione avvolge principalmente un’altra funzione. Per esempio, di solito creo queste funzioni helper che avvolgono str_c():Qui ... mi permette di inoltrare qualsiasi argomento che non voglio trattare str_c(). È una tecnica molto comoda. Ma ha un prezzo: qualsiasi argomento scritto male non genererà un errore. Questo rende facile che gli errori di battitura passino inosservati:Se volete solo catturare valori del ..., usate list(...).","code":"\nsum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n#> [1] 55\nstringr::str_c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\n#> [1] \"abcdef\"\ncommas <- function(...) stringr::str_c(..., collapse = \", \")\ncommas(letters[1:10])\n#> [1] \"a, b, c, d, e, f, g, h, i, j\"\n\nrule <- function(..., pad = \"-\") {\n  title <- paste0(...)\n  width <- getOption(\"width\") - nchar(title) - 5\n  cat(title, \" \", stringr::str_dup(pad, width), \"\\n\", sep = \"\")\n}\nrule(\"Important output\")\n#> Important output -----------------------------------------------------------\nx <- c(1, 2)\nsum(x, na.mr = TRUE)\n#> [1] 4"},{"path":"funzioni.html","id":"valutazione-pigra-lazy-evaluation","chapter":"19 Funzioni","heading":"19.5.4 Valutazione pigra (lazy evaluation)","text":"Gli argomenti R sono valutati pigramente: non sono calcolati finché non sono necessari. Questo significa che se non sono mai usati, non sono mai chiamati. Questa è un’importante proprietà di R come linguaggio di programmazione, ma generalmente non è importante quando si scrivono le proprie funzioni per l’analisi dei dati. Potete leggere di più sulla valutazione pigra http://adv-r..co.nz/Functions.html#lazy-evaluation.","code":""},{"path":"funzioni.html","id":"esercizi-53","chapter":"19 Funzioni","heading":"19.5.5 Esercizi","text":"Cosa fa commas(letters, collapse = \"-\")? Perché?Cosa fa commas(letters, collapse = \"-\")? Perché?Sarebbe bello se tu potessi fornire più caratteri ’argomento pad,\nper esempio rule(\"Titolo\", pad = \"-+\"). Perché attualmente questo non funziona? Come\nsi potrebbe risolvere?Sarebbe bello se tu potessi fornire più caratteri ’argomento pad,\nper esempio rule(\"Titolo\", pad = \"-+\"). Perché attualmente questo non funziona? Come\nsi potrebbe risolvere?Cosa fa l’argomento trim di mean()? Quando potreste usarlo?Cosa fa l’argomento trim di mean()? Quando potreste usarlo?Il valore predefinito per l’argomento metodo di cor() è\nc(\"pearson\", \"kendall\", \"spearman\"). Cosa significa? Quale\nvalore è usato per default?Il valore predefinito per l’argomento metodo di cor() è\nc(\"pearson\", \"kendall\", \"spearman\"). Cosa significa? Quale\nvalore è usato per default?","code":""},{"path":"funzioni.html","id":"valori-di-ritorno","chapter":"19 Funzioni","heading":"19.6 Valori di ritorno","text":"Capire cosa dovrebbe restituire la vostra funzione è di solito semplice: è il motivo per cui avete creato la funzione primo luogo! Ci sono due cose da considerare quando si restituisce un valore:Restituire anticipo rende la vostra funzione più facile da leggere?Restituire anticipo rende la vostra funzione più facile da leggere?Potete rendere la vostra funzione ‘pipeable’ (usabile con una pipe)?Potete rendere la vostra funzione ‘pipeable’ (usabile con una pipe)?","code":""},{"path":"funzioni.html","id":"dichiarazioni-di-ritorno-esplicite","chapter":"19 Funzioni","heading":"19.6.1 Dichiarazioni di ritorno esplicite","text":"Il valore restituito dalla funzione è di solito l’ultima affermazione che valuta, ma potete scegliere di tornare anticipo usando return(). Penso che sia meglio salvare l’uso di return() per segnalare che si può tornare anticipo con una soluzione più semplice. Una ragione comune per farlo è perché gli input sono vuoti:Un’altra ragione è che avete una dichiarazione con un blocco complesso e un blocco semplice. Per esempio, potreste scrivere un’istruzione come questa:Ma se il primo blocco è molto lungo, quando si arriva al else, si è dimenticata la condizione. Un modo per riscriverlo è usare un ritorno anticipato per il caso semplice:Questo tende rendere il codice più facile da capire, perché non avete bisogno di così tanto contesto per capirlo.","code":"\ncomplicated_function <- function(x, y, z) {\n  if (length(x) == 0 || length(y) == 0) {\n    return(0)\n  }\n    \n  # Codice complicato qui\n}\nf <- function() {\n  if (x) {\n    # fare \n    # qualcosa\n    # che\n    # prende\n    # molte\n    # linee\n    # per \n    # essere\n    # espresso\n  } else {\n    # restituire qualcosa di breve\n  }\n}\n\nf <- function() {\n  if (!x) {\n    return(something_short)\n  }\n\n    # fare \n    # qualcosa\n    # che\n    # prende\n    # molte\n    # linee\n    # per \n    # essere\n    # espresso\n}"},{"path":"funzioni.html","id":"scrivere-funzioni-pipeable-usabili-con-la-pipe","chapter":"19 Funzioni","heading":"19.6.2 Scrivere funzioni ‘pipeable’ (usabili con la pipe)","text":"Se volete scrivere le vostre funzioni pipeable, è importante pensare al valore di ritorno. Conoscere il tipo di oggetto del valore di ritorno significherà che la vostra pipeline “funzionerà”. Per esempio, con dplyr e tidyr il tipo di oggetto è il data frame.Ci sono due tipi base di funzioni pipeable: le trasformazioni e gli effetti collaterali. Con trasformazioni, un oggetto viene passato come primo argomento della funzione e viene restituito un oggetto modificato. Con effetti collaterali, l’oggetto passato non viene trasformato. Invece, la funzione esegue un’azione sull’oggetto, come disegnare una grafico o salvare un file. Le funzioni effetti collaterali dovrebbero restituire “invisibilmente” il primo argomento, modo che mentre non vengono stampate possono ancora essere utilizzate una pipe. Per esempio, questa semplice funzione stampa il numero di valori mancanti un frame di dati:Se lo chiamiamo interattivamente, l’opzione invisible() significa che l’input df non viene stampato:Ma c’è ancora, solo che non è stampato di default:E possiamo ancora usarlo una pipe:","code":"\nshow_missings <- function(df) {\n  n <- sum(is.na(df))\n  cat(\"Missing values: \", n, \"\\n\", sep = \"\")\n  \n  invisible(df)\n}\nshow_missings(mtcars)\n#> Missing values: 0\nx <- show_missings(mtcars) \n#> Missing values: 0\nclass(x)\n#> [1] \"data.frame\"\ndim(x)\n#> [1] 32 11\nmtcars %>% \n  show_missings() %>% \n  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% \n  show_missings() \n#> Missing values: 0\n#> Missing values: 18"},{"path":"funzioni.html","id":"ambiente","chapter":"19 Funzioni","heading":"19.7 Ambiente","text":"L’ultimo componente di una funzione è il suo ambiente. Questo non è qualcosa che dovete capire fondo quando iniziate scrivere funzioni. Tuttavia, è importante conoscere un po’ gli ambienti perché sono cruciali per il funzionamento delle funzioni. L’ambiente di una funzione controlla come R trova il valore associato ad un nome. Per esempio, prendete questa funzione:molti linguaggi di programmazione, questo sarebbe un errore, perché y non è definito ’interno della funzione. R, questo è un codice valido perché R usa delle regole chiamate lexical scoping per trovare il valore associato ad un nome. Poiché y non è definito ’interno della funzione, R cercherà nell’ ambiente dove la funzione è stata definita:Questo comportamento sembra una ricetta per bug, e effetti si dovrebbe evitare di creare deliberatamente funzioni come questa, ma generale non causa troppi problemi (soprattutto se si riavvia regolarmente R per arrivare una tabula rasa).Il vantaggio di questo comportamento è che dal punto di vista del linguaggio permette R di essere molto coerente. Ogni nome viene cercato usando lo stesso insieme di regole. Per f() questo include il comportamento di due cose che potreste non aspettarvi: { e +. Questo vi permette di fare cose subdole come:Questo è un fenomeno comune R. R pone pochi limiti al vostro potere. Potete fare molte cose che non potete fare altri linguaggi di programmazione. Potete fare molte cose che il 99% delle volte sono estremamente sconsigliate (come sovrascrivere il funzionamento dell’addizione!). Ma questa potenza e flessibilità è ciò che rende possibili strumenti come ggplot2 e dplyr. Imparare come usare al meglio questa flessibilità va oltre lo scopo di questo libro, ma si può leggere Advanced R.","code":"\nf <- function(x) {\n  x + y\n} \ny <- 100\nf(10)\n#> [1] 110\n\ny <- 1000\nf(10)\n#> [1] 1010\n`+` <- function(x, y) {\n  if (runif(1) < 0.1) {\n    sum(x, y)\n  } else {\n    sum(x, y) * 1.1\n  }\n}\ntable(replicate(1000, 1 + 2))\n#> \n#>   3 3.3 \n#> 100 900\nrm(`+`)"},{"path":"vettori.html","id":"vettori","chapter":"20 Vettori","heading":"20 Vettori","text":"","code":""},{"path":"vettori.html","id":"introduzione-13","chapter":"20 Vettori","heading":"20.1 Introduzione","text":"Finora questo libro si è concentrato sulle tibble e sui pacchetti che lavorano con esse. Ma quando inizierete scrivere le vostre funzioni e scavare più fondo R, avrete bisogno di imparare vettori, gli oggetti che sono alla base delle tibble. Se avete imparato R modo più tradizionale, probabilmente avete già familiarità con vettori, dato che la maggior parte delle risorse di R inizia con vettori e si fa strada fino alle tibble. Penso che sia meglio iniziare con le tibble perché sono immediatamente utili, e poi lavorare fino ai componenti sottostanti.vettori sono particolarmente importanti perché la maggior parte delle funzioni che scriverete lavoreranno con vettori. È possibile scrivere funzioni che lavorano con le tibbie (come ggplot2, dplyr e tidyr), ma gli strumenti necessari per scrivere tali funzioni sono attualmente idiosincratici e immaturi. Sto lavorando ad un approccio migliore, https://github.com/hadley/lazyeval, ma non sarà pronto tempo per la pubblicazione del libro. Anche quando sarà completo, avrete ancora bisogno di capire vettori, renderà solo più facile scrivere un livello user-friendly sopra.","code":""},{"path":"vettori.html","id":"prerequisiti-13","chapter":"20 Vettori","heading":"20.1.1 Prerequisiti","text":"Il focus di questo capitolo è sulle strutture dati di base di R, quindi non è essenziale caricare alcun pacchetto. Tuttavia, useremo una manciata di funzioni del pacchetto purrr per evitare alcune incongruenze R base.","code":"\nlibrary(tidyverse)"},{"path":"vettori.html","id":"nozioni-di-base-sui-vettori","chapter":"20 Vettori","heading":"20.2 Nozioni di base sui vettori","text":"Ci sono due tipi di vettori:Vettori atomic, di cui esistono sei tipi:\nlogical, integer, double, character, complex, e\nraw. vettori interi e doppi sono conosciuti collettivamente come\nvettori numerici.\nVettori atomic, di cui esistono sei tipi:\nlogical, integer, double, character, complex, e\nraw. vettori interi e doppi sono conosciuti collettivamente come\nvettori numerici.Liste, che volte sono chiamate vettori ricorsivi perché le liste possono contenere altre liste.La differenza principale tra vettori atomici e liste è che vettori atomici sono omogenei, mentre le liste possono essere eterogenee. C’è un altro oggetto correlato: NULL. NULL è spesso usato per rappresentare l’assenza di un vettore (al contrario di NA che è usato per rappresentare l’assenza di un valore un vettore). NULL si comporta tipicamente come un vettore di lunghezza 0. La figura 20.1 riassume le interrelazioni.\nFigure 20.1: hierarchy R’s vector types\nOgni vettore ha due proprietà chiave:Il suo tipo, che potete determinare con typeof().\n\ntypeof(letters)\n#> [1] \"character\"\ntypeof(1:10)\n#> [1] \"integer\"Il suo tipo, che potete determinare con typeof().La sua length, che potete determinare con length().\n\nx <- list(\"\", \"b\", 1:10)\nlength(x)\n#> [1] 3La sua length, che potete determinare con length().vettori possono anche contenere metadati aggiuntivi arbitrari sotto forma di attributi. Questi attributi sono usati per creare vettori aumentati che si basano su comportamenti aggiuntivi. Ci sono tre tipi importanti di vettori aumentati:fattori sono costruiti sopra vettori interi.Date e date-ora sono costruiti sopra vettori numerici.data frame e le tibble sono costruiti sopra le liste.Questo capitolo vi introdurrà questi importanti vettori dal più semplice al più complicato. Inizierete con vettori atomici, poi arriverete alle liste, e finirete con vettori aumentati.","code":"\ntypeof(letters)\n#> [1] \"character\"\ntypeof(1:10)\n#> [1] \"integer\"\nx <- list(\"a\", \"b\", 1:10)\nlength(x)\n#> [1] 3"},{"path":"vettori.html","id":"tipi-importanti-di-vettori-atomici","chapter":"20 Vettori","heading":"20.3 Tipi importanti di vettori atomici","text":"quattro tipi più importanti di vettore atomico sono logico, intero, doppio e carattere. Raw e complex sono usati raramente durante un’analisi dei dati, quindi non li discuterò qui.","code":""},{"path":"vettori.html","id":"logico","chapter":"20 Vettori","heading":"20.3.1 Logico","text":"vettori logici sono il tipo più semplice di vettore atomico perché possono assumere solo tre possibili valori: FALSE, TRUE e NA. vettori logici sono solitamente costruiti con operatori di confronto, come descritto [comparatori]. Puoi anche crearli mano con c():","code":"\n1:10 %% 3 == 0\n#>  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\nc(TRUE, TRUE, FALSE, NA)\n#> [1]  TRUE  TRUE FALSE    NA"},{"path":"vettori.html","id":"numerico","chapter":"20 Vettori","heading":"20.3.2 Numerico","text":"vettori interi e doppi sono conosciuti collettivamente come vettori numerici. R, numeri sono doppi per default. Per fare un intero, metti una L dopo il numero:La distinzione tra interi e double non è solitamente importante, ma ci sono due importanti differenze di cui dovreste essere consapevoli:double sono approssimazioni. double rappresentano numeri virgola mobile che non possono essere sempre rappresentati con precisione con una quantità fissa di memoria. Questo significa che dovreste considerare tutti double come approssimazioni. Per esempio, cos’è il quadrato della radice quadrata di due?\n\nx <- sqrt(2) ^ 2\nx\n#> [1] 2\nx - 2\n#> [1] 4.440892e-16\nQuesto comportamento è comune quando si lavora con numeri virgola mobile: la maggior parte\ncalcoli includono qualche errore di approssimazione. Invece di confrontare numeri virgola mobile\nvirgola mobile usando ==, dovreste usare dplyr::near() che permette\nqualche tolleranza numerica.double sono approssimazioni. double rappresentano numeri virgola mobile che non possono essere sempre rappresentati con precisione con una quantità fissa di memoria. Questo significa che dovreste considerare tutti double come approssimazioni. Per esempio, cos’è il quadrato della radice quadrata di due?Questo comportamento è comune quando si lavora con numeri virgola mobile: la maggior parte\ncalcoli includono qualche errore di approssimazione. Invece di confrontare numeri virgola mobile\nvirgola mobile usando ==, dovreste usare dplyr::near() che permette\nqualche tolleranza numerica.Gli interi hanno un valore speciale: NA, mentre double ne hanno quattro:\nNA, NaN, Inf e -Inf. Tutti e tre valori speciali NaN, Inf e -Inf possono presentarsi durante la divisione:\n\nc(-1, 0, 1) / 0\n#> [1] -Inf  NaN  Inf\nEvita di usare == per controllare questi altri valori speciali. Usate invece le\nfunzioni di aiuto .finite(), .infinite(), e .nan():\n\n0\nInf\nNA\nNaN\n.finite()\nx\n\n\n\n.infinite()\n\nx\n\n\n.na()\n\n\nx\nx\n.nan()\n\n\n\nx\nGli interi hanno un valore speciale: NA, mentre double ne hanno quattro:\nNA, NaN, Inf e -Inf. Tutti e tre valori speciali NaN, Inf e -Inf possono presentarsi durante la divisione:Evita di usare == per controllare questi altri valori speciali. Usate invece le\nfunzioni di aiuto .finite(), .infinite(), e .nan():","code":"\ntypeof(1)\n#> [1] \"double\"\ntypeof(1L)\n#> [1] \"integer\"\n1.5L\n#> [1] 1.5\nx <- sqrt(2) ^ 2\nx\n#> [1] 2\nx - 2\n#> [1] 4.440892e-16\nc(-1, 0, 1) / 0\n#> [1] -Inf  NaN  Inf"},{"path":"vettori.html","id":"carattere","chapter":"20 Vettori","heading":"20.3.3 Carattere","text":"vettori di caratteri sono il tipo più complesso di vettore atomico, perché ogni elemento di un vettore di caratteri è una stringa, e una stringa può contenere una quantità arbitraria di dati.Hai già imparato molto su come lavorare con le stringhe stringhe. Qui volevo menzionare una caratteristica importante dell’implementazione delle stringhe sottostanti: R usa un pool globale di stringhe. Questo significa che ogni stringa unica è immagazzinata memoria solo una volta, e ogni uso della stringa punta quella rappresentazione. Questo riduce la quantità di memoria necessaria alle stringhe duplicate. Potete vedere questo comportamento pratica con pryr::object_size():y non occupa 1000 volte più memoria di x, perché ogni elemento di y è solo un puntatore quella stessa stringa. Un puntatore è di 8 byte, quindi 1000 puntatori una stringa di 152 B sono 8 * 1000 + 152 = 8.14 kB.","code":"\nx <- \"This is a reasonably long string.\"\npryr::object_size(x)\n#> 152 B\n\ny <- rep(x, 1000)\npryr::object_size(y)\n#> 8.14 kB"},{"path":"vettori.html","id":"valori-mancanti-4","chapter":"20 Vettori","heading":"20.3.4 Valori mancanti","text":"Nota che ogni tipo di vettore atomico ha il suo valore mancante:Normalmente non avete bisogno di conoscere questi diversi tipi perché potete sempre usare NA e sarà convertito nel tipo corretto usando le regole di coercizione implicite descritte seguito. Tuttavia, ci sono alcune funzioni che sono rigide riguardo ai loro input, quindi è utile avere questa conoscenza tasca modo da poter essere specifici quando necessario.","code":"\nNA            # logical\n#> [1] NA\nNA_integer_   # integer\n#> [1] NA\nNA_real_      # double\n#> [1] NA\nNA_character_ # character\n#> [1] NA"},{"path":"vettori.html","id":"esercizi-54","chapter":"20 Vettori","heading":"20.3.5 Esercizi","text":"Descrivete la differenza tra .finite(x) e !.infinite(x).Descrivete la differenza tra .finite(x) e !.infinite(x).Leggete il codice sorgente di dplyr::near() (Suggerimento: per vedere il codice sorgente,\neliminate il ()). Come funziona?Leggete il codice sorgente di dplyr::near() (Suggerimento: per vedere il codice sorgente,\neliminate il ()). Come funziona?Un vettore logico può assumere 3 possibili valori. Quanti valori possibili\nvalori possibili può assumere un vettore intero? Quanti valori possibili può assumere\nprendere un double? Usa Google per fare qualche ricerca.Un vettore logico può assumere 3 possibili valori. Quanti valori possibili\nvalori possibili può assumere un vettore intero? Quanti valori possibili può assumere\nprendere un double? Usa Google per fare qualche ricerca.Inventa almeno quattro funzioni che ti permettono di convertire un doppio un\nintero. cosa differiscono? Sii preciso.Inventa almeno quattro funzioni che ti permettono di convertire un doppio un\nintero. cosa differiscono? Sii preciso.Quali funzioni del pacchetto readr ti permettono di trasformare una stringa\nun vettore logico, intero e double?Quali funzioni del pacchetto readr ti permettono di trasformare una stringa\nun vettore logico, intero e double?","code":""},{"path":"vettori.html","id":"usare-i-vettori-atomici","chapter":"20 Vettori","heading":"20.4 Usare i vettori atomici","text":"Ora che hai capito diversi tipi di vettore atomico, è utile rivedere alcuni degli strumenti importanti per lavorare con essi. Questi includono:Come convertire da un tipo ’altro e quando ciò avviene\nautomaticamente.Come convertire da un tipo ’altro e quando ciò avviene\nautomaticamente.Come capire se un oggetto è un tipo specifico di vettore.Come capire se un oggetto è un tipo specifico di vettore.Cosa succede quando si lavora con vettori di diversa lunghezza.Cosa succede quando si lavora con vettori di diversa lunghezza.Come nominare gli elementi di un vettore.Come nominare gli elementi di un vettore.Come estrarre gli elementi di interesse.Come estrarre gli elementi di interesse.","code":""},{"path":"vettori.html","id":"coercizione","chapter":"20 Vettori","heading":"20.4.1 Coercizione","text":"Ci sono due modi per convertire, o coercere, un tipo di vettore un altro:La coercizione esplicita avviene quando si chiama una funzione come .logical(),\n.integer(), .double(), o .character(). Ogni volta che vi trovate\nte di usare la coercizione esplicita, dovresti sempre controllare se è possibile\nfare la correzione monte, modo che il vettore non abbia mai avuto il tipo sbagliato \n’inizio. Per esempio, potrebbe essere necessario modificare la specifica di readr\ncol_types.La coercizione esplicita avviene quando si chiama una funzione come .logical(),\n.integer(), .double(), o .character(). Ogni volta che vi trovate\nte di usare la coercizione esplicita, dovresti sempre controllare se è possibile\nfare la correzione monte, modo che il vettore non abbia mai avuto il tipo sbagliato \n’inizio. Per esempio, potrebbe essere necessario modificare la specifica di readr\ncol_types.La coercizione implicita avviene quando si usa un vettore un contesto specifico\nche si aspetta un certo tipo di vettore. Per esempio, quando usate un vettore logico\nlogico con una funzione di riepilogo numerico, o quando si usa un vettore doppio\ndove ci si aspetta un vettore intero.La coercizione implicita avviene quando si usa un vettore un contesto specifico\nche si aspetta un certo tipo di vettore. Per esempio, quando usate un vettore logico\nlogico con una funzione di riepilogo numerico, o quando si usa un vettore doppio\ndove ci si aspetta un vettore intero.Poiché la coercizione esplicita è usata relativamente raramente, ed è gran parte facile da capire, mi concentrerò sulla coercizione implicita qui.Avete già visto il tipo più importante di coercizione implicita: usare un vettore logico un contesto numerico. questo caso TRUE è convertito 1 e FALSE convertito 0. Ciò significa che la somma di un vettore logico è il numero di veri, e la media di un vettore logico è la proporzione di veri:Potreste vedere del codice (tipicamente più vecchio) che si basa sulla coercizione implicita nella direzione opposta, da intero logico:questo caso, 0 è convertito FALSE e tutto il resto è convertito TRUE. Penso che questo renda più difficile capire il tuo codice, e non lo consiglio. Sii invece esplicito: lunghezza(x) > 0.È anche importante capire cosa succede quando provate creare un vettore contenente più tipi con c(): il tipo più complesso vince sempre.Un vettore atomico non può avere un mix di tipi diversi perché il tipo è una proprietà del vettore completo, non dei singoli elementi. Se hai bisogno di mescolare più tipi nello stesso vettore, dovresti usare una lista, che imparerai conoscere tra poco.","code":"\nx <- sample(20, 100, replace = TRUE)\ny <- x > 10\nsum(y)  # quanti sono maggiori di 10?\n#> [1] 38\nmean(y) # quale proporzione è maggiore di 10?\n#> [1] 0.38\nif (length(x)) {\n  # fa qualcosa\n}\ntypeof(c(TRUE, 1L))\n#> [1] \"integer\"\ntypeof(c(1L, 1.5))\n#> [1] \"double\"\ntypeof(c(1.5, \"a\"))\n#> [1] \"character\""},{"path":"vettori.html","id":"funzioni-di-test","chapter":"20 Vettori","heading":"20.4.2 Funzioni di test","text":"volte vuoi fare cose diverse base al tipo di vettore. Un’opzione è usare typeof(). Un’altra è usare una funzione di test che restituisca un TRUE o un FALSE. Base R fornisce molte funzioni come .vector() e .atomic(), ma spesso restituiscono risultati sorprendenti. Invece, è più sicuro usare le funzioni is_* fornite da purrr, che sono riassunte nella tabella qui sotto.","code":""},{"path":"vettori.html","id":"scalari-e-regole-di-riciclaggio","chapter":"20 Vettori","heading":"20.4.3 Scalari e regole di riciclaggio","text":"Oltre costringere implicitamente tipi di vettori ad essere compatibili, R costringerà implicitamente anche la lunghezza dei vettori. Questo è chiamato riciclo dei vettori, perché il vettore più corto viene ripetuto, o riciclato, alla stessa lunghezza del vettore più lungo.Questo è generalmente più utile quando si mescolano vettori e “scalari”. Ho messo gli scalari tra virgolette perché R realtà non ha scalari: invece, un singolo numero è un vettore di lunghezza 1. Poiché non ci sono scalari, la maggior parte delle funzioni built-sono vettorizzate, il che significa che opereranno su un vettore di numeri. Ecco perché, per esempio, questo codice funziona:R, le operazioni matematiche di base lavorano con vettori. Ciò significa che non dovreste mai aver bisogno di eseguire un’iterazione esplicita quando eseguite semplici calcoli matematici.È intuitivo ciò che dovrebbe accadere se si aggiungono due vettori della stessa lunghezza, o un vettore e uno “scalare”, ma cosa succede se si aggiungono due vettori di lunghezza diversa?Qui, R espanderà il vettore più breve alla stessa lunghezza del più lungo, il cosiddetto riciclo. Questo è silenzioso tranne quando la lunghezza del più lungo non è un multiplo intero della lunghezza del più corto:Mentre il riciclo vettoriale può essere usato per creare codice molto succinto e intelligente, può anche nascondere silenziosamente dei problemi. Per questo motivo, le funzioni vettoriali di tidyverse daranno errore quando si ricicla qualcosa che non sia uno scalare. Se volete riciclare, dovrete farlo voi stessi con rep():","code":"\nsample(10) + 100\n#>  [1] 107 104 103 109 102 101 106 110 105 108\nrunif(10) > 0.5\n#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n1:10 + 1:2\n#>  [1]  2  4  4  6  6  8  8 10 10 12\n1:10 + 1:3\ntibble(x = 1:4, y = 1:2)\n#> Error:\n#> ! Tibble columns must have compatible sizes.\n#> • Size 4: Existing data.\n#> • Size 2: Column `y`.\n#> ℹ Only values of size one are recycled.\n\ntibble(x = 1:4, y = rep(1:2, 2))\n#> # A tibble: 4 × 2\n#>       x     y\n#>   <int> <int>\n#> 1     1     1\n#> 2     2     2\n#> 3     3     1\n#> 4     4     2\n\ntibble(x = 1:4, y = rep(1:2, each = 2))\n#> # A tibble: 4 × 2\n#>       x     y\n#>   <int> <int>\n#> 1     1     1\n#> 2     2     1\n#> 3     3     2\n#> 4     4     2"},{"path":"vettori.html","id":"denominazione-dei-vettori","chapter":"20 Vettori","heading":"20.4.4 Denominazione dei vettori","text":"Tutti tipi di vettori possono essere nominati. Puoi nominarli durante la creazione con c():O dopo averlo fatto, con purrr::set_names():vettori nominati sono molto utili per il subsetting, descritto di seguito.","code":"\nc(x = 1, y = 2, z = 4)\n#> x y z \n#> 1 2 4\nset_names(1:3, c(\"a\", \"b\", \"c\"))\n#> a b c \n#> 1 2 3"},{"path":"vettori.html","id":"vector-subsetting","chapter":"20 Vettori","heading":"20.4.5 Sottoinsiemi","text":"Finora abbiamo usato dplyr::filter() per filtrare le righe una tibla. Il filtro() funziona solo con le tibbie, quindi avremo bisogno di un nuovo strumento per vettori: [. [ è la funzione di sottoinsieme, e si chiama come x[]. Ci sono quattro tipi di cose con cui è possibile subsettare un vettore:Un vettore numerico contenente solo numeri interi. numeri interi devono essere o tutti\npositivi, tutti negativi o zero.\nIl sottoinsieme con numeri interi positivi mantiene gli elementi quelle posizioni:\n\nx <- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#> [1] \"three\" \"two\"   \"five\"\nRipetendo una posizione, si può effettivamente fare un output più lungo dell’input:\n\nx[c(1, 1, 5, 5, 5, 2)]\n#> [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\nvalori negativi fanno cadere gli elementi nelle posizioni specificate:\n\nx[c(-1, -3, -5)]\n#> [1] \"two\"  \"four\"\nÈ un errore mischiare valori positivi e negativi:\n\nx[c(1, -1)]\n#> Error x[c(1, -1)]: 0's may mixed negative subscripts\nIl messaggio di errore menziona il subsetting con zero, che non restituisce alcun valore:\n\nx[0]\n#> character(0)\nQuesto non è utile molto spesso, ma può essere utile se volete creare\nstrutture di dati insolite con cui testare le vostre funzioni.Un vettore numerico contenente solo numeri interi. numeri interi devono essere o tutti\npositivi, tutti negativi o zero.Il sottoinsieme con numeri interi positivi mantiene gli elementi quelle posizioni:Ripetendo una posizione, si può effettivamente fare un output più lungo dell’input:valori negativi fanno cadere gli elementi nelle posizioni specificate:È un errore mischiare valori positivi e negativi:Il messaggio di errore menziona il subsetting con zero, che non restituisce alcun valore:Questo non è utile molto spesso, ma può essere utile se volete creare\nstrutture di dati insolite con cui testare le vostre funzioni.Il sottoinsieme con un vettore logico mantiene tutti valori corrispondenti ad un\nvalore TRUE. Questo è più spesso utile combinazione con le\nfunzioni di confronto.\n\nx <- c(10, 3, NA, 5, 8, 1, NA)\n\n# Tutti valori non mancanti di x\nx[!.na(x)]\n#> [1] 10  3  5  8  1\n\n# Tutti valori pari (o mancanti!) di x\nx[x %% 2 == 0]\n#> [1] 10 NA  8 NAIl sottoinsieme con un vettore logico mantiene tutti valori corrispondenti ad un\nvalore TRUE. Questo è più spesso utile combinazione con le\nfunzioni di confronto.Se avete un vettore di nome, potete sottoinvestirlo con un vettore di caratteri:\n\nx <- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#> xyz def \n#>   5   2\nCome con gli interi positivi, potete anche usare un vettore di caratteri per\nduplicare singole voci.Se avete un vettore di nome, potete sottoinvestirlo con un vettore di caratteri:Come con gli interi positivi, potete anche usare un vettore di caratteri per\nduplicare singole voci.Il tipo più semplice di sottoinsieme è il nulla, x[], che restituisce il\ncompleto x. Questo non è utile per il sottoinsieme di vettori, ma è utile\nquando si sottopongono matrici (e altre strutture ad alta dimensione) perché\npermette di selezionare tutte le righe o tutte le colonne, lasciando\nindice vuoto. Per esempio, se x è 2d, x[1, ] seleziona la prima riga e\ntutte le colonne, e x[, -1] seleziona tutte le righe e tutte le colonne tranne\nla prima.Il tipo più semplice di sottoinsieme è il nulla, x[], che restituisce il\ncompleto x. Questo non è utile per il sottoinsieme di vettori, ma è utile\nquando si sottopongono matrici (e altre strutture ad alta dimensione) perché\npermette di selezionare tutte le righe o tutte le colonne, lasciando\nindice vuoto. Per esempio, se x è 2d, x[1, ] seleziona la prima riga e\ntutte le colonne, e x[, -1] seleziona tutte le righe e tutte le colonne tranne\nla prima.Per saperne di più sulle applicazioni del subsetting, leggete il capitolo “Subsetting” di Advanced R: http://adv-r..co.nz/Subsetting.html#applications.C’è un’importante variazione di [ chiamata [[. [[ estrae sempre e solo un singolo elemento, e abbandona sempre nomi. È una buona idea usarla ogni volta che volete rendere chiaro che state estraendo un singolo elemento, come un ciclo . La distinzione tra [ e [[ è più importante per le liste, come vedremo tra poco.","code":"\nx <- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx[c(3, 2, 5)]\n#> [1] \"three\" \"two\"   \"five\"\nx[c(1, 1, 5, 5, 5, 2)]\n#> [1] \"one\"  \"one\"  \"five\" \"five\" \"five\" \"two\"\nx[c(-1, -3, -5)]\n#> [1] \"two\"  \"four\"\nx[c(1, -1)]\n#> Error in x[c(1, -1)]: only 0's may be mixed with negative subscripts\nx[0]\n#> character(0)\nx <- c(10, 3, NA, 5, 8, 1, NA)\n\n# Tutti i valori non mancanti di x\nx[!is.na(x)]\n#> [1] 10  3  5  8  1\n\n# Tutti i valori pari (o mancanti!) di x\nx[x %% 2 == 0]\n#> [1] 10 NA  8 NA\nx <- c(abc = 1, def = 2, xyz = 5)\nx[c(\"xyz\", \"def\")]\n#> xyz def \n#>   5   2"},{"path":"vettori.html","id":"esercizi-55","chapter":"20 Vettori","heading":"20.4.6 Esercizi","text":"Cosa ti dice il mean(.na(x)) di un vettore x? 2. Che dire di\nsum(!.finite(x))?Cosa ti dice il mean(.na(x)) di un vettore x? 2. Che dire di\nsum(!.finite(x))?Leggete attentamente la documentazione di .vector(). Cosa verifica effettivamente\nverifica? Perché .atomic() non concorda con la definizione di\nvettori atomici di cui sopra?Leggete attentamente la documentazione di .vector(). Cosa verifica effettivamente\nverifica? Perché .atomic() non concorda con la definizione di\nvettori atomici di cui sopra?Confronta e contrasta setNames() con purrr::set_names().Confronta e contrasta setNames() con purrr::set_names().Creare funzioni che prendono un vettore come input e restituiscono:\nL’ultimo valore. Dovreste usare [ o [[?\nGli elementi nelle posizioni pari.\nOgni elemento tranne l’ultimo valore.\nSolo numeri pari (e nessun valore mancante).\nCreare funzioni che prendono un vettore come input e restituiscono:L’ultimo valore. Dovreste usare [ o [[?L’ultimo valore. Dovreste usare [ o [[?Gli elementi nelle posizioni pari.Gli elementi nelle posizioni pari.Ogni elemento tranne l’ultimo valore.Ogni elemento tranne l’ultimo valore.Solo numeri pari (e nessun valore mancante).Solo numeri pari (e nessun valore mancante).Perché x[-che(x > 0)]non è lo stesso di x[x <= 0]?Perché x[-che(x > 0)]non è lo stesso di x[x <= 0]?Cosa succede quando si sottoinveste con un numero intero positivo più grande\ndella lunghezza del vettore? Cosa succede quando si effettua un sottoinsieme con un\nnome che non esiste?Cosa succede quando si sottoinveste con un numero intero positivo più grande\ndella lunghezza del vettore? Cosa succede quando si effettua un sottoinsieme con un\nnome che non esiste?","code":""},{"path":"vettori.html","id":"liste","chapter":"20 Vettori","heading":"20.5 Vettori ricorsivi (liste)","text":"Le liste sono un passo avanti nella complessità rispetto ai vettori atomici, perché le liste possono contenere altre liste. Questo le rende adatte rappresentare strutture gerarchiche o ad albero. Si crea una lista con list():Uno strumento molto utile per lavorare con le liste è str() perché si concentra sulla struttura, non sul contenuto.differenza dei vettori atomici, list() può contenere un mix di oggetti:Le liste possono anche contenere altre liste!","code":"\nx <- list(1, 2, 3)\nx\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n#> \n#> [[3]]\n#> [1] 3\nstr(x)\n#> List of 3\n#>  $ : num 1\n#>  $ : num 2\n#>  $ : num 3\n\nx_named <- list(a = 1, b = 2, c = 3)\nstr(x_named)\n#> List of 3\n#>  $ a: num 1\n#>  $ b: num 2\n#>  $ c: num 3\ny <- list(\"a\", 1L, 1.5, TRUE)\nstr(y)\n#> List of 4\n#>  $ : chr \"a\"\n#>  $ : int 1\n#>  $ : num 1.5\n#>  $ : logi TRUE\nz <- list(list(1, 2), list(3, 4))\nstr(z)\n#> List of 2\n#>  $ :List of 2\n#>   ..$ : num 1\n#>   ..$ : num 2\n#>  $ :List of 2\n#>   ..$ : num 3\n#>   ..$ : num 4"},{"path":"vettori.html","id":"visualizzazione-delle-liste","chapter":"20 Vettori","heading":"20.5.1 Visualizzazione delle liste","text":"Per spiegare le funzioni di manipolazione delle liste più complicate, è utile avere una rappresentazione visiva delle liste. Per esempio, prendete queste tre liste:Li disegnerò come segue:Ci sono tre principi:Le liste hanno angoli arrotondati. vettori atomici hanno angoli quadrati.Le liste hanno angoli arrotondati. vettori atomici hanno angoli quadrati.figli sono disegnati ’interno del loro genitore e hanno uno sfondo\nsfondo per rendere più facile vedere la gerarchia.figli sono disegnati ’interno del loro genitore e hanno uno sfondo\nsfondo per rendere più facile vedere la gerarchia.L’orientamento dei figli (cioè righe o colonne) non è importante,\nquindi sceglierò un orientamento di riga o di colonna per risparmiare spazio o per illustrare\nuna proprietà importante nell’esempio.L’orientamento dei figli (cioè righe o colonne) non è importante,\nquindi sceglierò un orientamento di riga o di colonna per risparmiare spazio o per illustrare\nuna proprietà importante nell’esempio.","code":"\nx1 <- list(c(1, 2), c(3, 4))\nx2 <- list(list(1, 2), list(3, 4))\nx3 <- list(1, list(2, list(3)))"},{"path":"vettori.html","id":"sottoinsieme","chapter":"20 Vettori","heading":"20.5.2 Sottoinsieme","text":"Ci sono tre modi per suddividere una lista, che illustrerò con una lista chiamata :[ estrae una sotto-lista. Il risultato sarà sempre una lista.\n\nstr([1:2])\n#> List 2\n#>  $ : int [1:3] 1 2 3\n#>  $ b: chr \"string\"\nstr([4])\n#> List 1\n#>  $ d:List 2\n#>   ..$ : num -1\n#>   ..$ : num -5\nCome con vettori, potete sottoporre subset un vettore logico, intero o di caratteri.[ estrae una sotto-lista. Il risultato sarà sempre una lista.Come con vettori, potete sottoporre subset un vettore logico, intero o di caratteri.[[ estrae un singolo componente da una lista. Rimuove un livello di gerarchia dalla lista.\n\nstr([[1]])\n#>  int [1:3] 1 2 3\nstr([[4]])\n#> List 2\n#>  $ : num -1\n#>  $ : num -5[[ estrae un singolo componente da una lista. Rimuove un livello di gerarchia dalla lista.$ è un’abbreviazione per estrarre elementi nominati di una lista. Funziona modo simile [[ eccetto che non c’è bisogno di usare le virgolette.\n\n$\n#> [1] 1 2 3\n[[\"\"]]\n#> [1] 1 2 3$ è un’abbreviazione per estrarre elementi nominati di una lista. Funziona modo simile [[ eccetto che non c’è bisogno di usare le virgolette.La distinzione tra [ e [[ è davvero importante per le liste, perché [[ si addentra nella lista mentre [ restituisce una nuova lista più piccola. Confrontate il codice e l’output di cui sopra con la rappresentazione visiva nella figura 20.2.\nFigure 20.2: Subsetting list, visually.\n","code":"\na <- list(a = 1:3, b = \"a string\", c = pi, d = list(-1, -5))\nstr(a[1:2])\n#> List of 2\n#>  $ a: int [1:3] 1 2 3\n#>  $ b: chr \"a string\"\nstr(a[4])\n#> List of 1\n#>  $ d:List of 2\n#>   ..$ : num -1\n#>   ..$ : num -5\nstr(a[[1]])\n#>  int [1:3] 1 2 3\nstr(a[[4]])\n#> List of 2\n#>  $ : num -1\n#>  $ : num -5\na$a\n#> [1] 1 2 3\na[[\"a\"]]\n#> [1] 1 2 3"},{"path":"vettori.html","id":"liste-di-condimenti","chapter":"20 Vettori","heading":"20.5.3 Liste di condimenti","text":"La differenza tra [ e [[ è molto importante, ma è facile confondersi. Per aiutarti ricordare, lascia che ti mostri un insolito saliera per il pepe.Se questa saliera di pepe è la vostra lista x, allora, x[1] è una saliera di pepe contenente un singolo pacchetto di pepe:x[2] avrebbe lo stesso aspetto, ma conterrebbe il secondo pacchetto. x[1:2] sarebbe una saliera per il pepe contenente due pacchetti di pepe.x[[1]] è:Se voleste ottenere il contenuto del pacchetto pepper, avreste bisogno di x[[1]][[1]]:","code":""},{"path":"vettori.html","id":"esercizi-56","chapter":"20 Vettori","heading":"20.5.4 Esercizi","text":"Disegna le seguenti liste come insiemi annidati:\nlista(, b, lista(c, d), lista(e, f))\nlista(lista(lista(lista(lista(lista()))))))\nDisegna le seguenti liste come insiemi annidati:lista(, b, lista(c, d), lista(e, f))lista(lista(lista(lista(lista(lista()))))))Cosa succede se si sottoinveste un tibble come se si stesse sottoponendo una lista?\nQuali sono le differenze chiave tra una lista e una tibla?Cosa succede se si sottoinveste un tibble come se si stesse sottoponendo una lista?\nQuali sono le differenze chiave tra una lista e una tibla?","code":""},{"path":"vettori.html","id":"attributi","chapter":"20 Vettori","heading":"20.6 Attributi","text":"Ogni vettore può contenere metadati aggiuntivi arbitrari attraverso suoi attributes. Puoi pensare agli attributi come una lista di vettori denominata che può essere allegata qualsiasi oggetto.\nPotete ottenere e impostare valori dei singoli attributi con attr() o vederli tutti insieme con attributes().Ci sono tre attributi molto importanti che vengono utilizzati per implementare parti fondamentali di R:Names sono usati per nominare gli elementi di un vettore. 1. 2. Dimensions (dims, breve) fanno sì che un vettore si comporti come una matrice o un array. 1. Class è usato per implementare il sistema orientato agli oggetti S3.Avete visto nomi sopra, e non parleremo di dimensioni perché non usiamo matrici questo libro. Resta da descrivere la classe, che controlla il funzionamento delle funzioni generiche. Le funzioni generiche sono la chiave per la programmazione orientata agli oggetti R, perché fanno sì che le funzioni si comportino diversamente per diverse classi di input. Una discussione dettagliata della programmazione orientata agli oggetti va oltre lo scopo di questo libro, ma potete leggerne di più Advanced R http://adv-r..co.nz/OO-essentials.html#s3.Ecco come appare una tipica funzione generica:La chiamata “UseMethod” significa che questa è una funzione generica, e chiamerà uno specifico method, una funzione, basata sulla classe del primo argomento. (Tutti metodi sono funzioni; non tutte le funzioni sono metodi). Potete elencare tutti metodi di un generico con metodi():Per esempio, se x è un vettore di caratteri, .Date() chiamerà .Date.character(); se è un fattore, chiamerà .Date.factor().Potete vedere l’implementazione specifica di un metodo con getS3method():Il più importante generico S3 è print(): controlla come l’oggetto viene stampato quando si digita il suo nome sulla console. Altri generici importanti sono le funzioni di subsetting [, [[, e $.","code":"\nx <- 1:10\nattr(x, \"greeting\")\n#> NULL\nattr(x, \"greeting\") <- \"Hi!\"\nattr(x, \"farewell\") <- \"Bye!\"\nattributes(x)\n#> $greeting\n#> [1] \"Hi!\"\n#> \n#> $farewell\n#> [1] \"Bye!\"\nas.Date\n#> function (x, ...) \n#> UseMethod(\"as.Date\")\n#> <bytecode: 0x55a5b039ed00>\n#> <environment: namespace:base>\nmethods(\"as.Date\")\n#> [1] as.Date.character   as.Date.default     as.Date.factor     \n#> [4] as.Date.numeric     as.Date.POSIXct     as.Date.POSIXlt    \n#> [7] as.Date.vctrs_sclr* as.Date.vctrs_vctr*\n#> see '?methods' for accessing help and source code\ngetS3method(\"as.Date\", \"default\")\n#> function (x, ...) \n#> {\n#>     if (inherits(x, \"Date\")) \n#>         x\n#>     else if (is.null(x)) \n#>         .Date(numeric())\n#>     else if (is.logical(x) && all(is.na(x))) \n#>         .Date(as.numeric(x))\n#>     else stop(gettextf(\"do not know how to convert '%s' to class %s\", \n#>         deparse1(substitute(x)), dQuote(\"Date\")), domain = NA)\n#> }\n#> <bytecode: 0x55a5adecfed0>\n#> <environment: namespace:base>\ngetS3method(\"as.Date\", \"numeric\")\n#> function (x, origin, ...) \n#> {\n#>     if (missing(origin)) {\n#>         if (!length(x)) \n#>             return(.Date(numeric()))\n#>         if (!any(is.finite(x))) \n#>             return(.Date(x))\n#>         stop(\"'origin' must be supplied\")\n#>     }\n#>     as.Date(origin, ...) + x\n#> }\n#> <bytecode: 0x55a5aded6140>\n#> <environment: namespace:base>"},{"path":"vettori.html","id":"vettori-incrementati","chapter":"20 Vettori","heading":"20.7 Vettori incrementati","text":"vettori atomici e le liste sono mattoni per altri importanti tipi di vettori come fattori e le date. Li chiamo vettori aumentati, perché sono vettori con ulteriori attributi, inclusa la classe. Poiché vettori aumentati hanno una classe, si comportano diversamente dal vettore atomico su cui sono costruiti. questo libro, facciamo uso di quattro importanti vettori aumentati:FattoriDateData-oraTibbleQuesti sono descritti di seguito.","code":""},{"path":"vettori.html","id":"fattori-1","chapter":"20 Vettori","heading":"20.7.1 Fattori","text":"fattori sono progettati per rappresentare dati categorici che possono assumere un insieme fisso di possibili valori. fattori sono costruiti sopra gli interi e hanno un attributo levels:","code":"\nx <- factor(c(\"ab\", \"cd\", \"ab\"), levels = c(\"ab\", \"cd\", \"ef\"))\ntypeof(x)\n#> [1] \"integer\"\nattributes(x)\n#> $levels\n#> [1] \"ab\" \"cd\" \"ef\"\n#> \n#> $class\n#> [1] \"factor\""},{"path":"vettori.html","id":"date-e-data-ora","chapter":"20 Vettori","heading":"20.7.2 Date e data-ora","text":"Le date R sono vettori numerici che rappresentano il numero di giorni dal 1° gennaio 1970.data-ora sono vettori numerici con classe POSIXct che rappresentano il numero di secondi dal 1 gennaio 1970. (Nel caso ve lo steste chiedendo, “POSIXct” sta per “Portable Operating System Interface”, ora del calendario).L’attributo tzone è opzionale. Controlla come viene stampata l’ora, non quale ora assoluta si riferisce.C’è un altro tipo di date-times chiamato POSIXlt. Questi sono costruiti sopra le liste con nome:POSIXlts sono rari ’interno del tidyverse. Spuntano fuori R di base, perché sono necessari per estrarre componenti specifici di una data, come l’anno o il mese. Dato che lubridate fornisce degli helper per fare questo, non ne avete bisogno. POSIXct sono sempre più facili da lavorare, quindi se scoprite di avere un POSIXlt, dovreste sempre convertirlo un normale data time lubridate::as_date_time().","code":"\nx <- as.Date(\"1971-01-01\")\nunclass(x)\n#> [1] 365\n\ntypeof(x)\n#> [1] \"double\"\nattributes(x)\n#> $class\n#> [1] \"Date\"\nx <- lubridate::ymd_hm(\"1970-01-01 01:00\")\nunclass(x)\n#> [1] 3600\n#> attr(,\"tzone\")\n#> [1] \"UTC\"\n\ntypeof(x)\n#> [1] \"double\"\nattributes(x)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nattr(x, \"tzone\") <- \"US/Pacific\"\nx\n#> [1] \"1969-12-31 17:00:00 PST\"\n\nattr(x, \"tzone\") <- \"US/Eastern\"\nx\n#> [1] \"1969-12-31 20:00:00 EST\"\ny <- as.POSIXlt(x)\ntypeof(y)\n#> [1] \"list\"\nattributes(y)\n#> $names\n#>  [1] \"sec\"    \"min\"    \"hour\"   \"mday\"   \"mon\"    \"year\"   \"wday\"   \"yday\"  \n#>  [9] \"isdst\"  \"zone\"   \"gmtoff\"\n#> \n#> $class\n#> [1] \"POSIXlt\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"US/Eastern\" \"EST\"        \"EDT\""},{"path":"vettori.html","id":"tibble-1","chapter":"20 Vettori","heading":"20.7.3 Tibble","text":"Le tibble sono liste aumentate: hanno classe “tbl_df” + “tbl” + “data.frame”, e gli attributi names (colonna) e row.names:La differenza tra una tibble e una lista è che tutti gli elementi di un data frame devono essere vettori della stessa lunghezza. Tutte le funzioni che lavorano con le tibble impongono questo vincolo.data.frame tradizionali hanno una struttura molto simile:La differenza principale è la classe. La classe di tibble include “data.frame”, il che significa che le tibble ereditano il comportamento dei normali data frame per default.","code":"\ntb <- tibble::tibble(x = 1:5, y = 5:1)\ntypeof(tb)\n#> [1] \"list\"\nattributes(tb)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5\n#> \n#> $names\n#> [1] \"x\" \"y\"\ndf <- data.frame(x = 1:5, y = 5:1)\ntypeof(df)\n#> [1] \"list\"\nattributes(df)\n#> $names\n#> [1] \"x\" \"y\"\n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3 4 5"},{"path":"vettori.html","id":"esercizi-57","chapter":"20 Vettori","heading":"20.7.4 Esercizi","text":"Cosa restituisce hms::hms(3600)? Come si stampa? Quale primitiva\nè costruito sopra il vettore aumentato? Quali attributi usa\nusa?Cosa restituisce hms::hms(3600)? Come si stampa? Quale primitiva\nè costruito sopra il vettore aumentato? Quali attributi usa\nusa?Prova fare un tibbo che abbia colonne di lunghezza diversa. Cosa\nsuccede?Prova fare un tibbo che abbia colonne di lunghezza diversa. Cosa\nsuccede?base alla definizione di cui sopra, va bene avere una lista come\ncolonna di una tibla?base alla definizione di cui sopra, va bene avere una lista come\ncolonna di una tibla?","code":""},{"path":"iterazioni.html","id":"iterazioni","chapter":"21 Iterazioni","heading":"21 Iterazioni","text":"","code":""},{"path":"iterazioni.html","id":"introduzione-14","chapter":"21 Iterazioni","heading":"21.1 Introduzione","text":"funzioni, abbiamo parlato di quanto sia importante ridurre la duplicazione del codice creando funzioni invece di copiare e incollare. Ridurre la duplicazione del codice ha tre benefici principali:È più facile vedere l’intento del vostro codice, perché vostri occhi sono\nattratti da ciò che è diverso, non da ciò che rimane lo stesso.È più facile vedere l’intento del vostro codice, perché vostri occhi sono\nattratti da ciò che è diverso, non da ciò che rimane lo stesso.È più facile rispondere ai cambiamenti dei requisiti. Quando tuoi bisogni\nesigenze, hai solo bisogno di fare cambiamenti un posto, piuttosto che\nricordarsi di cambiare ogni posto cui hai copiato e incollato il\ncodice.È più facile rispondere ai cambiamenti dei requisiti. Quando tuoi bisogni\nesigenze, hai solo bisogno di fare cambiamenti un posto, piuttosto che\nricordarsi di cambiare ogni posto cui hai copiato e incollato il\ncodice.È probabile che abbiate meno bug perché ogni linea di codice è\nusata più posti.È probabile che abbiate meno bug perché ogni linea di codice è\nusata più posti.Uno strumento per ridurre la duplicazione sono le funzioni, che riducono la duplicazione identificando schemi ripetuti di codice e li estraggono pezzi indipendenti che possono essere facilmente riutilizzati e aggiornati. Un altro strumento per ridurre la duplicazione è l’ iterazione, che vi aiuta quando avete bisogno di fare la stessa cosa più input: ripetere la stessa operazione su diverse colonne, o su diversi insiemi di dati.\nquesto capitolo imparerete due importanti paradigmi di iterazione: la programmazione imperativa e la programmazione funzionale. Sul lato imperativo ci sono strumenti come cicli e cicli , che sono un ottimo punto di partenza perché rendono l’iterazione molto esplicita, quindi è ovvio cosa sta succedendo. Tuttavia, cicli sono abbastanza prolissi e richiedono un bel po’ di codice di supporto che viene duplicato per ogni ciclo . La programmazione funzionale (FP) offre strumenti per estrarre questo codice duplicato, così ogni comune modello di ciclo ha la sua propria funzione. Una volta che si padroneggia il vocabolario della FP, si possono risolvere molti problemi comuni di iterazione con meno codice, più facilità e meno errori.","code":""},{"path":"iterazioni.html","id":"prerequisiti-14","chapter":"21 Iterazioni","heading":"21.1.1 Prerequisiti","text":"Una volta che avete padroneggiato cicli forniti da R base, imparerete alcuni dei potenti strumenti di programmazione forniti da purrr, uno dei pacchetti principali di tidyverse.","code":"\nlibrary(tidyverse)"},{"path":"iterazioni.html","id":"cicli-for","chapter":"21 Iterazioni","heading":"21.2 Cicli for","text":"Immaginiamo di avere questa semplice tibble:Vogliamo calcolare la mediana di ogni colonna. Si potrebbe fare con il copia-e-incolla:Ma questo infrange la nostra regola empirica: mai copiare e incollare più di due volte. Invece, potremmo usare un ciclo :Ogni ciclo ha tre componenti:Il output: output <- vector(\"double\", length(x)).\nPrima di iniziare il ciclo, dovete sempre allocare uno spazio sufficiente\nper l’output. Questo è molto importante per l’efficienza: se fate crescere\nil ciclo ad ogni iterazione usando c() (per esempio), il vostro ciclo \nsarà molto lento.\nUn modo generale per creare un vettore vuoto di una data lunghezza è la funzione vector()\nè la funzione vector(). Ha due argomenti: il tipo di vettore (“logico”,\n“intero”, “doppio”, “carattere”, ecc.) e la lunghezza del vettore.Il output: output <- vector(\"double\", length(x)).\nPrima di iniziare il ciclo, dovete sempre allocare uno spazio sufficiente\nper l’output. Questo è molto importante per l’efficienza: se fate crescere\nil ciclo ad ogni iterazione usando c() (per esempio), il vostro ciclo \nsarà molto lento.Un modo generale per creare un vettore vuoto di una data lunghezza è la funzione vector()\nè la funzione vector(). Ha due argomenti: il tipo di vettore (“logico”,\n“intero”, “doppio”, “carattere”, ecc.) e la lunghezza del vettore.La sequenza: seq_along(df). Questo determina su cosa eseguire il ciclo:\nogni esecuzione del ciclo assegnerà un valore diverso da\nseq_along(df). È utile pensare come un pronome, come “”.\nPotreste non aver visto seq_along() prima. È una versione sicura del\nfamiliare 1:length(l), con un’importante differenza: se avete un\nvettore di lunghezza zero, seq_along() fa la cosa giusta:\n\ny <- vector(\"double\", 0)\nseq_along(y)\n#> integer(0)\n1:length(y)\n#> [1] 1 0\nProbabilmente non creerete deliberatamente un vettore di lunghezza zero, ma\nè facile crearli accidentalmente. Se usate 1:length(x) invece di\ndi seq_along(x), probabilmente otterrete un messaggio di errore confuso.La sequenza: seq_along(df). Questo determina su cosa eseguire il ciclo:\nogni esecuzione del ciclo assegnerà un valore diverso da\nseq_along(df). È utile pensare come un pronome, come “”.Potreste non aver visto seq_along() prima. È una versione sicura del\nfamiliare 1:length(l), con un’importante differenza: se avete un\nvettore di lunghezza zero, seq_along() fa la cosa giusta:Probabilmente non creerete deliberatamente un vettore di lunghezza zero, ma\nè facile crearli accidentalmente. Se usate 1:length(x) invece di\ndi seq_along(x), probabilmente otterrete un messaggio di errore confuso.Il corpo: output[[]] <- mediana(df[[]]). Questo è il codice che fa\nil lavoro. Viene eseguito ripetutamente, ogni volta con un valore diverso per .\nLa prima iterazione eseguirà output[[1]] <- mediana(df[[1]]),\nla seconda eseguirà output[[2]] <- mediana(df[[2]]), e così via.Il corpo: output[[]] <- mediana(df[[]]). Questo è il codice che fa\nil lavoro. Viene eseguito ripetutamente, ogni volta con un valore diverso per .\nLa prima iterazione eseguirà output[[1]] <- mediana(df[[1]]),\nla seconda eseguirà output[[2]] <- mediana(df[[2]]), e così via.Questo è tutto quello che c’è nel ciclo ! Ora è un buon momento per fare pratica nel creare alcuni cicli di base (e non così di base) usando gli esercizi qui sotto. Poi passeremo ad alcune variazioni del ciclo che vi aiuteranno risolvere altri problemi che si presenteranno nella pratica.","code":"\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\nmedian(df$a)\n#> [1] -0.2457625\nmedian(df$b)\n#> [1] -0.2873072\nmedian(df$c)\n#> [1] -0.05669771\nmedian(df$d)\n#> [1] 0.1442633\noutput <- vector(\"double\", ncol(df))  # 1. output\nfor (i in seq_along(df)) {            # 2. sequenza\n  output[[i]] <- median(df[[i]])      # 3. corpo\n}\noutput\n#> [1] -0.24576245 -0.28730721 -0.05669771  0.14426335\ny <- vector(\"double\", 0)\nseq_along(y)\n#> integer(0)\n1:length(y)\n#> [1] 1 0"},{"path":"iterazioni.html","id":"esercizi-58","chapter":"21 Iterazioni","heading":"21.2.1 Esercizi","text":"Scrivere cicli per:\nCalcolare la media di ogni colonna mtcars.\nDeterminare il tipo di ogni colonna nycflights13::flights.\nCalcolare il numero di valori unici ogni colonna di iris.\nGenera 10 normali casuali da distribuzioni con medie di -10, 0, 10 e 100.\nPensate ’output, alla sequenza e al corpo prima di iniziare scrivere\nil ciclo.Scrivere cicli per:Calcolare la media di ogni colonna mtcars.Determinare il tipo di ogni colonna nycflights13::flights.Calcolare il numero di valori unici ogni colonna di iris.Genera 10 normali casuali da distribuzioni con medie di -10, 0, 10 e 100.Pensate ’output, alla sequenza e al corpo prima di iniziare scrivere\nil ciclo.Eliminate il ciclo ognuno dei seguenti esempi sfruttando\nsfruttando una funzione esistente che lavora con vettori:\n\n<- \"\"\n(x letters) {\n  <- stringr::str_c(, x)\n}\n\nx <- sample(100)\nsd <- 0\n(seq_along(x)) {\n  sd <- sd + (x[] - mean(x)) ^ 2\n}\nsd <- sqrt(sd / (length(x) - 1))\n\nx <- runif(100)\n<- vector(\"numeric\", length(x))\n[1] <- x[1]\n(2:length(x)) {\n  [] <- [- 1] + x[]\n}Eliminate il ciclo ognuno dei seguenti esempi sfruttando\nsfruttando una funzione esistente che lavora con vettori:Combinate le vostre abilità di scrittura di funzioni e di ciclo :\nScrivi un ciclo che stampi() il testo della canzone per bambini\n“Alice il cammello”.\nConverti la filastrocca “dieci nel letto” una funzione. Generalizzare\nqualsiasi numero di persone qualsiasi struttura per dormire.\nConvertire la canzone “99 bottiglie di birra sul muro” una funzione.\nGeneralizzare qualsiasi numero di qualsiasi recipiente contenente qualsiasi liquido su\nqualsiasi superficie.\nCombinate le vostre abilità di scrittura di funzioni e di ciclo :Scrivi un ciclo che stampi() il testo della canzone per bambini\n“Alice il cammello”.Scrivi un ciclo che stampi() il testo della canzone per bambini\n“Alice il cammello”.Converti la filastrocca “dieci nel letto” una funzione. Generalizzare\nqualsiasi numero di persone qualsiasi struttura per dormire.Converti la filastrocca “dieci nel letto” una funzione. Generalizzare\nqualsiasi numero di persone qualsiasi struttura per dormire.Convertire la canzone “99 bottiglie di birra sul muro” una funzione.\nGeneralizzare qualsiasi numero di qualsiasi recipiente contenente qualsiasi liquido su\nqualsiasi superficie.Convertire la canzone “99 bottiglie di birra sul muro” una funzione.\nGeneralizzare qualsiasi numero di qualsiasi recipiente contenente qualsiasi liquido su\nqualsiasi superficie.È comune vedere cicli che non preallocano l’output e invece\naumentano la lunghezza di un vettore ad ogni passo:\n\noutput <- vector(\"integer\", 0)\n(seq_along(x)) {\n  output <- c(output, lengths(x[[]]))\n}\noutput\nCome influisce sulle prestazioni? Progettate ed eseguite un esperimento.È comune vedere cicli che non preallocano l’output e invece\naumentano la lunghezza di un vettore ad ogni passo:Come influisce sulle prestazioni? Progettate ed eseguite un esperimento.","code":"\nout <- \"\"\nfor (x in letters) {\n  out <- stringr::str_c(out, x)\n}\n\nx <- sample(100)\nsd <- 0\nfor (i in seq_along(x)) {\n  sd <- sd + (x[i] - mean(x)) ^ 2\n}\nsd <- sqrt(sd / (length(x) - 1))\n\nx <- runif(100)\nout <- vector(\"numeric\", length(x))\nout[1] <- x[1]\nfor (i in 2:length(x)) {\n  out[i] <- out[i - 1] + x[i]\n}\noutput <- vector(\"integer\", 0)\nfor (i in seq_along(x)) {\n  output <- c(output, lengths(x[[i]]))\n}\noutput"},{"path":"iterazioni.html","id":"variazioni-del-ciclo-for","chapter":"21 Iterazioni","heading":"21.3 Variazioni del ciclo for","text":"Una volta che avete il ciclo di base sotto la vostra cintura, ci sono alcune variazioni di cui dovreste essere consapevoli. Queste variazioni sono importanti indipendentemente da come si fa l’iterazione, quindi non dimenticatele una volta che avete imparato le tecniche FP che imparerete nella prossima sezione.Ci sono quattro variazioni sul tema di base del ciclo :Modificare un oggetto esistente, invece di crearne uno nuovo.Looping su nomi o valori, invece che su indici.\nLooping su nomi o valori, invece che su indici.Gestire uscite di lunghezza sconosciuta.Gestione di sequenze di lunghezza sconosciuta.","code":""},{"path":"iterazioni.html","id":"modifica-di-un-oggetto-esistente","chapter":"21 Iterazioni","heading":"21.3.1 Modifica di un oggetto esistente","text":"volte volete usare un ciclo per modificare un oggetto esistente. Per esempio, ricordate la nostra sfida da funzioni. Volevamo ridimensionare ogni colonna di un frame di dati:Per risolvere questo con un ciclo pensiamo di nuovo ai tre componenti:Output: abbiamo già l’output — è uguale ’input!Output: abbiamo già l’output — è uguale ’input!Sequenza: possiamo pensare un data frame come una lista di colonne, quindi possiamo iterare su ogni colonna con seq_along(df).Sequenza: possiamo pensare un data frame come una lista di colonne, quindi possiamo iterare su ogni colonna con seq_along(df).Corpo: applicare rescale01().Corpo: applicare rescale01().Questo ci dà:Tipicamente modificherete una lista o un data frame con questo tipo di ciclo, quindi ricordatevi di usare [[, non [. Potreste aver notato che ho usato [[ tutti miei cicli : Penso sia meglio usare [[ anche per vettori atomici perché rende chiaro che voglio lavorare con un singolo elemento.","code":"\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\nrescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n}\n\ndf$a <- rescale01(df$a)\ndf$b <- rescale01(df$b)\ndf$c <- rescale01(df$c)\ndf$d <- rescale01(df$d)\nfor (i in seq_along(df)) {\n  df[[i]] <- rescale01(df[[i]])\n}"},{"path":"iterazioni.html","id":"modelli-di-looping","chapter":"21 Iterazioni","heading":"21.3.2 Modelli di looping","text":"Ci sono tre modi di base per fare un loop su un vettore. Finora vi ho mostrato il più generale: il looping sugli indici numerici con (seq_along(xs)), e l’estrazione del valore con x[[]]. Ci sono altre due forme:Loop sugli elementi: (x xs). Questo è più utile se vi interessa solo\npreoccuparsi solo degli effetti collaterali, come tracciare o salvare un file, perché è\ndifficile salvare l’output modo efficiente.Loop sugli elementi: (x xs). Questo è più utile se vi interessa solo\npreoccuparsi solo degli effetti collaterali, come tracciare o salvare un file, perché è\ndifficile salvare l’output modo efficiente.Fate un loop sui nomi: (nm names(xs)). Questo vi dà il nome, che\npotete usare per accedere al valore con x[[nm]]. Questo è utile se volete\nusare il nome nel titolo di un grafico o nel nome di un file. Se state creando\nun output con nome, assicuratevi di nominare il vettore dei risultati questo modo:\n\nresults <- vector(\"list\", length(x))\nnames(results) <- names(x)Fate un loop sui nomi: (nm names(xs)). Questo vi dà il nome, che\npotete usare per accedere al valore con x[[nm]]. Questo è utile se volete\nusare il nome nel titolo di un grafico o nel nome di un file. Se state creando\nun output con nome, assicuratevi di nominare il vettore dei risultati questo modo:L’iterazione sugli indici numerici è la forma più generale, perché data la posizione si può estrarre sia il nome che il valore:","code":"\nresults <- vector(\"list\", length(x))\nnames(results) <- names(x)\nfor (i in seq_along(x)) {\n  name <- names(x)[[i]]\n  value <- x[[i]]\n}"},{"path":"iterazioni.html","id":"lunghezza-di-uscita-sconosciuta","chapter":"21 Iterazioni","heading":"21.3.3 Lunghezza di uscita sconosciuta","text":"volte potreste non sapere quanto sarà lungo l’output. Per esempio, immaginate di voler simulare alcuni vettori casuali di lunghezza casuale. Potreste essere tentati di risolvere questo problema facendo crescere progressivamente il vettore:Ma questo non è molto efficiente perché ogni iterazione, R deve copiare tutti dati dalle iterazioni precedenti. termini tecnici si ottiene un comportamento “quadratico” (\\(O(n^2)\\)) che significa che un ciclo con un numero di elementi tre volte superiore richiederebbe nove (\\(3^2\\)) volte più tempo per essere eseguito.Una soluzione migliore è quella di salvare risultati una lista, e poi combinarli un singolo vettore dopo che il ciclo è finito:Qui ho usato unlist() per appiattire una lista di vettori un singolo vettore. Un’opzione più rigorosa è quella di usare purrr::flatten_dbl() — esso darà un errore se l’input non è una lista di double.Questo schema si verifica anche altri posti:Potreste generare una lunga stringa. Invece di paste() insieme\nogni iterazione con la precedente, salvate l’output un vettore di caratteri e\npoi combinate quel vettore una singola stringa con\npaste(output, collapse = \"\").Potreste generare una lunga stringa. Invece di paste() insieme\nogni iterazione con la precedente, salvate l’output un vettore di caratteri e\npoi combinate quel vettore una singola stringa con\npaste(output, collapse = \"\").Potreste generare un grande frame di dati. Invece di sequenziare\nrbind()ogni iterazione, salvate l’output una lista, poi usate\ndplyr::bind_rows(output) per combinare l’output un singolo\nframe di dati.Potreste generare un grande frame di dati. Invece di sequenziare\nrbind()ogni iterazione, salvate l’output una lista, poi usate\ndplyr::bind_rows(output) per combinare l’output un singolo\nframe di dati.Fate attenzione questo schema. Ogni volta che lo vedete, passate ad un oggetto risultato più complesso, e poi combinate un solo passo alla fine.","code":"\nmeans <- c(0, 1, 2)\n\noutput <- double()\nfor (i in seq_along(means)) {\n  n <- sample(100, 1)\n  output <- c(output, rnorm(n, means[[i]]))\n}\nstr(output)\n#>  num [1:138] 0.912 0.205 2.584 -0.789 0.588 ...\nout <- vector(\"list\", length(means))\nfor (i in seq_along(means)) {\n  n <- sample(100, 1)\n  out[[i]] <- rnorm(n, means[[i]])\n}\nstr(out)\n#> List of 3\n#>  $ : num [1:76] -0.3389 -0.0756 0.0402 0.1243 -0.9984 ...\n#>  $ : num [1:17] -0.11 1.149 0.614 0.77 1.392 ...\n#>  $ : num [1:41] 1.88 2.46 2.62 1.82 1.88 ...\nstr(unlist(out))\n#>  num [1:134] -0.3389 -0.0756 0.0402 0.1243 -0.9984 ..."},{"path":"iterazioni.html","id":"lunghezza-della-sequenza-sconosciuta","chapter":"21 Iterazioni","heading":"21.3.4 Lunghezza della sequenza sconosciuta","text":"volte non sapete nemmeno per quanto tempo la sequenza di input debba essere eseguita. Questo è comune quando si fanno simulazioni. Per esempio, potreste voler fare un ciclo finché non ottenete tre teste fila. Non potete fare questo tipo di iterazione con il ciclo . Invece, potete usare un ciclo . Un ciclo è più semplice del ciclo perché ha solo due componenti, una condizione e un corpo:Un ciclo è anche più generale di un ciclo , perché potete riscrivere qualsiasi ciclo come un ciclo , ma non potete riscrivere ogni ciclo come un ciclo :Ecco come potremmo usare un ciclo per trovare quanti tentativi ci vogliono per ottenere tre teste di fila:Menziono cicli solo brevemente, perché non li uso quasi mai. Sono più spesso usati per la simulazione, che è al di fuori dello scopo di questo libro. Tuttavia, è bene sapere che esistono modo da essere preparati per problemi cui il numero di iterazioni non è noto anticipo.","code":"\nwhile (condition) {\n  # corpo\n}\nfor (i in seq_along(x)) {\n  # corpo\n}\n\n# Equivalente a\ni <- 1\nwhile (i <= length(x)) {\n  # corpo\n  i <- i + 1 \n}\nflip <- function() sample(c(\"T\", \"H\"), 1)\n\nflips <- 0\nnheads <- 0\n\nwhile (nheads < 3) {\n  if (flip() == \"H\") {\n    nheads <- nheads + 1\n  } else {\n    nheads <- 0\n  }\n  flips <- flips + 1\n}\nflips\n#> [1] 21"},{"path":"iterazioni.html","id":"esercizi-59","chapter":"21 Iterazioni","heading":"21.3.5 Esercizi","text":"Immaginate di avere una directory piena di file CSV che volete leggere.\nAvete loro percorsi un vettore,\nfiles <- dir(\"data/\", pattern = \"\\\\csv$\", full.names = TRUE), e ora\nvuole leggere ognuno di essi con read_csv(). Scrivete il ciclo che\nli carichi un singolo frame di dati.Immaginate di avere una directory piena di file CSV che volete leggere.\nAvete loro percorsi un vettore,\nfiles <- dir(\"data/\", pattern = \"\\\\csv$\", full.names = TRUE), e ora\nvuole leggere ognuno di essi con read_csv(). Scrivete il ciclo che\nli carichi un singolo frame di dati.Cosa succede se usate (nm names(x)) e x non ha nomi?\nCosa succede se solo alcuni degli elementi hanno un nome? Cosa succede se nomi non sono\nnon sono unici?Cosa succede se usate (nm names(x)) e x non ha nomi?\nCosa succede se solo alcuni degli elementi hanno un nome? Cosa succede se nomi non sono\nnon sono unici?Scrivete una funzione che stampi la media di ogni colonna numerica un data\ndati, insieme al suo nome. Per esempio, show_mean(iris) stamperebbe:\n\nshow_mean(iris)\n#> Sepal.Length: 5.84\n#> Sepal.Width:  3.06\n#> Petal.Length: 3.76\n#> Petal.Width:  1.20\n(Sfida extra: quale funzione ho usato per assicurarmi che numeri fossero ben allineati, anche se nomi delle variabili avevano lunghezze diverse?)Scrivete una funzione che stampi la media di ogni colonna numerica un data\ndati, insieme al suo nome. Per esempio, show_mean(iris) stamperebbe:(Sfida extra: quale funzione ho usato per assicurarmi che numeri fossero ben allineati, anche se nomi delle variabili avevano lunghezze diverse?)Cosa fa questo codice? Come funziona?\n\ntrans <- list( \n  disp = function(x) x * 0.0163871,\n  = function(x) {\n    factor(x, labels = c(\"auto\", \"manual\"))\n  }\n)\n(var names(trans)) {\n  mtcars[[var]] <- trans[[var]](mtcars[[var]])\n}Cosa fa questo codice? Come funziona?","code":"\nshow_mean(iris)\n#> Sepal.Length: 5.84\n#> Sepal.Width:  3.06\n#> Petal.Length: 3.76\n#> Petal.Width:  1.20\ntrans <- list( \n  disp = function(x) x * 0.0163871,\n  am = function(x) {\n    factor(x, labels = c(\"auto\", \"manual\"))\n  }\n)\nfor (var in names(trans)) {\n  mtcars[[var]] <- trans[[var]](mtcars[[var]])\n}"},{"path":"iterazioni.html","id":"cicli-for-vs.-funzionali","chapter":"21 Iterazioni","heading":"21.4 Cicli for vs. funzionali","text":"cicli non sono così importanti R come lo sono altri linguaggi perché R è un linguaggio di programmazione funzionale. Questo significa che è possibile avvolgere cicli una funzione e chiamare quella funzione invece di usare direttamente il ciclo .Per vedere perché questo è importante, considerate (di nuovo) questo semplice frame di dati:Immaginate di voler calcolare la media di ogni colonna. Potreste farlo con un ciclo :Vi rendete conto che vorrete calcolare la media di ogni colonna abbastanza frequentemente, quindi la estraete una funzione:Ma poi pensate che sarebbe utile poter calcolare anche la mediana e la deviazione standard, quindi copiate e incollate la vostra funzione col_mean() e sostituite la mean() con median() e sd():Uh oh! Avete copiato e incollato questo codice due volte, quindi è il momento di pensare come generalizzarlo. Notate che la maggior parte di questo codice è un boilerplate -loop ed è difficile vedere l’unica cosa (mean(), median(), sd()) che è diversa tra le funzioni.Cosa fareste se vedeste una serie di funzioni come questa:Si spera di notare che ci sono molti doppioni e di estrarli un argomento aggiuntivo:Avete ridotto la possibilità di generare bug (perché ora avete 1/3 del codice originale), e lo avete reso facile da generalizzare nuove situazioni.Possiamo fare esattamente la stessa cosa con col_mean(), col_median() e col_sd() aggiungendo un argomento che fornisce la funzione da applicare ad ogni colonna:L’idea di passare una funzione ad un’altra funzione è un’idea estremamente potente, ed è uno dei comportamenti che rende R un linguaggio di programmazione funzionale. Potrebbe volerci un po’ di tempo per comprendere l’idea, ma ne vale la pena. Nel resto del capitolo, conoscerete e userete il pacchetto purrr, che fornisce funzioni che eliminano la necessità di molti comuni cicli . La famiglia di funzioni apply R base (apply(), lapply(), tapply(), etc) risolve un problema simile, ma purrr è più coerente e quindi più facile da imparare.L’obiettivo di usare le funzioni purrr al posto dei cicli è di permettervi di rompere le comuni sfide di manipolazione delle liste pezzi indipendenti:Come puoi risolvere il problema per un singolo elemento della lista? Una volta\nuna volta risolto il problema, purrr si occupa di generalizzare la\nsoluzione ad ogni elemento della lista.Come puoi risolvere il problema per un singolo elemento della lista? Una volta\nuna volta risolto il problema, purrr si occupa di generalizzare la\nsoluzione ad ogni elemento della lista.Se stai risolvendo un problema complesso, come puoi scomporlo \npezzi che ti permettono di avanzare di un piccolo passo verso la soluzione?\nsoluzione? Con Purrr, ottieni tanti piccoli pezzi che puoi\ncomporre insieme con il tubo.Se stai risolvendo un problema complesso, come puoi scomporlo \npezzi che ti permettono di avanzare di un piccolo passo verso la soluzione?\nsoluzione? Con Purrr, ottieni tanti piccoli pezzi che puoi\ncomporre insieme con il tubo.Questa struttura rende più facile risolvere nuovi problemi. Rende anche più facile capire le tue soluzioni ai vecchi problemi quando rileggi il tuo vecchio codice.","code":"\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\noutput <- vector(\"double\", length(df))\nfor (i in seq_along(df)) {\n  output[[i]] <- mean(df[[i]])\n}\noutput\n#> [1] -0.3260369  0.1356639  0.4291403 -0.2498034\ncol_mean <- function(df) {\n  output <- vector(\"double\", length(df))\n  for (i in seq_along(df)) {\n    output[i] <- mean(df[[i]])\n  }\n  output\n}\ncol_median <- function(df) {\n  output <- vector(\"double\", length(df))\n  for (i in seq_along(df)) {\n    output[i] <- median(df[[i]])\n  }\n  output\n}\ncol_sd <- function(df) {\n  output <- vector(\"double\", length(df))\n  for (i in seq_along(df)) {\n    output[i] <- sd(df[[i]])\n  }\n  output\n}\nf1 <- function(x) abs(x - mean(x)) ^ 1\nf2 <- function(x) abs(x - mean(x)) ^ 2\nf3 <- function(x) abs(x - mean(x)) ^ 3\nf <- function(x, i) abs(x - mean(x)) ^ i\ncol_summary <- function(df, fun) {\n  out <- vector(\"double\", length(df))\n  for (i in seq_along(df)) {\n    out[i] <- fun(df[[i]])\n  }\n  out\n}\ncol_summary(df, median)\n#> [1] -0.51850298  0.02779864  0.17295591 -0.61163819\ncol_summary(df, mean)\n#> [1] -0.3260369  0.1356639  0.4291403 -0.2498034"},{"path":"iterazioni.html","id":"esercizi-60","chapter":"21 Iterazioni","heading":"21.4.1 Esercizi","text":"Leggete la documentazione per apply(). Nel caso 2d, quali due cicli \ngeneralizza?Leggete la documentazione per apply(). Nel caso 2d, quali due cicli \ngeneralizza?Adattate col_summary() modo che si applichi solo alle colonne numeriche\nPotreste voler iniziare con una funzione is_numeric() che restituisca\nun vettore logico che ha un TRUE corrispondente ad ogni colonna numerica.Adattate col_summary() modo che si applichi solo alle colonne numeriche\nPotreste voler iniziare con una funzione is_numeric() che restituisca\nun vettore logico che ha un TRUE corrispondente ad ogni colonna numerica.","code":""},{"path":"iterazioni.html","id":"le-funzioni-map","chapter":"21 Iterazioni","heading":"21.5 Le funzioni map","text":"Lo schema di eseguire un ciclo su un vettore, fare qualcosa ad ogni elemento e salvare risultati è così comune che il pacchetto purrr fornisce una famiglia di funzioni che lo fanno per voi. C’è una funzione per ogni tipo di output:map() fa una lista.map_lgl() crea un vettore logico.map_int() crea un vettore intero.map_dbl() crea un vettore doppio.La funzione map_chr() crea un vettore di caratteri.Ogni funzione prende un vettore come input, applica una funzione ad ogni pezzo, e poi restituisce un nuovo vettore che ha la stessa lunghezza (e gli stessi nomi) dell’input. Il tipo di vettore è determinato dal suffisso della funzione map.Una volta che padroneggiate queste funzioni, scoprirete che ci vuole molto meno tempo per risolvere problemi di iterazione. Ma non dovreste mai sentirvi colpa se usate un ciclo invece di una funzione map. Le funzioni mappa sono un passo avanti nella torre di astrazione, e può volerci molto tempo per capire come funzionano. L’importante è che risolviate il problema su cui state lavorando, non che scriviate il codice più conciso ed elegante (anche se è sicuramente qualcosa cui volete tendere!).Alcune persone vi diranno di evitare cicli perché sono lenti. Si sbagliano! (Beh, almeno sono piuttosto fuori moda, dato che cicli non sono stati lenti per molti anni). Il principale vantaggio di usare funzioni come map() non è la velocità, ma la chiarezza: rendono il vostro codice più facile da scrivere e da leggere.Possiamo usare queste funzioni per eseguire gli stessi calcoli dell’ultimo ciclo . Quelle funzioni di riepilogo hanno restituito dei doppi, quindi abbiamo bisogno di usare map_dbl():Rispetto ’uso di un ciclo , l’attenzione si concentra sull’operazione che viene eseguita (cioè mean(), median(), sd()), non sulla contabilità richiesta per fare il loop su ogni elemento e memorizzare l’output. Questo è ancora più evidente se usiamo la pipe:Ci sono alcune differenze tra map_*() e col_summary():Tutte le funzioni purrr sono implementate C. Questo le rende un po’ più veloci\nspese della leggibilità.Tutte le funzioni purrr sono implementate C. Questo le rende un po’ più veloci\nspese della leggibilità.Il secondo argomento, .f, la funzione da applicare, può essere una formula, un\nvettore di caratteri o un vettore di interi. Imparerete queste comode\nscorciatoie nella prossima sezione.Il secondo argomento, .f, la funzione da applicare, può essere una formula, un\nvettore di caratteri o un vettore di interi. Imparerete queste comode\nscorciatoie nella prossima sezione.map_*() usa … ([dot dot dot]) per passare ulteriori argomenti\n.f ogni volta che viene chiamato:\n\nmap_dbl(df, mean, trim = 0.5)\n#>                     b           c           d \n#> -0.51850298  0.02779864  0.17295591 -0.61163819map_*() usa … ([dot dot dot]) per passare ulteriori argomenti\n.f ogni volta che viene chiamato:Le funzioni map conservano anche nomi:\n\nz <- list(x = 1:3, y = 4:5)\nmap_int(z, length)\n#> x y \n#> 3 2Le funzioni map conservano anche nomi:","code":"\nmap_dbl(df, mean)\n#>          a          b          c          d \n#> -0.3260369  0.1356639  0.4291403 -0.2498034\nmap_dbl(df, median)\n#>           a           b           c           d \n#> -0.51850298  0.02779864  0.17295591 -0.61163819\nmap_dbl(df, sd)\n#>         a         b         c         d \n#> 0.9214834 0.4848945 0.9816016 1.1563324\ndf %>% map_dbl(mean)\n#>          a          b          c          d \n#> -0.3260369  0.1356639  0.4291403 -0.2498034\ndf %>% map_dbl(median)\n#>           a           b           c           d \n#> -0.51850298  0.02779864  0.17295591 -0.61163819\ndf %>% map_dbl(sd)\n#>         a         b         c         d \n#> 0.9214834 0.4848945 0.9816016 1.1563324\nmap_dbl(df, mean, trim = 0.5)\n#>           a           b           c           d \n#> -0.51850298  0.02779864  0.17295591 -0.61163819\nz <- list(x = 1:3, y = 4:5)\nmap_int(z, length)\n#> x y \n#> 3 2"},{"path":"iterazioni.html","id":"scorciatoie","chapter":"21 Iterazioni","heading":"21.5.1 Scorciatoie","text":"Ci sono alcune scorciatoie che potete usare con .f per risparmiare un po’ di battitura. Immaginate di voler adattare un modello lineare ad ogni gruppo un set di dati. Il seguente esempio giocattolo divide il dataset mtcars tre pezzi (uno per ogni valore di cilindro) e adatta lo stesso modello lineare ad ogni pezzo:La sintassi per creare una funzione anonima R è piuttosto prolissa, così purrr fornisce una comoda scorciatoia: una formula unilaterale.Qui ho usato . come pronome: si riferisce ’elemento corrente della lista (nello stesso modo cui si riferisce ’indice corrente nel ciclo ).Quando state guardando molti modelli, potreste voler estrarre una statistica riassuntiva come il \\(R^2\\). Per farlo dobbiamo prima eseguire summary() e poi estrarre il componente chiamato r.quadrato. Potremmo farlo usando la scorciatoia per le funzioni anonime:Ma estrarre componenti con nome è un’operazione comune, quindi purrr fornisce una scorciatoia ancora più breve: si può usare una stringa.Potete anche usare un intero per selezionare gli elementi base alla posizione:","code":"\nmodels <- mtcars %>% \n  split(.$cyl) %>% \n  map(function(df) lm(mpg ~ wt, data = df))\nmodels <- mtcars %>% \n  split(.$cyl) %>% \n  map(~lm(mpg ~ wt, data = .))\nmodels %>% \n  map(summary) %>% \n  map_dbl(~.$r.squared)\n#>         4         6         8 \n#> 0.5086326 0.4645102 0.4229655\nmodels %>% \n  map(summary) %>% \n  map_dbl(\"r.squared\")\n#>         4         6         8 \n#> 0.5086326 0.4645102 0.4229655\nx <- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))\nx %>% map_dbl(2)\n#> [1] 2 5 8"},{"path":"iterazioni.html","id":"base-r","chapter":"21 Iterazioni","heading":"21.5.2 Base R","text":"Se avete familiarità con la famiglia di funzioni apply R base, potreste aver notato alcune somiglianze con le funzioni purrr:lapply() è fondamentalmente identica map(), eccetto che map() è\ncoerente con tutte le altre funzioni purrr, e potete usare le\nscorciatoie per .f.lapply() è fondamentalmente identica map(), eccetto che map() è\ncoerente con tutte le altre funzioni purrr, e potete usare le\nscorciatoie per .f.Base sapply() è un wrapper intorno lapply() che automaticamente\nsemplifica l’output. Questo è utile per il lavoro interattivo ma è\nproblematico una funzione perché non si sa mai che tipo di output\notterrete:\n\nx1 <- list(\n  c(0.27, 0.37, 0.57, 0.91, 0.20),\n  c(0.90, 0.94, 0.66, 0.63, 0.06), \n  c(0.21, 0.18, 0.69, 0.38, 0.77)\n)\nx2 <- list(\n  c(0.50, 0.72, 0.99, 0.38, 0.78), \n  c(0.93, 0.21, 0.65, 0.13, 0.27), \n  c(0.39, 0.01, 0.38, 0.87, 0.34)\n)\n\nthreshold <- function(x, cutoff = 0.8) x[x > cutoff]\nx1 %>% sapply(threshold) %>% str()\n#> List 3\n#>  $ : num 0.91\n#>  $ : num [1:2] 0.9 0.94\n#>  $ : num(0)\nx2 %>% sapply(threshold) %>% str()\n#>  num [1:3] 0.99 0.93 0.87Base sapply() è un wrapper intorno lapply() che automaticamente\nsemplifica l’output. Questo è utile per il lavoro interattivo ma è\nproblematico una funzione perché non si sa mai che tipo di output\notterrete:vapply() è un’alternativa sicura sapply() perché si fornisce un\nargomento aggiuntivo che definisce il tipo. L’unico problema con\nvapply() è che richiede un sacco di battitura:\nvapply(df, .numeric, logical(1)) è equivalente \nmap_lgl(df, .numeric). Un vantaggio di vapply() rispetto alle funzioni map\nè che può produrre anche matrici — le funzioni map producono solo\nproducono solo vettori.vapply() è un’alternativa sicura sapply() perché si fornisce un\nargomento aggiuntivo che definisce il tipo. L’unico problema con\nvapply() è che richiede un sacco di battitura:\nvapply(df, .numeric, logical(1)) è equivalente \nmap_lgl(df, .numeric). Un vantaggio di vapply() rispetto alle funzioni map\nè che può produrre anche matrici — le funzioni map producono solo\nproducono solo vettori.Mi concentro qui sulle funzioni di Purrr perché hanno nomi e argomenti più coerenti, utili scorciatoie, e futuro forniranno un facile parallelismo e barre di progresso.","code":"\nx1 <- list(\n  c(0.27, 0.37, 0.57, 0.91, 0.20),\n  c(0.90, 0.94, 0.66, 0.63, 0.06), \n  c(0.21, 0.18, 0.69, 0.38, 0.77)\n)\nx2 <- list(\n  c(0.50, 0.72, 0.99, 0.38, 0.78), \n  c(0.93, 0.21, 0.65, 0.13, 0.27), \n  c(0.39, 0.01, 0.38, 0.87, 0.34)\n)\n\nthreshold <- function(x, cutoff = 0.8) x[x > cutoff]\nx1 %>% sapply(threshold) %>% str()\n#> List of 3\n#>  $ : num 0.91\n#>  $ : num [1:2] 0.9 0.94\n#>  $ : num(0)\nx2 %>% sapply(threshold) %>% str()\n#>  num [1:3] 0.99 0.93 0.87"},{"path":"iterazioni.html","id":"esercizi-61","chapter":"21 Iterazioni","heading":"21.5.3 Esercizi","text":"Scrivete del codice che usi una delle funzioni map per:\nCalcolare la media di ogni colonna mtcars.\n\nDeterminare il tipo di ogni colonna nycflights13::flights.\nCalcolare il numero di valori unici ogni colonna di iris.\nGenera 10 normali casuali da distribuzioni con medie di -10, 0, 10 e 100.\nScrivete del codice che usi una delle funzioni map per:Calcolare la media di ogni colonna mtcars.\nCalcolare la media di ogni colonna mtcars.Determinare il tipo di ogni colonna nycflights13::flights.Calcolare il numero di valori unici ogni colonna di iris.Genera 10 normali casuali da distribuzioni con medie di -10, 0, 10 e 100.Come si può creare un singolo vettore che per ogni colonna di un data frame\nindichi se è un fattore o meno?Come si può creare un singolo vettore che per ogni colonna di un data frame\nindichi se è un fattore o meno?Cosa succede quando usi le funzioni map su vettori che non sono liste?\nCosa fa la funzione map(1:5, runif)? Perché?Cosa succede quando usi le funzioni map su vettori che non sono liste?\nCosa fa la funzione map(1:5, runif)? Perché?Cosa fa map(-2:2, rnorm, n = 5)? Perché?\nChe cosa fa map_dbl(-2:2, rnorm, n = 5)? Perché?\nCosa fa map(-2:2, rnorm, n = 5)? Perché?Che cosa fa map_dbl(-2:2, rnorm, n = 5)? Perché?Riscrivete map(x, function(df) lm(mpg ~ wt, data = df)) per eliminare la\nfunzione anonima.Riscrivete map(x, function(df) lm(mpg ~ wt, data = df)) per eliminare la\nfunzione anonima.","code":""},{"path":"iterazioni.html","id":"affrontare-il-fallimento","chapter":"21 Iterazioni","heading":"21.6 Affrontare il fallimento","text":"Quando usate le funzioni map per ripetere molte operazioni, le possibilità che una di queste operazioni fallisca sono molto più alte. Quando ciò accade, si ottiene un messaggio di errore e nessun output. Questo è fastidioso: perché un fallimento vi impedisce di accedere tutti gli altri successi? Come ci si assicura che una mela marcia non rovini l’intero barile?questa sezione imparerete come affrontare questa situazione con una nuova funzione: safely(). La funzione safely() è un avverbio: prende una funzione (un verbo) e ne restituisce una versione modificata. questo caso, la funzione modificata non darà mai un errore. Invece, restituisce sempre una lista con due elementi:result è il risultato originale. Se c’è stato un errore, questo sarà NULL.result è il risultato originale. Se c’è stato un errore, questo sarà NULL.error è un oggetto di errore. Se l’operazione ha avuto successo, questo sarà\nNULL.error è un oggetto di errore. Se l’operazione ha avuto successo, questo sarà\nNULL.(Potreste avere familiarità con la funzione try() R base. È simile, ma poiché volte restituisce il risultato originale e volte restituisce un oggetto errore, è più difficile lavorarci).Illustriamo questo con un semplice esempio: log():Quando la funzione ha successo, l’elemento result contiene il risultato e l’elemento error è NULL. Quando la funzione fallisce, l’elemento result è NULL e l’elemento error contiene un oggetto di errore.La funzione safely() è progettata per lavorare con map:Sarebbe più facile lavorare con questo se avessimo due liste: una di tutti gli errori e una di tutti gli output. Questo è facile da ottenere con purrr::transpose():Sta te decidere come trattare gli errori, ma tipicamente guarderai valori di x dove y è un errore, o lavorerai con valori di y che sono ok:Purrr fornisce altri due utili avverbi:Come safely(), possibly() ha sempre successo. È più semplice di safely(), perché gli si dà un valore predefinito da restituire caso di errore.\n\nx <- list(1, 10, \"\")\nx %>% map_dbl(possibly(log, NA_real_))\n#> [1] 0.000000 2.302585       NACome safely(), possibly() ha sempre successo. È più semplice di safely(), perché gli si dà un valore predefinito da restituire caso di errore.quietly() svolge un ruolo simile quello di safely(), ma invece di catturare gli errori, cattura l’output stampato, messaggi e gli avvertimenti:\n\nx <- list(1, -1)\nx %>% map(quietly(log)) %>% str()\n#> List 2\n#>  $ :List 4\n#>   ..$ result  : num 0\n#>   ..$ output  : chr \"\"\n#>   ..$ warnings: chr(0) \n#>   ..$ messages: chr(0) \n#>  $ :List 4\n#>   ..$ result  : num NaN\n#>   ..$ output  : chr \"\"\n#>   ..$ warnings: chr \"NaNs produced\"\n#>   ..$ messages: chr(0)quietly() svolge un ruolo simile quello di safely(), ma invece di catturare gli errori, cattura l’output stampato, messaggi e gli avvertimenti:","code":"\nsafe_log <- safely(log)\nstr(safe_log(10))\n#> List of 2\n#>  $ result: num 2.3\n#>  $ error : NULL\nstr(safe_log(\"a\"))\n#> List of 2\n#>  $ result: NULL\n#>  $ error :List of 2\n#>   ..$ message: chr \"non-numeric argument to mathematical function\"\n#>   ..$ call   : language .Primitive(\"log\")(x, base)\n#>   ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nx <- list(1, 10, \"a\")\ny <- x %>% map(safely(log))\nstr(y)\n#> List of 3\n#>  $ :List of 2\n#>   ..$ result: num 0\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: num 2.3\n#>   ..$ error : NULL\n#>  $ :List of 2\n#>   ..$ result: NULL\n#>   ..$ error :List of 2\n#>   .. ..$ message: chr \"non-numeric argument to mathematical function\"\n#>   .. ..$ call   : language .Primitive(\"log\")(x, base)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\ny <- y %>% transpose()\nstr(y)\n#> List of 2\n#>  $ result:List of 3\n#>   ..$ : num 0\n#>   ..$ : num 2.3\n#>   ..$ : NULL\n#>  $ error :List of 3\n#>   ..$ : NULL\n#>   ..$ : NULL\n#>   ..$ :List of 2\n#>   .. ..$ message: chr \"non-numeric argument to mathematical function\"\n#>   .. ..$ call   : language .Primitive(\"log\")(x, base)\n#>   .. ..- attr(*, \"class\")= chr [1:3] \"simpleError\" \"error\" \"condition\"\nis_ok <- y$error %>% map_lgl(is_null)\nx[!is_ok]\n#> [[1]]\n#> [1] \"a\"\ny$result[is_ok] %>% flatten_dbl()\n#> [1] 0.000000 2.302585\nx <- list(1, 10, \"a\")\nx %>% map_dbl(possibly(log, NA_real_))\n#> [1] 0.000000 2.302585       NA\nx <- list(1, -1)\nx %>% map(quietly(log)) %>% str()\n#> List of 2\n#>  $ :List of 4\n#>   ..$ result  : num 0\n#>   ..$ output  : chr \"\"\n#>   ..$ warnings: chr(0) \n#>   ..$ messages: chr(0) \n#>  $ :List of 4\n#>   ..$ result  : num NaN\n#>   ..$ output  : chr \"\"\n#>   ..$ warnings: chr \"NaNs produced\"\n#>   ..$ messages: chr(0)"},{"path":"iterazioni.html","id":"map-su-più-argomenti","chapter":"21 Iterazioni","heading":"21.7 Map su più argomenti","text":"Finora abbiamo mappato lungo un singolo input. Ma spesso avete più input correlati che avete bisogno di iterare parallelo. Questo è il lavoro delle funzioni map2() e pmap(). Per esempio, immaginate di voler simulare alcune normali casuali con mezzi diversi. Sapete come farlo con map():E se si volesse variare anche la deviazione standard? Un modo per farlo sarebbe quello di iterare sugli indici e indicizzare vettori di medie e deviazioni standard:Ma questo offusca l’intento del codice. Invece potremmo usare map2() che itera su due vettori parallelo:map2() genera questa serie di chiamate di funzioni:Notate che gli argomenti che variano per ogni chiamata vengono prima della funzione; gli argomenti che sono gli stessi per ogni chiamata vengono dopo.Come map(), map2() è solo un involucro attorno ad un ciclo :Si potrebbe anche immaginare map3(), map4(), map5(), map6() ecc. Invece, purrr fornisce pmap() che prende una lista di argomenti. Potreste usarlo se voleste variare la media, la deviazione standard e il numero di campioni:Questo sembra:Se non nominate gli elementi della lista, pmap() userà la corrispondenza posizionale quando chiama la funzione. Questo è un po’ fragile e rende il codice più difficile da leggere, quindi è meglio nominare gli argomenti:Questo genera chiamate più lunghe, ma più sicure:Poiché gli argomenti sono tutti della stessa lunghezza, ha senso memorizzarli un frame di dati:Non appena il vostro codice diventa complicato, penso che un data frame sia un buon approccio perché assicura che ogni colonna abbia un nome e sia della stessa lunghezza di tutte le altre colonne.","code":"\nmu <- list(5, 10, -3)\nmu %>% \n  map(rnorm, n = 5) %>% \n  str()\n#> List of 3\n#>  $ : num [1:5] 5.63 7.1 4.39 3.37 4.99\n#>  $ : num [1:5] 9.34 9.33 9.52 11.32 10.64\n#>  $ : num [1:5] -2.49 -4.75 -2.11 -2.78 -2.42\nsigma <- list(1, 5, 10)\nseq_along(mu) %>% \n  map(~rnorm(5, mu[[.]], sigma[[.]])) %>% \n  str()\n#> List of 3\n#>  $ : num [1:5] 4.82 5.74 4 2.06 5.72\n#>  $ : num [1:5] 6.51 0.529 10.381 14.377 12.269\n#>  $ : num [1:5] -11.51 2.66 8.52 -10.56 -7.89\nmap2(mu, sigma, rnorm, n = 5) %>% str()\n#> List of 3\n#>  $ : num [1:5] 3.83 4.52 5.12 3.23 3.59\n#>  $ : num [1:5] 13.55 3.8 8.16 12.31 8.39\n#>  $ : num [1:5] -15.872 -13.3 12.141 0.469 14.794\nmap2 <- function(x, y, f, ...) {\n  out <- vector(\"list\", length(x))\n  for (i in seq_along(x)) {\n    out[[i]] <- f(x[[i]], y[[i]], ...)\n  }\n  out\n}\nn <- list(1, 3, 5)\nargs1 <- list(n, mu, sigma)\nargs1 %>%\n  pmap(rnorm) %>% \n  str()\n#> List of 3\n#>  $ : num 5.39\n#>  $ : num [1:3] 5.41 2.08 9.58\n#>  $ : num [1:5] -23.85 -2.96 -6.56 8.46 -5.21\nargs2 <- list(mean = mu, sd = sigma, n = n)\nargs2 %>% \n  pmap(rnorm) %>% \n  str()\nparams <- tribble(\n  ~mean, ~sd, ~n,\n    5,     1,  1,\n   10,     5,  3,\n   -3,    10,  5\n)\nparams %>% \n  pmap(rnorm)\n#> [[1]]\n#> [1] 6.018179\n#> \n#> [[2]]\n#> [1]  8.681404 18.292712  6.129566\n#> \n#> [[3]]\n#> [1] -12.239379  -5.755334  -8.933997  -4.222859   8.797842"},{"path":"iterazioni.html","id":"invocare-diverse-funzioni","chapter":"21 Iterazioni","heading":"21.7.1 Invocare diverse funzioni","text":"C’è un ulteriore passo avanti nella complessità: oltre variare gli argomenti della funzione, potreste anche variare la funzione stessa:Per gestire questo caso, potete usare invoke_map():Il primo argomento è una lista di funzioni o un vettore di caratteri di nomi di funzioni. Il secondo argomento è una lista di liste che danno gli argomenti che variano per ogni funzione. Gli argomenti successivi sono passati ad ogni funzione.E ancora, potete usare tribble() per rendere la creazione di queste coppie di argomenti un po’ più facile:","code":"\nf <- c(\"runif\", \"rnorm\", \"rpois\")\nparam <- list(\n  list(min = -1, max = 1), \n  list(sd = 5), \n  list(lambda = 10)\n)\ninvoke_map(f, param, n = 5) %>% str()\n#> Warning: `invoke_map()` was deprecated in purrr 1.0.0.\n#> ℹ Please use map() + exec() instead.\n#> List of 3\n#>  $ : num [1:5] 0.479 0.439 -0.471 0.348 -0.581\n#>  $ : num [1:5] 2.48 3.9 7.54 -9.12 3.94\n#>  $ : int [1:5] 6 11 5 8 9\nsim <- tribble(\n  ~f,      ~params,\n  \"runif\", list(min = -1, max = 1),\n  \"rnorm\", list(sd = 5),\n  \"rpois\", list(lambda = 10)\n)\nsim %>% \n  mutate(sim = invoke_map(f, params, n = 10))"},{"path":"iterazioni.html","id":"walk","chapter":"21 Iterazioni","heading":"21.8 Walk","text":"Walk è un’alternativa map che si usa quando si vuole chiamare una funzione per suoi effetti collaterali, piuttosto che per il suo valore di ritorno. Di solito lo fai perché vuoi rendere l’output sullo schermo o salvare file su disco - la cosa importante è l’azione, non il valore di ritorno. Ecco un esempio molto semplice:walk() non è generalmente molto utile rispetto walk2() o pwalk(). Per esempio, se avete una lista di trame e un vettore di nomi di file, potreste usare pwalk() per salvare ogni file nella posizione corrispondente sul disco:walk(), walk2() e pwalk() restituiscono tutti invisibilmente .x, il primo argomento. Questo li rende adatti ’uso nel mezzo delle pipeline.","code":"\nx <- list(1, \"a\", 3)\n\nx %>% \n  walk(print)\n#> [1] 1\n#> [1] \"a\"\n#> [1] 3\nlibrary(ggplot2)\nplots <- mtcars %>% \n  split(.$cyl) %>% \n  map(~ggplot(., aes(mpg, wt)) + geom_point())\npaths <- stringr::str_c(names(plots), \".pdf\")\n\npwalk(list(paths, plots), ggsave, path = tempdir())"},{"path":"iterazioni.html","id":"altri-modelli-di-cicli-for","chapter":"21 Iterazioni","heading":"21.9 Altri modelli di cicli for","text":"Purrr fornisce un certo numero di altre funzioni che astraggono da altri tipi di cicli . Le userai meno frequentemente delle funzioni di mappa, ma sono utili da conoscere. L’obiettivo qui è di illustrare brevemente ogni funzione, così speriamo che vi venga mente se vedete un problema simile futuro. Poi si può andare cercare la documentazione per maggiori dettagli.","code":""},{"path":"iterazioni.html","id":"funzioni-predicate","chapter":"21 Iterazioni","heading":"21.9.1 Funzioni predicate","text":"Un certo numero di funzioni lavorano con funzioni predicate che restituiscono un singolo TRUE o FALSE.Le funzioni keep() e discard() mantengono gli elementi dell’input dove il predicato è rispettivamente TRUE o FALSE:() e every() determinano se il predicato è vero per qualsiasi o per tutti gli elementi.detect() trova il primo elemento cui il predicato è vero; detect_index() restituisce la sua posizione.head_while() e tail_while() prendono elementi dall’inizio o dalla fine di un vettore mentre un predicato è vero:","code":"\niris %>% \n  keep(is.factor) %>% \n  str()\n#> 'data.frame':    150 obs. of  1 variable:\n#>  $ Species: Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\niris %>% \n  discard(is.factor) %>% \n  str()\n#> 'data.frame':    150 obs. of  4 variables:\n#>  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#>  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#>  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#>  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\nx <- list(1:5, letters, list(10))\n\nx %>% \n  some(is_character)\n#> [1] TRUE\n\nx %>% \n  every(is_vector)\n#> [1] TRUE\nx <- sample(10)\nx\n#>  [1] 10  6  1  3  2  4  5  8  9  7\n\nx %>% \n  detect(~ . > 5)\n#> [1] 10\n\nx %>% \n  detect_index(~ . > 5)\n#> [1] 1\nx %>% \n  head_while(~ . > 5)\n#> [1] 10  6\n\nx %>% \n  tail_while(~ . > 5)\n#> [1] 8 9 7"},{"path":"iterazioni.html","id":"ridurre-e-accumulare","chapter":"21 Iterazioni","heading":"21.9.2 Ridurre e accumulare","text":"volte si ha una lista complessa che si vuole ridurre ad una lista semplice applicando ripetutamente una funzione che riduce una coppia ad un singoletto. Questo è utile se si vuole applicare un verbo di dplyr due tabelle più tabelle. Per esempio, potreste avere una lista di frame di dati, e volete ridurla ad un singolo frame di dati unendo gli elementi insieme:O forse avete una lista di vettori e volete trovare l’intersezione:La funzione reduce() prende una funzione “binaria” (cioè una funzione con due input primari), e la applica ripetutamente ad una lista finché non rimane un solo elemento.La funzione accumulate() è simile, ma mantiene tutti risultati intermedi. Potreste usarla per implementare una somma cumulativa:","code":"\ndfs <- list(\n  age = tibble(name = \"John\", age = 30),\n  sex = tibble(name = c(\"John\", \"Mary\"), sex = c(\"M\", \"F\")),\n  trt = tibble(name = \"Mary\", treatment = \"A\")\n)\n\ndfs %>% reduce(full_join)\n#> Joining with `by = join_by(name)`\n#> Joining with `by = join_by(name)`\n#> # A tibble: 2 × 4\n#>   name    age sex   treatment\n#>   <chr> <dbl> <chr> <chr>    \n#> 1 John     30 M     <NA>     \n#> 2 Mary     NA F     A\nvs <- list(\n  c(1, 3, 5, 6, 10),\n  c(1, 2, 3, 7, 8, 10),\n  c(1, 2, 3, 4, 8, 9, 10)\n)\n\nvs %>% reduce(intersect)\n#> [1]  1  3 10\nx <- sample(10)\nx\n#>  [1]  7  5 10  9  8  3  1  4  2  6\nx %>% accumulate(`+`)\n#>  [1]  7 12 22 31 39 42 43 47 49 55"},{"path":"iterazioni.html","id":"esercizi-62","chapter":"21 Iterazioni","heading":"21.9.3 Esercizi","text":"Implementate la vostra versione di every() usando un ciclo . Confrontatela con purrr::every(). Cosa fa la versione di Purrr che la vostra non fa?Implementate la vostra versione di every() usando un ciclo . Confrontatela con purrr::every(). Cosa fa la versione di Purrr che la vostra non fa?Create un col_summary() migliorato che applica una funzione di riepilogo ad ogni colonna numerica un frame di dati.Create un col_summary() migliorato che applica una funzione di riepilogo ad ogni colonna numerica un frame di dati.Un possibile equivalente R di base di col_summary() è:\n\ncol_sum3 <- function(df, f) {\n  is_num <- sapply(df, .numeric)\n  df_num <- df[, is_num]\n\n  sapply(df_num, f)\n}\nMa ha una serie di bug come illustrato con seguenti input:\n\ndf <- tibble(\n  x = 1:3, \n  y = 3:1,\n  z = c(\"\", \"b\", \"c\")\n)\n# OK\ncol_sum3(df, mean)\n# Ha problemi: non sempre restituisce un vettore numerico\ncol_sum3(df[1:2], mean)\ncol_sum3(df[1], mean)\ncol_sum3(df[0], mean)\nCosa causa bug?Un possibile equivalente R di base di col_summary() è:Ma ha una serie di bug come illustrato con seguenti input:Cosa causa bug?","code":"\ncol_sum3 <- function(df, f) {\n  is_num <- sapply(df, is.numeric)\n  df_num <- df[, is_num]\n\n  sapply(df_num, f)\n}\ndf <- tibble(\n  x = 1:3, \n  y = 3:1,\n  z = c(\"a\", \"b\", \"c\")\n)\n# OK\ncol_sum3(df, mean)\n# Ha problemi: non sempre restituisce un vettore numerico\ncol_sum3(df[1:2], mean)\ncol_sum3(df[1], mean)\ncol_sum3(df[0], mean)"},{"path":"model-intro.html","id":"model-intro","chapter":"22 Introduzione","heading":"22 Introduzione","text":"Ora che siete dotati di potenti strumenti di programmazione possiamo finalmente tornare alla modellazione. Userete vostri nuovi strumenti di gestione dei dati e di programmazione per adattare molti modelli e capire come funzionano. Il focus di questo libro è l’esplorazione, non la conferma o l’inferenza formale. Ma imparerete alcuni strumenti di base che vi aiuteranno capire la variazione ’interno dei vostri modelli.L’obiettivo di un modello è quello di fornire un semplice riassunto bassa dimesionalità di un set di dati. Idealmente, il modello catturerà veri “segnali” (cioè modelli generati dal fenomeno di interesse), e ignorerà il “rumore” (cioè la variazione casuale che non vi interessa). Qui ci occupiamo solo dei modelli “predittivi”, che, come suggerisce il nome, generano previsioni. C’è un altro tipo di modello che non discuteremo: modelli “data discovery”. Questi modelli non fanno previsioni, ma vi aiutano scoprire relazioni interessanti ’interno dei vostri dati. (Queste due categorie di modelli sono talvolta chiamate supervisionate e non supervisionate, ma non credo che questa terminologia sia particolarmente illuminante).Questo libro non vi darà una profonda comprensione della teoria matematica che sta alla base dei modelli. Tuttavia, costruirà la vostra intuizione su come funzionano modelli statistici e vi darà una famiglia di strumenti utili che vi permetteranno di usare modelli per capire meglio vostri dati:modelli base, imparerete come funzionano meccanicamente modelli, concentrandovi su\nl’importante famiglia dei modelli lineari. Imparerete strumenti generali per ottenere\ncomprensione di ciò che un modello predittivo ti dice sui tuoi dati, concentrandoti su\nsemplici insiemi di dati simulati.modelli base, imparerete come funzionano meccanicamente modelli, concentrandovi su\nl’importante famiglia dei modelli lineari. Imparerete strumenti generali per ottenere\ncomprensione di ciò che un modello predittivo ti dice sui tuoi dati, concentrandoti su\nsemplici insiemi di dati simulati.costruire modelli, imparerete come usare modelli per estrarre modelli noti\nmodelli nei dati reali. Una volta riconosciuto un modello importante\nè utile renderlo esplicito un modello, perché allora si possono\npiù facilmente vedere segnali più sottili che rimangono.costruire modelli, imparerete come usare modelli per estrarre modelli noti\nmodelli nei dati reali. Una volta riconosciuto un modello importante\nè utile renderlo esplicito un modello, perché allora si possono\npiù facilmente vedere segnali più sottili che rimangono.molti modelli, imparerai come usare molti modelli semplici per aiutare\ncomprendere insiemi di dati complessi. Questa è una tecnica potente, ma per accedervi\nma per accedervi è necessario combinare strumenti di modellazione e programmazione.molti modelli, imparerai come usare molti modelli semplici per aiutare\ncomprendere insiemi di dati complessi. Questa è una tecnica potente, ma per accedervi\nma per accedervi è necessario combinare strumenti di modellazione e programmazione.Questi argomenti sono notevoli per quello che non includono: qualsiasi strumento per valutare quantitativamente modelli. Questo è deliberato: quantificare precisamente un modello richiede un paio di grandi idee che non abbiamo lo spazio per coprire qui. Per ora, farete affidamento sulla valutazione qualitativa e sul vostro naturale scetticismo. Imparare di più sui modelli, vi indicheremo altre risorse dove potrete imparare di più.","code":""},{"path":"model-intro.html","id":"generazione-di-ipotesi-vs.-conferma-di-ipotesi","chapter":"22 Introduzione","heading":"22.1 Generazione di ipotesi vs. conferma di ipotesi","text":"questo libro, useremo modelli come strumento di esplorazione, completando la triade degli strumenti per l’analisi esplorativa dei dati (EDA) che sono stati introdotti nella Parte 1. Questo non è il modo cui modelli vengono solitamente insegnati, ma come vedrete, modelli sono uno strumento importante per l’esplorazione. Tradizionalmente, il focus della modellazione è sull’inferenza, o per confermare che un’ipotesi è vera. Fare questo correttamente non è complicato, ma è difficile. Ci sono un paio di idee che dovete capire per fare l’inferenza correttamente:Ogni osservazione può essere usata o per l’esplorazione o per la conferma,\nnon per entrambe.Ogni osservazione può essere usata o per l’esplorazione o per la conferma,\nnon per entrambe.Puoi usare un’osservazione quante volte vuoi per l’esplorazione,\nma puoi usarla solo una volta per la conferma. Non appena usi un’osservazione\nosservazione due volte, si è passati dalla conferma ’esplorazione.Puoi usare un’osservazione quante volte vuoi per l’esplorazione,\nma puoi usarla solo una volta per la conferma. Non appena usi un’osservazione\nosservazione due volte, si è passati dalla conferma ’esplorazione.Questo è necessario perché per confermare un’ipotesi dovete usare dati indipendenti dai dati che avete usato per generare l’ipotesi. Altrimenti sarete troppo ottimisti. Non c’è assolutamente nulla di sbagliato nell’esplorazione, ma non dovreste mai vendere un’analisi esplorativa come un’analisi di conferma perché è fondamentalmente fuorviante.Se siete seriamente intenzionati fare un’analisi confermativa, un approccio è quello di dividere vostri dati tre parti prima di iniziare l’analisi:Il 60% dei vostri dati va un training (o set di esplorazione). Siete autorizzati \npermesso di fare tutto quello che vuoi con questi dati: visualizzarli e adattarvi tonnellate\ndi modelli.Il 60% dei vostri dati va un training (o set di esplorazione). Siete autorizzati \npermesso di fare tutto quello che vuoi con questi dati: visualizzarli e adattarvi tonnellate\ndi modelli.Il 20% va un set di query. Puoi usare questi dati per confrontare modelli\no visualizzazioni mano, ma non ti è permesso usarli come parte di\nun processo automatizzato.Il 20% va un set di query. Puoi usare questi dati per confrontare modelli\no visualizzazioni mano, ma non ti è permesso usarli come parte di\nun processo automatizzato.Il 20% viene trattenuto per un test set. Puoi usare questi dati solo UNA VOLTA, per\ntestare il vostro modello finale.Il 20% viene trattenuto per un test set. Puoi usare questi dati solo UNA VOLTA, per\ntestare il vostro modello finale.Questo partizionamento vi permette di esplorare dati di addestramento, generando occasionalmente ipotesi candidate che controllate con il set di query. Quando siete sicuri di avere il modello giusto, potete controllarlo una volta con dati di test.(Si noti che anche quando si fa la modellazione confermativa, è necessario fare l’EDA. Se non fate nessuna EDA rimarrete ciechi ai problemi di qualità dei vostri dati).","code":""},{"path":"modelli-base.html","id":"modelli-base","chapter":"23 Modelli base","heading":"23 Modelli base","text":"","code":""},{"path":"modelli-base.html","id":"introduzione-15","chapter":"23 Modelli base","heading":"23.1 Introduzione","text":"L’obiettivo di un modello è quello di fornire un semplice riassunto bassa dimesionalità di un set di dati. Nel contesto di questo libro useremo modelli per dividere dati modelli e residui. modelli forti nasconderanno tendenze più sottili, quindi useremo modelli per aiutarci rimuovere livelli di struttura mentre esploriamo un set di dati.Tuttavia, prima di iniziare usare modelli su serie di dati interessanti e reali, è necessario comprendere le basi del funzionamento dei modelli. Per questo motivo, questo capitolo del libro è unico perché utilizza solo set di dati simulati. Questi set di dati sono molto semplici, e per niente interessanti, ma vi aiuteranno capire l’essenza della modellazione prima di applicare le stesse tecniche ai dati reali nel prossimo capitolo.Ci sono due parti un modello:Primo, si definisce una famiglia di modelli che esprimono un modello preciso, ma\nmodello preciso, ma generico, che si vuole catturare. Per esempio, il modello\npotrebbe essere una linea retta o una curva quadratica. Esprimerai\nla famiglia di modelli come un’equazione come y = a_1 * x + a_2 o\ny = a_1 * x ^ a_2. Qui, x e y sono variabili conosciute dai tuoi\ndati, e a_1 e a_2 sono parametri che possono variare per catturare\nmodelli diversi.Primo, si definisce una famiglia di modelli che esprimono un modello preciso, ma\nmodello preciso, ma generico, che si vuole catturare. Per esempio, il modello\npotrebbe essere una linea retta o una curva quadratica. Esprimerai\nla famiglia di modelli come un’equazione come y = a_1 * x + a_2 o\ny = a_1 * x ^ a_2. Qui, x e y sono variabili conosciute dai tuoi\ndati, e a_1 e a_2 sono parametri che possono variare per catturare\nmodelli diversi.Poi, si genera un modello adattato trovando il modello dalla\nfamiglia che si avvicina di più ai vostri dati. Questo prende il modello generico\ngenerico e lo rende specifico, come y = 3 * x + 7 o y = 9 * x ^ 2.Poi, si genera un modello adattato trovando il modello dalla\nfamiglia che si avvicina di più ai vostri dati. Questo prende il modello generico\ngenerico e lo rende specifico, come y = 3 * x + 7 o y = 9 * x ^ 2.È importante capire che un modello adattato è solo il modello più vicino da una famiglia di modelli. Questo implica che si ha il modello “migliore” (secondo alcuni criteri); non implica che si abbia un buon modello e certamente non implica che il modello sia “vero”. George Box lo dice bene nel suo famoso aforisma:Tutti modelli sono sbagliati, ma alcuni sono utili.Vale la pena leggere il contesto più completo della citazione:Ora sarebbe davvero notevole se qualsiasi sistema esistente nel mondo reale\npotesse essere rappresentato esattamente da un qualsiasi modello semplice. Tuttavia, modelli astutamente scelti\nmodelli parsimoniosi spesso forniscono approssimazioni notevolmente utili. Per\nesempio, la legge PV = RT che mette relazione pressione P, volume V e temperatura T di\nun gas “ideale” attraverso una costante R non è esattamente vera per qualsiasi gas reale, ma\nspesso fornisce un’approssimazione utile e inoltre la sua struttura è\ninformativa poiché scaturisce da una visione fisica del comportamento delle molecole di gas\nmolecole di gas.Per un tale modello non c’è bisogno di porre la domanda “Il modello è vero?\nSe la”verità” deve essere “tutta la verità”, la risposta deve essere “”. L’unica\ndomanda di interesse è “Il modello è illuminante e utile?”.L’obiettivo di un modello non è quello di scoprire la verità, ma di scoprire una semplice approssimazione che sia ancora utile.","code":""},{"path":"modelli-base.html","id":"prerequisiti-15","chapter":"23 Modelli base","heading":"23.1.1 Prerequisiti","text":"questo capitolo useremo il pacchetto modelr che avvolge le funzioni di modellazione di base di R per farle lavorare naturalmente un tubo.","code":"\nlibrary(tidyverse)\n\nlibrary(modelr)\noptions(na.action = na.warn)"},{"path":"modelli-base.html","id":"un-modello-semplice","chapter":"23 Modelli base","heading":"23.2 Un modello semplice","text":"Diamo un’occhiata al dataset simulato sim1, incluso nel pacchetto modelr. Contiene due variabili continue, x e y. Tracciamo il loro grafico per vedere come sono correlati:Si può vedere un forte modello nei dati. Usiamo un modello per catturare quel modello e renderlo esplicito. È nostro compito fornire la forma base del modello. questo caso, la relazione sembra lineare, cioè y = a_0 + a_1 * x. Cominciamo farci un’idea di come sono modelli di questa famiglia generandone alcuni caso e sovrapponendoli ai dati. Per questo semplice caso, possiamo usare geom_abline() che prende una pendenza e un’intercetta come parametri. Più avanti impareremo tecniche più generali che funzionano con qualsiasi modello.Ci sono 250 modelli su questo grafico, ma molti sono davvero pessimi! Dobbiamo trovare buoni modelli rendendo precisa la nostra intuizione che un buon modello è “vicino” ai dati. Abbiamo bisogno di un modo per quantificare la distanza tra dati e un modello. Poi possiamo adattare il modello trovando il valore di a_0 e a_1 che genera il modello con la minore distanza dai dati.Un facile punto di partenza è trovare la distanza verticale tra ogni punto e il modello, come nel seguente diagramma. (Nota che ho spostato leggermente valori x modo che tu possa vedere le singole distanze).Questa distanza è semplicemente la differenza tra il valore y dato dal modello (la predizione) e il valore y reale nei dati (la risposta).Per calcolare questa distanza, prima trasformiamo la nostra famiglia di modelli una funzione R. Questa prende parametri del modello e dati come input, e dà come output valori predetti dal modello:Poi, abbiamo bisogno di un modo per calcolare una distanza complessiva tra valori previsti e quelli reali. altre parole, il grafico sopra mostra 30 distanze: come facciamo farle collassare un singolo numero?Un modo comune per farlo statistica è usare la “deviazione media della radice quadrata”. Si calcola la differenza tra il reale e il previsto, si eleva al quadrato, si fa la media e si prende la radice quadrata. Questa distanza ha un sacco di interessanti proprietà matematiche, di cui non parleremo qui. Dovrete fidarvi della mia parola!Ora possiamo usare purrr per calcolare la distanza per tutti modelli definiti sopra. Abbiamo bisogno di una funzione di aiuto perché la nostra funzione di distanza si aspetta il modello come un vettore numerico di lunghezza 2.Poi, sovrapponiamo 10 migliori modelli ai dati. Ho colorato modelli per -dist: questo è un modo semplice per assicurarsi che modelli migliori (cioè quelli con la distanza minore) abbiano colori più brillanti.Possiamo anche pensare questi modelli come delle osservazioni, e visualizzarli con uno scatterplot di a1 vs a2, sempre colorato da -dist. Non possiamo più vedere direttamente come il modello si confronta con dati, ma possiamo vedere molti modelli contemporaneamente. Di nuovo, ho evidenziato 10 modelli migliori, questa volta disegnando dei cerchi rossi sotto di essi.Invece di provare molti modelli casuali, potremmo essere più sistematici e generare una griglia di punti uniformemente distanziati (questa è chiamata ricerca griglia). Ho scelto parametri della griglia modo approssimativo guardando dove si trovavano migliori modelli nel grafico sopra.Quando si sovrappongono migliori 10 modelli ai dati originali, tutti sembrano abbastanza buoni:Si potrebbe immaginare di rendere iterativamente la griglia sempre più fine fino restringere il modello migliore. Ma c’è un modo migliore per affrontare questo problema: uno strumento di minimizzazione numerica chiamato ricerca Newton-Raphson. L’intuizione di Newton-Raphson è piuttosto semplice: si sceglie un punto di partenza e si cerca il pendio più ripido. Poi si scia giù per quel pendio un po’, e poi si ripete ancora e ancora, finché non si può scendere più basso. R, possiamo farlo con optim():Non preoccupatevi troppo dei dettagli di come funziona optim(). È l’intuizione che è importante qui. Se avete una funzione che definisce la distanza tra un modello e un set di dati, un algoritmo che può minimizzare tale distanza modificando parametri del modello, potete trovare il modello migliore. La cosa bella di questo approccio è che funzionerà per qualsiasi famiglia di modelli per cui è possibile scrivere un’equazione.C’è un altro approccio che possiamo usare per questo modello, perché è un caso speciale di una famiglia più ampia: modelli lineari. Un modello lineare ha la forma generale y = a_1 + a_2 * x_1 + a_3 * x_2 + ... + a_n * x_(n - 1). Quindi questo semplice modello è equivalente un modello lineare generale dove n è 2 e x_1 è x. R ha uno strumento specificamente progettato per l’adattamento di modelli lineari chiamato lm(). lm() ha un modo speciale per specificare la famiglia di modelli: le formule. Le formule assomigliano y ~ x, che lm() tradurrà una funzione come y = a_1 + a_2 * x. Possiamo adattare il modello e guardare l’output:Questi sono esattamente gli stessi valori che abbiamo ottenuto con optim()! Dietro le quinte lm() non usa optim() ma sfrutta invece la struttura matematica dei modelli lineari. Usando alcune connessioni tra geometria, calcolo e algebra lineare, lm() trova effettivamente il modello più vicino un solo passo, usando un algoritmo sofisticato. Questo approccio è più veloce e garantisce che ci sia un minimo globale.","code":"\nggplot(sim1, aes(x, y)) + \n  geom_point()\nmodels <- tibble(\n  a1 = runif(250, -20, 40),\n  a2 = runif(250, -5, 5)\n)\n\nggplot(sim1, aes(x, y)) + \n  geom_abline(aes(intercept = a1, slope = a2), data = models, alpha = 1/4) +\n  geom_point() \nmodel1 <- function(a, data) {\n  a[1] + data$x * a[2]\n}\nmodel1(c(7, 1.5), sim1)\n#>  [1]  8.5  8.5  8.5 10.0 10.0 10.0 11.5 11.5 11.5 13.0 13.0 13.0 14.5 14.5 14.5\n#> [16] 16.0 16.0 16.0 17.5 17.5 17.5 19.0 19.0 19.0 20.5 20.5 20.5 22.0 22.0 22.0\nmeasure_distance <- function(mod, data) {\n  diff <- data$y - model1(mod, data)\n  sqrt(mean(diff ^ 2))\n}\nmeasure_distance(c(7, 1.5), sim1)\n#> [1] 2.665212\nsim1_dist <- function(a1, a2) {\n  measure_distance(c(a1, a2), sim1)\n}\n\nmodels <- models %>% \n  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))\nmodels\n#> # A tibble: 250 × 3\n#>       a1      a2  dist\n#>    <dbl>   <dbl> <dbl>\n#> 1 -15.2   0.0889  30.8\n#> 2  30.1  -0.827   13.2\n#> 3  16.0   2.27    13.2\n#> 4 -10.6   1.38    18.7\n#> 5 -19.6  -1.04    41.8\n#> 6   7.98  4.59    19.3\n#> # … with 244 more rows\nggplot(sim1, aes(x, y)) + \n  geom_point(size = 2, colour = \"grey30\") + \n  geom_abline(\n    aes(intercept = a1, slope = a2, colour = -dist), \n    data = filter(models, rank(dist) <= 10)\n  )\nggplot(models, aes(a1, a2)) +\n  geom_point(data = filter(models, rank(dist) <= 10), size = 4, colour = \"red\") +\n  geom_point(aes(colour = -dist))\ngrid <- expand.grid(\n  a1 = seq(-5, 20, length = 25),\n  a2 = seq(1, 3, length = 25)\n  ) %>% \n  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))\n\ngrid %>% \n  ggplot(aes(a1, a2)) +\n  geom_point(data = filter(grid, rank(dist) <= 10), size = 4, colour = \"red\") +\n  geom_point(aes(colour = -dist)) \nggplot(sim1, aes(x, y)) + \n  geom_point(size = 2, colour = \"grey30\") + \n  geom_abline(\n    aes(intercept = a1, slope = a2, colour = -dist), \n    data = filter(grid, rank(dist) <= 10)\n  )\nbest <- optim(c(0, 0), measure_distance, data = sim1)\nbest$par\n#> [1] 4.222248 2.051204\n\nggplot(sim1, aes(x, y)) + \n  geom_point(size = 2, colour = \"grey30\") + \n  geom_abline(intercept = best$par[1], slope = best$par[2])\nsim1_mod <- lm(y ~ x, data = sim1)\ncoef(sim1_mod)\n#> (Intercept)           x \n#>    4.220822    2.051533"},{"path":"modelli-base.html","id":"esercizi-63","chapter":"23 Modelli base","heading":"23.2.1 Esercizi","text":"Uno svantaggio del modello lineare è che è sensibile valori insoliti perché la distanza incorpora un termine quadratico. Adattate un modello lineare ai dati simulati qui sotto e visualizzate risultati. Esegui un paio di volte per generare diversi set di dati simulati. Cosa notate del modello?\n\nsim1a <- tibble(\n  x = rep(1:10, = 3),\n  y = x * 1.5 + 6 + rt(length(x), df = 2)\n)Uno svantaggio del modello lineare è che è sensibile valori insoliti perché la distanza incorpora un termine quadratico. Adattate un modello lineare ai dati simulati qui sotto e visualizzate risultati. Esegui un paio di volte per generare diversi set di dati simulati. Cosa notate del modello?Un modo per rendere modelli lineari più robusti è usare una misura di distanza diversa. Per esempio, invece della distanza radice-media quadrata, si potrebbe usare la distanza media-assoluta:\n\nmeasure_distance <- function(mod, data) {\n  diff <- data$y - model1(mod, data)\n  mean(abs(diff))\n}\nUsate optim() per adattare questo modello ai dati simulati sopra e confrontatelo con il modello lineare.Un modo per rendere modelli lineari più robusti è usare una misura di distanza diversa. Per esempio, invece della distanza radice-media quadrata, si potrebbe usare la distanza media-assoluta:Usate optim() per adattare questo modello ai dati simulati sopra e confrontatelo con il modello lineare.Una sfida nell’eseguire l’ottimizzazione numerica è che è garantito di trovare solo un ottimo locale. Qual è il problema dell’ottimizzazione di un modello tre parametri come questo?\n\nmodel1 <- function(, data) {\n  [1] + data$x * [2] + [3]\n}Una sfida nell’eseguire l’ottimizzazione numerica è che è garantito di trovare solo un ottimo locale. Qual è il problema dell’ottimizzazione di un modello tre parametri come questo?","code":"\nsim1a <- tibble(\n  x = rep(1:10, each = 3),\n  y = x * 1.5 + 6 + rt(length(x), df = 2)\n)\nmeasure_distance <- function(mod, data) {\n  diff <- data$y - model1(mod, data)\n  mean(abs(diff))\n}\nmodel1 <- function(a, data) {\n  a[1] + data$x * a[2] + a[3]\n}"},{"path":"modelli-base.html","id":"visualizzare-i-modelli","chapter":"23 Modelli base","heading":"23.3 Visualizzare i modelli","text":"Per modelli semplici, come quello di cui sopra, è possibile capire quale modello cattura studiando attentamente la famiglia del modello e coefficienti montati. E se si segue un corso di statistica sulla modellizzazione, è probabile che si passi molto tempo fare proprio questo. Qui, tuttavia, prenderemo una strada diversa. Ci concentreremo sulla comprensione di un modello guardando le sue previsioni. Questo ha un grande vantaggio: ogni tipo di modello predittivo fa delle previsioni (altrimenti cosa servirebbe?) quindi possiamo usare lo stesso set di tecniche per capire qualsiasi tipo di modello predittivo.È anche utile vedere ciò che il modello non cattura, cosiddetti residui che rimangono dopo aver sottratto le previsioni dai dati. residui sono potenti perché ci permettono di usare modelli per rimuovere modelli eclatanti modo da poter studiare le tendenze più sottili che rimangono.","code":""},{"path":"modelli-base.html","id":"previsioni","chapter":"23 Modelli base","heading":"23.3.1 Previsioni","text":"Per visualizzare le previsioni di un modello, iniziamo generando una griglia di valori uniformemente distanziati che copra la regione cui si trovano nostri dati. Il modo più semplice per farlo è usare modelr::data_grid(). Il suo primo argomento è un frame di dati, e per ogni argomento successivo trova le variabili uniche e poi genera tutte le combinazioni:(Questo diventerà più interessante quando inizieremo ad aggiungere più variabili al nostro modello).Poi aggiungiamo le predizioni. Useremo modelr::add_predictions() che prende un data frame e un modello. Aggiunge le predizioni dal modello ad una nuova colonna nel data frame:(Potete anche usare questa funzione per aggiungere previsioni al vostro set di dati originale).Poi, tracciamo le previsioni. Potreste chiedervi tutto questo lavoro extra rispetto al semplice utilizzo di geom_abline(). Ma il vantaggio di questo approccio è che funzionerà con qualsiasi modello R, dal più semplice al più complesso. Siete limitati solo dalle vostre capacità di visualizzazione. Per altre idee su come visualizzare tipi di modelli più complessi, potreste provare http://vita..co.nz/papers/model-vis.html.","code":"\ngrid <- sim1 %>% \n  data_grid(x) \ngrid\n#> # A tibble: 10 × 1\n#>       x\n#>   <int>\n#> 1     1\n#> 2     2\n#> 3     3\n#> 4     4\n#> 5     5\n#> 6     6\n#> # … with 4 more rows\ngrid <- grid %>% \n  add_predictions(sim1_mod) \ngrid\n#> # A tibble: 10 × 2\n#>       x  pred\n#>   <int> <dbl>\n#> 1     1  6.27\n#> 2     2  8.32\n#> 3     3 10.4 \n#> 4     4 12.4 \n#> 5     5 14.5 \n#> 6     6 16.5 \n#> # … with 4 more rows\nggplot(sim1, aes(x)) +\n  geom_point(aes(y = y)) +\n  geom_line(aes(y = pred), data = grid, colour = \"red\", size = 1)\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead."},{"path":"modelli-base.html","id":"residui","chapter":"23 Modelli base","heading":"23.3.2 Residui","text":"Il rovescio della medaglia delle previsioni sono residui. Le previsioni ti dicono il modello che il modello ha catturato, e residui ti dicono cosa il modello ha mancato. residui sono solo le distanze tra valori osservati e quelli previsti che abbiamo calcolato sopra.Aggiungiamo residui ai dati con add_residuals(), che funziona come add_predictions(). Si noti, tuttavia, che usiamo il dataset originale, non una griglia costruita. Questo perché per calcolare residui abbiamo bisogno dei valori reali di y.Ci sono alcuni modi diversi per capire cosa ci dicono residui sul modello. Un modo è semplicemente disegnare un poligono di frequenza per aiutarci capire la diffusione dei residui:Questo vi aiuta calibrare la qualità del modello: quanto sono lontane le previsioni dai valori osservati? Notate che la media del residuo sarà sempre 0.Spesso vorrete ricreare dei grafici usando residui invece del predittore originale. Vedrete molto di questo nel prossimo capitolo.Questo sembra un rumore casuale, suggerendo che il nostro modello ha fatto un buon lavoro nel catturare modelli nel set di dati.","code":"\nsim1 <- sim1 %>% \n  add_residuals(sim1_mod)\nsim1\n#> # A tibble: 30 × 3\n#>       x     y  resid\n#>   <int> <dbl>  <dbl>\n#> 1     1  4.20 -2.07 \n#> 2     1  7.51  1.24 \n#> 3     1  2.13 -4.15 \n#> 4     2  8.99  0.665\n#> 5     2 10.2   1.92 \n#> 6     2 11.3   2.97 \n#> # … with 24 more rows\nggplot(sim1, aes(resid)) + \n  geom_freqpoly(binwidth = 0.5)\nggplot(sim1, aes(x, resid)) + \n  geom_ref_line(h = 0) +\n  geom_point() "},{"path":"modelli-base.html","id":"esercizi-64","chapter":"23 Modelli base","heading":"23.3.3 Esercizi","text":"Invece di usare lm() per adattare una linea retta, potete usare loess()\nper adattare una curva liscia. 2. Ripetete il processo di adattamento del modello,\ngenerazione della griglia, previsioni e visualizzazione su sim1 usando\nloess() invece di lm(). Come si confronta il risultato con\ngeom_smooth()?Invece di usare lm() per adattare una linea retta, potete usare loess()\nper adattare una curva liscia. 2. Ripetete il processo di adattamento del modello,\ngenerazione della griglia, previsioni e visualizzazione su sim1 usando\nloess() invece di lm(). Come si confronta il risultato con\ngeom_smooth()?add_predictions()è abbinato gather_predictions() e\nspread_predictions(). Come differiscono queste tre funzioni?add_predictions()è abbinato gather_predictions() e\nspread_predictions(). Come differiscono queste tre funzioni?Cosa fa geom_ref_line()? Da quale pacchetto proviene?\nPerché la visualizzazione di una linea di riferimento nei grafici che mostrano residui è\nutile e importante?Cosa fa geom_ref_line()? Da quale pacchetto proviene?\nPerché la visualizzazione di una linea di riferimento nei grafici che mostrano residui è\nutile e importante?Perché potreste voler guardare un poligono di frequenza dei residui assoluti?\nQuali sono pro e contro rispetto al guardare residui grezzi?\nPerché potreste voler guardare un poligono di frequenza dei residui assoluti?Quali sono pro e contro rispetto al guardare residui grezzi?","code":""},{"path":"modelli-base.html","id":"formule-e-famiglie-di-modelli","chapter":"23 Modelli base","heading":"23.4 Formule e famiglie di modelli","text":"Avete già visto le formule quando usate facet_wrap() e facet_grid(). R, le formule forniscono un modo generale per ottenere un “comportamento speciale”. Piuttosto che valutare subito valori delle variabili, li catturano modo che possano essere interpretati dalla funzione.La maggior parte delle funzioni di modellazione R usa una conversione standard da formule funzioni. Avete già visto una semplice conversione: y ~ x viene tradotto y = a_1 + a_2 * x. Se volete vedere cosa fa effettivamente R, potete usare la funzione model_matrix(). Prende un data frame e una formula e restituisce una tibla che definisce l’equazione del modello: ogni colonna nell’output è associata un coefficiente nel modello, la funzione è sempre y = a_1 * out1 + a_2 * out_2. Per il caso più semplice di y ~ x1 questo ci mostra qualcosa di interessante:Il modo cui R aggiunge l’intercetta al modello è semplicemente avere una colonna piena di uno. Per impostazione predefinita, R aggiungerà sempre questa colonna. Se non volete, dovete eliminarla esplicitamente con -1:La matrice del modello cresce modo non sorprendente quando si aggiungono più variabili al modello:Questa notazione della formula è talvolta chiamata “notazione Wilkinson-Rogers”, ed è stata inizialmente descritta Symbolic Description Factorial Models Analysis Variance, di G. N. Wilkinson e C. E. Rogers https://www.jstor.org/stable/2346786. Vale la pena scavare e leggere l’articolo originale se volete capire tutti dettagli dell’algebra di modellazione.Le sezioni seguenti spiegano come funziona questa notazione della formula per le variabili categoriche, le interazioni e la trasformazione.","code":"\ndf <- tribble(\n  ~y, ~x1, ~x2,\n  4, 2, 5,\n  5, 1, 6\n)\nmodel_matrix(df, y ~ x1)\n#> # A tibble: 2 × 2\n#>   `(Intercept)`    x1\n#>           <dbl> <dbl>\n#> 1             1     2\n#> 2             1     1\nmodel_matrix(df, y ~ x1 - 1)\n#> # A tibble: 2 × 1\n#>      x1\n#>   <dbl>\n#> 1     2\n#> 2     1\nmodel_matrix(df, y ~ x1 + x2)\n#> # A tibble: 2 × 3\n#>   `(Intercept)`    x1    x2\n#>           <dbl> <dbl> <dbl>\n#> 1             1     2     5\n#> 2             1     1     6"},{"path":"modelli-base.html","id":"variabili-categoriche","chapter":"23 Modelli base","heading":"23.4.1 Variabili categoriche","text":"Generare una funzione da una formula è semplice quando il predittore è continuo, ma le cose diventano un po’ più complicate quando il predittore è categorico. Immaginate di avere una formula come y ~ sex, dove sex potrebbe essere maschio o femmina. Non ha senso convertirla una formula come y = x_0 + x_1 * sex perché sex non è un numero - non si può moltiplicare! Invece quello che R fa è convertirlo y = x_0 + x_1 * sex_male dove sex_male è uno se sex è maschio e zero altrimenti:Potresti chiederti perché R non crea anche una colonna sexfemale. Il problema è che creerebbe una colonna che è perfettamente prevedibile base alle altre colonne (cioè sexfemale = 1 - sexmale). Sfortunatamente dettagli esatti del perché questo è un problema vanno oltre lo scopo di questo libro, ma fondamentalmente crea una famiglia di modelli che è troppo flessibile, e avrà infiniti modelli che sono ugualmente vicini ai dati.Fortunatamente, però, se ci si concentra sulla visualizzazione delle previsioni non è necessario preoccuparsi della parametrizzazione esatta. Guardiamo alcuni dati e modelli per renderlo concreto. Ecco il dataset sim2 di modelr:Possiamo adattarvi un modello e generare delle previsioni:effetti, un modello con un x categorico predirà il valore medio per ogni categoria. (Perché? Perché la media minimizza la distanza radice-media-quadrata.) Questo è facile da vedere se sovrapponiamo le previsioni ai dati originali:Non puoi fare previsioni su livelli che non hai osservato. volte lo si fa per caso, quindi è bene riconoscere questo messaggio di errore:","code":"\ndf <- tribble(\n  ~ sex, ~ response,\n  \"male\", 1,\n  \"female\", 2,\n  \"male\", 1\n)\nmodel_matrix(df, response ~ sex)\n#> # A tibble: 3 × 2\n#>   `(Intercept)` sexmale\n#>           <dbl>   <dbl>\n#> 1             1       1\n#> 2             1       0\n#> 3             1       1\nggplot(sim2) + \n  geom_point(aes(x, y))\nmod2 <- lm(y ~ x, data = sim2)\n\ngrid <- sim2 %>% \n  data_grid(x) %>% \n  add_predictions(mod2)\ngrid\n#> # A tibble: 4 × 2\n#>   x      pred\n#>   <chr> <dbl>\n#> 1 a      1.15\n#> 2 b      8.12\n#> 3 c      6.13\n#> 4 d      1.91\nggplot(sim2, aes(x)) + \n  geom_point(aes(y = y)) +\n  geom_point(data = grid, aes(y = pred), colour = \"red\", size = 4)\ntibble(x = \"e\") %>% \n  add_predictions(mod2)\n#> Error in model.frame.default(Terms, newdata, na.action = na.action, xlev = object$xlevels): factor x has new level e"},{"path":"modelli-base.html","id":"interazioni-continue-e-categoriche","chapter":"23 Modelli base","heading":"23.4.2 Interazioni (continue e categoriche)","text":"Cosa succede quando combini una variabile continua e una categorica? sim3 contiene un predittore categorico e un predittore continuo. Possiamo visualizzarlo con un semplice grafico:Ci sono due possibili modelli da adattare questi dati:Quando si aggiungono variabili con +, il modello stima ogni effetto indipendente da tutti gli altri. È possibile adattare la cosiddetta interazione usando *. Per esempio, y ~ x1 * x2 si traduce y = a_0 + a_1 * x1 + a_2 * x2 + a_12 * x1 * x2. Nota che ogni volta che usi *, sia l’interazione che le singole componenti sono incluse nel modello.Per visualizzare questi modelli abbiamo bisogno di due nuovi trucchi:Abbiamo due predittori, quindi dobbiamo dare data_grid() entrambe le variabili.\nTrova tutti valori unici di x1 e x2 e poi genera tutte le\ncombinazioni.Abbiamo due predittori, quindi dobbiamo dare data_grid() entrambe le variabili.\nTrova tutti valori unici di x1 e x2 e poi genera tutte le\ncombinazioni.Per generare previsioni da entrambi modelli simultaneamente, possiamo usare\ngather_predictions() che aggiunge ogni previsione come una riga. Il\ncomplemento di gather_predictions() è spread_predictions() che aggiunge\nogni previsione una nuova colonna.Per generare previsioni da entrambi modelli simultaneamente, possiamo usare\ngather_predictions() che aggiunge ogni previsione come una riga. Il\ncomplemento di gather_predictions() è spread_predictions() che aggiunge\nogni previsione una nuova colonna.Insieme questo ci dà:Possiamo visualizzare risultati di entrambi modelli su un unico grafico usando il facetting:Nota che il modello che usa + ha la stessa pendenza per ogni linea, ma intercette diverse. Il modello che usa * ha una pendenza e un’intercetta diverse per ogni linea.Quale modello è migliore per questi dati? Possiamo dare un’occhiata ai residui. Qui ho sfaccettato sia il modello che x2 perché rende più facile vedere il modello ’interno di ogni gruppo.C’è un modello poco evidente nei residui per il mod2. residui per il mod1 mostrano che il modello ha chiaramente mancato qualche modello b, e meno, ma ancora presente è il modello c, e d. Ci si potrebbe chiedere se c’è un modo preciso per dire quale di mod1 o mod2 sia migliore. C’è, ma richiede un sacco di background matematico, e noi non interessa molto. Qui, ci interessa una valutazione qualitativa del fatto che il modello abbia catturato o meno il modello che ci interessa.","code":"\nggplot(sim3, aes(x1, y)) + \n  geom_point(aes(colour = x2))\nmod1 <- lm(y ~ x1 + x2, data = sim3)\nmod2 <- lm(y ~ x1 * x2, data = sim3)\ngrid <- sim3 %>% \n  data_grid(x1, x2) %>% \n  gather_predictions(mod1, mod2)\ngrid\n#> # A tibble: 80 × 4\n#>   model    x1 x2     pred\n#>   <chr> <int> <fct> <dbl>\n#> 1 mod1      1 a      1.67\n#> 2 mod1      1 b      4.56\n#> 3 mod1      1 c      6.48\n#> 4 mod1      1 d      4.03\n#> 5 mod1      2 a      1.48\n#> 6 mod1      2 b      4.37\n#> # … with 74 more rows\nggplot(sim3, aes(x1, y, colour = x2)) + \n  geom_point() + \n  geom_line(data = grid, aes(y = pred)) + \n  facet_wrap(~ model)\nsim3 <- sim3 %>% \n  gather_residuals(mod1, mod2)\n\nggplot(sim3, aes(x1, resid, colour = x2)) + \n  geom_point() + \n  facet_grid(model ~ x2)"},{"path":"modelli-base.html","id":"interazioni-due-continue","chapter":"23 Modelli base","heading":"23.4.3 Interazioni (due continue)","text":"Diamo un’occhiata al modello equivalente per due variabili continue. Inizialmente le cose procedono modo quasi identico ’esempio precedente:Notate il mio uso di seq_range() dentro data_grid(). Invece di usare ogni valore unico di x, userò una griglia regolarmente distanziata di cinque valori tra numeri minimo e massimo. Probabilmente non è super importante questo caso, ma è una tecnica utile generale. Ci sono altri due utili argomenti seq_range():pretty = TRUE genererà una sequenza “carina”, cioè qualcosa che sembra\npiacevole ’occhio umano. Questo è utile se volete produrre tabelle di\noutput:\n\nseq_range(c(0.0123, 0.923423), n = 5)\n#> [1] 0.0123000 0.2400808 0.4678615 0.6956423 0.9234230\nseq_range(c(0.0123, 0.923423), n = 5, pretty = TRUE)\n#> [1] 0.0 0.2 0.4 0.6 0.8 1.0pretty = TRUE genererà una sequenza “carina”, cioè qualcosa che sembra\npiacevole ’occhio umano. Questo è utile se volete produrre tabelle di\noutput:trim = 0.1 taglierà via il 10% dei valori della coda. Questo è utile se le\nvariabili hanno una distribuzione coda lunga e ci si vuole concentrare sulla generazione di\nvalori vicino al centro:\n\nx1 <- rcauchy(100)\nseq_range(x1, n = 5)\n#> [1] -115.86934  -83.52130  -51.17325  -18.82520   13.52284\nseq_range(x1, n = 5, trim = 0.10)\n#> [1] -13.841101  -8.709812  -3.578522   1.552767   6.684057\nseq_range(x1, n = 5, trim = 0.25)\n#> [1] -2.17345439 -1.05938856  0.05467728  1.16874312  2.28280896\nseq_range(x1, n = 5, trim = 0.50)\n#> [1] -0.7249565 -0.2677888  0.1893788  0.6465465  1.1037141trim = 0.1 taglierà via il 10% dei valori della coda. Questo è utile se le\nvariabili hanno una distribuzione coda lunga e ci si vuole concentrare sulla generazione di\nvalori vicino al centro:expand = 0.1 è un certo senso l’opposto di trim(), espande l’intervallo del 10%.\n\nx2 <- c(0, 1)\nseq_range(x2, n = 5)\n#> [1] 0.00 0.25 0.50 0.75 1.00\nseq_range(x2, n = 5, expand = 0.10)\n#> [1] -0.050  0.225  0.500  0.775  1.050\nseq_range(x2, n = 5, expand = 0.25)\n#> [1] -0.1250  0.1875  0.5000  0.8125  1.1250\nseq_range(x2, n = 5, expand = 0.50)\n#> [1] -0.250  0.125  0.500  0.875  1.250expand = 0.1 è un certo senso l’opposto di trim(), espande l’intervallo del 10%.Ora proviamo visualizzare questo modello. Abbiamo due predittori continui, quindi potete immaginare il modello come una superficie 3d. Potremmo visualizzarlo usando geom_tile():Questo non suggerisce che modelli siano molto diversi! Ma questa è parte un’illusione: nostri occhi e il nostro cervello non sono molto bravi confrontare accuratamente le sfumature di colore. Invece di guardare la superficie dall’alto, potremmo guardarla da entrambi lati, mostrando più facce:Questo vi mostra che l’interazione tra due variabili continue funziona fondamentalmente allo stesso modo di una variabile categorica e continua. Un’interazione dice che non c’è un offset fisso: devi considerare entrambi valori di x1 e x2 simultaneamente per prevedere y.Puoi vedere che anche con solo due variabili continue, è difficile ottenere una buona visualizzazione. Ma questo è ragionevole: non ci si dovrebbe aspettare che sia facile capire come tre o più variabili interagiscono simultaneamente! Ma di nuovo, ci salviamo un po’ perché stiamo usando modelli per l’esplorazione, e potete costruire gradualmente il vostro modello nel tempo. Il modello non deve essere perfetto, deve solo aiutarvi rivelare un po’ di più sui vostri dati.Ho passato un po’ di tempo guardare residui per vedere se potevo capire se il mod2 ha fatto meglio del mod1. Penso che lo faccia, ma è piuttosto sottile. Avrai la possibilità di lavorarci negli esercizi.","code":"\nmod1 <- lm(y ~ x1 + x2, data = sim4)\nmod2 <- lm(y ~ x1 * x2, data = sim4)\n\ngrid <- sim4 %>% \n  data_grid(\n    x1 = seq_range(x1, 5), \n    x2 = seq_range(x2, 5) \n  ) %>% \n  gather_predictions(mod1, mod2)\ngrid\n#> # A tibble: 50 × 4\n#>   model    x1    x2   pred\n#>   <chr> <dbl> <dbl>  <dbl>\n#> 1 mod1   -1    -1    0.996\n#> 2 mod1   -1    -0.5 -0.395\n#> 3 mod1   -1     0   -1.79 \n#> 4 mod1   -1     0.5 -3.18 \n#> 5 mod1   -1     1   -4.57 \n#> 6 mod1   -0.5  -1    1.91 \n#> # … with 44 more rows\nseq_range(c(0.0123, 0.923423), n = 5)\n#> [1] 0.0123000 0.2400808 0.4678615 0.6956423 0.9234230\nseq_range(c(0.0123, 0.923423), n = 5, pretty = TRUE)\n#> [1] 0.0 0.2 0.4 0.6 0.8 1.0\nx1 <- rcauchy(100)\nseq_range(x1, n = 5)\n#> [1] -115.86934  -83.52130  -51.17325  -18.82520   13.52284\nseq_range(x1, n = 5, trim = 0.10)\n#> [1] -13.841101  -8.709812  -3.578522   1.552767   6.684057\nseq_range(x1, n = 5, trim = 0.25)\n#> [1] -2.17345439 -1.05938856  0.05467728  1.16874312  2.28280896\nseq_range(x1, n = 5, trim = 0.50)\n#> [1] -0.7249565 -0.2677888  0.1893788  0.6465465  1.1037141\nx2 <- c(0, 1)\nseq_range(x2, n = 5)\n#> [1] 0.00 0.25 0.50 0.75 1.00\nseq_range(x2, n = 5, expand = 0.10)\n#> [1] -0.050  0.225  0.500  0.775  1.050\nseq_range(x2, n = 5, expand = 0.25)\n#> [1] -0.1250  0.1875  0.5000  0.8125  1.1250\nseq_range(x2, n = 5, expand = 0.50)\n#> [1] -0.250  0.125  0.500  0.875  1.250\nggplot(grid, aes(x1, x2)) + \n  geom_tile(aes(fill = pred)) + \n  facet_wrap(~ model)\nggplot(grid, aes(x1, pred, colour = x2, group = x2)) + \n  geom_line() +\n  facet_wrap(~ model)\nggplot(grid, aes(x2, pred, colour = x1, group = x1)) + \n  geom_line() +\n  facet_wrap(~ model)"},{"path":"modelli-base.html","id":"trasformazioni","chapter":"23 Modelli base","heading":"23.4.4 Trasformazioni","text":"Puoi anche eseguire trasformazioni ’interno della formula del modello. Per esempio, log(y) ~ sqrt(x1) + x2 si trasforma log(y) = a_1 + a_2 * sqrt(x1) + a_3 * x2. Se la vostra trasformazione coinvolge +, *, ^, o -, dovrete avvolgerla () modo che R non la tratti come parte della specifica del modello. Per esempio, y ~ x + (x ^ 2) viene tradotto y = a_1 + a_2 * x + a_3 * x^2. Se dimenticate il () e specificate y ~ x ^ 2 + x, R calcolerà y ~ x * x + x. x * x significa l’interazione di x con se stesso, che è la stessa di x. R elimina automaticamente le variabili ridondanti così x + x diventa x, il che significa che y ~ x ^ 2 + x specifica la funzione y = a_1 + a_2 * x. Probabilmente non è quello che intendevi!Di nuovo, se sei confuso su ciò che il tuo modello sta facendo, puoi sempre usare model_matrix() per vedere esattamente quale equazione lm() si adatta:Le trasformazioni sono utili perché puoi usarle per approssimare funzioni non lineari. Se hai seguito un corso di calcolo, potresti aver sentito parlare del teorema di Taylor che dice che puoi approssimare qualsiasi funzione liscia con una somma infinita di polinomi. Ciò significa che puoi usare una funzione polinomiale per avvicinarti arbitrariamente una funzione liscia adattando un’equazione come y = a_1 + a_2 * x + a_3 * x^2 + a_4 * x ^ 3. Scrivere questa sequenza mano è noioso, così R fornisce una funzione di aiuto: poly():Tuttavia c’è un grosso problema nell’uso di poly(): al di fuori dell’intervallo dei dati, polinomi sparano rapidamente ’infinito positivo o negativo. Un’alternativa più sicura è usare la spline naturale, splines::ns().Vediamo come appare quando cerchiamo di approssimare una funzione non lineare:Ho intenzione di adattare cinque modelli questi dati.Notate che l’estrapolazione al di fuori dell’intervallo dei dati è chiaramente cattiva. Questo è il lato negativo di approssimare una funzione con un polinomio. Ma questo è un problema molto reale con ogni modello: il modello non può mai dirvi se il comportamento è vero quando iniziate ad estrapolare al di fuori dell’intervallo dei dati che avete visto. Dovete affidarvi alla teoria e alla scienza.","code":"\ndf <- tribble(\n  ~y, ~x,\n   1,  1,\n   2,  2, \n   3,  3\n)\nmodel_matrix(df, y ~ x^2 + x)\n#> # A tibble: 3 × 2\n#>   `(Intercept)`     x\n#>           <dbl> <dbl>\n#> 1             1     1\n#> 2             1     2\n#> 3             1     3\nmodel_matrix(df, y ~ I(x^2) + x)\n#> # A tibble: 3 × 3\n#>   `(Intercept)` `I(x^2)`     x\n#>           <dbl>    <dbl> <dbl>\n#> 1             1        1     1\n#> 2             1        4     2\n#> 3             1        9     3\nmodel_matrix(df, y ~ poly(x, 2))\n#> # A tibble: 3 × 3\n#>   `(Intercept)` `poly(x, 2)1` `poly(x, 2)2`\n#>           <dbl>         <dbl>         <dbl>\n#> 1             1     -7.07e- 1         0.408\n#> 2             1     -9.07e-17        -0.816\n#> 3             1      7.07e- 1         0.408\nlibrary(splines)\nmodel_matrix(df, y ~ ns(x, 2))\n#> # A tibble: 3 × 3\n#>   `(Intercept)` `ns(x, 2)1` `ns(x, 2)2`\n#>           <dbl>       <dbl>       <dbl>\n#> 1             1       0           0    \n#> 2             1       0.566      -0.211\n#> 3             1       0.344       0.771\nsim5 <- tibble(\n  x = seq(0, 3.5 * pi, length = 50),\n  y = 4 * sin(x) + rnorm(length(x))\n)\n\nggplot(sim5, aes(x, y)) +\n  geom_point()\nmod1 <- lm(y ~ ns(x, 1), data = sim5)\nmod2 <- lm(y ~ ns(x, 2), data = sim5)\nmod3 <- lm(y ~ ns(x, 3), data = sim5)\nmod4 <- lm(y ~ ns(x, 4), data = sim5)\nmod5 <- lm(y ~ ns(x, 5), data = sim5)\n\ngrid <- sim5 %>% \n  data_grid(x = seq_range(x, n = 50, expand = 0.1)) %>% \n  gather_predictions(mod1, mod2, mod3, mod4, mod5, .pred = \"y\")\n\nggplot(sim5, aes(x, y)) + \n  geom_point() +\n  geom_line(data = grid, colour = \"red\") +\n  facet_wrap(~ model)"},{"path":"modelli-base.html","id":"esercizi-65","chapter":"23 Modelli base","heading":"23.4.5 Esercizi","text":"Cosa succede se ripetete l’analisi di sim2 usando un modello senza\nun’intercetta. Cosa succede ’equazione del modello? Cosa succede alle\nprevisioni?Cosa succede se ripetete l’analisi di sim2 usando un modello senza\nun’intercetta. Cosa succede ’equazione del modello? Cosa succede alle\nprevisioni?Usate model_matrix() per esplorare le equazioni generate per modelli\nche ho adattato sim3 e sim4. Perché * è una buona abbreviazione di interazione?Usate model_matrix() per esplorare le equazioni generate per modelli\nche ho adattato sim3 e sim4. Perché * è una buona abbreviazione di interazione?Usando principi di base, convertite le formule dei seguenti due\nmodelli funzioni. (Suggerimento: iniziate convertire la variabile categorica\nvariabili 0-1).\n\nmod1 <- lm(y ~ x1 + x2, data = sim3)\nmod2 <- lm(y ~ x1 * x2, data = sim3)Usando principi di base, convertite le formule dei seguenti due\nmodelli funzioni. (Suggerimento: iniziate convertire la variabile categorica\nvariabili 0-1).Per sim4, quale tra mod1 e mod2 è meglio? Penso che mod2 faccia un\nun lavoro leggermente migliore nella rimozione dei pattern, ma è piuttosto sottile. Puoi\nun grafico sostegno della mia affermazione?Per sim4, quale tra mod1 e mod2 è meglio? Penso che mod2 faccia un\nun lavoro leggermente migliore nella rimozione dei pattern, ma è piuttosto sottile. Puoi\nun grafico sostegno della mia affermazione?","code":"\nmod1 <- lm(y ~ x1 + x2, data = sim3)\nmod2 <- lm(y ~ x1 * x2, data = sim3)"},{"path":"modelli-base.html","id":"valori-mancanti-5","chapter":"23 Modelli base","heading":"23.5 Valori mancanti","text":"valori mancanti ovviamente non possono trasmettere alcuna informazione sulla relazione tra le variabili, quindi le funzioni di modellazione eliminano tutte le righe che contengono valori mancanti. Il comportamento predefinito di R è di eliminarli silenziosamente, ma options(na.action = na.warn) (eseguito nei prerequisiti), fa modo che tu riceva un avviso.Per sopprimere l’avvertimento, impostare na.action = na.exclude:Puoi sempre vedere esattamente quante osservazioni sono state usate con nobs():","code":"\ndf <- tribble(\n  ~x, ~y,\n  1, 2.2,\n  2, NA,\n  3, 3.5,\n  4, 8.3,\n  NA, 10\n)\n\nmod <- lm(y ~ x, data = df)\n#> Warning: Dropping 2 rows with missing values\nmod <- lm(y ~ x, data = df, na.action = na.exclude)\nnobs(mod)\n#> [1] 3"},{"path":"modelli-base.html","id":"altre-famiglie-di-modelli","chapter":"23 Modelli base","heading":"23.6 Altre famiglie di modelli","text":"Questo capitolo si è concentrato esclusivamente sulla classe dei modelli lineari, che assumono una relazione della forma y = a_1 * x1 + a_2 * x2 + ... + a_n * xn. modelli lineari assumono inoltre che residui abbiano una distribuzione normale, di cui non abbiamo parlato. Esiste un vasto insieme di classi di modelli che estendono il modello lineare vari modi interessanti. Alcuni di essi sono:Modelli lineari generalizzati, ad esempio stats::glm(). modelli lineari assumono che\nla risposta sia continua e l’errore abbia una distribuzione normale.\nmodelli lineari generalizzati estendono modelli lineari per includere risposte non continue\nrisposte non continue (per esempio dati binari o conteggi). Funzionano definendo una distanza\nbasata sull’idea statistica di verosimiglianza.Modelli lineari generalizzati, ad esempio stats::glm(). modelli lineari assumono che\nla risposta sia continua e l’errore abbia una distribuzione normale.\nmodelli lineari generalizzati estendono modelli lineari per includere risposte non continue\nrisposte non continue (per esempio dati binari o conteggi). Funzionano definendo una distanza\nbasata sull’idea statistica di verosimiglianza.Modelli additivi generalizzati, ad esempio mgcv::gam(), estendono modelli lineari generalizzati\nmodelli lineari generalizzati per incorporare funzioni lisce arbitrarie. Ciò significa che è possibile\nscrivere una formula come y ~ s(x) che diventa un’equazione come\ny = f(x)e lasciare chegam()` stimi quale sia questa funzione (soggetta ad alcuni\nvincoli di scorrevolezza per rendere il problema trattabile).Modelli additivi generalizzati, ad esempio mgcv::gam(), estendono modelli lineari generalizzati\nmodelli lineari generalizzati per incorporare funzioni lisce arbitrarie. Ciò significa che è possibile\nscrivere una formula come y ~ s(x) che diventa un’equazione come\ny = f(x)e lasciare chegam()` stimi quale sia questa funzione (soggetta ad alcuni\nvincoli di scorrevolezza per rendere il problema trattabile).Modelli lineari penalizzati, per esempio glmnet::glmnet(), aggiungono un termine di penalità alla\nla distanza che penalizza modelli complessi (definiti dalla distanza\ntra il vettore dei parametri e l’origine). Questo tende rendere\nmodelli che generalizzano meglio nuovi insiemi di dati della stessa popolazione.Modelli lineari penalizzati, per esempio glmnet::glmnet(), aggiungono un termine di penalità alla\nla distanza che penalizza modelli complessi (definiti dalla distanza\ntra il vettore dei parametri e l’origine). Questo tende rendere\nmodelli che generalizzano meglio nuovi insiemi di dati della stessa popolazione.Modelli lineari robusti, ad esempio MASS::rlm(), modificano la distanza per ponderare\npunti che sono molto lontani. Questo li rende meno sensibili alla presenza\ndi outlier, al costo di non essere altrettanto buoni quando non ci sono\nvalori anomali.Modelli lineari robusti, ad esempio MASS::rlm(), modificano la distanza per ponderare\npunti che sono molto lontani. Questo li rende meno sensibili alla presenza\ndi outlier, al costo di non essere altrettanto buoni quando non ci sono\nvalori anomali.Alberi decisionali, per esempio rpart::rpart(), attaccano il problema un modo completamente diverso\nmodo completamente diverso dai modelli lineari. Si adattano ad un modello costante frammentario, dividendo \ndati pezzi progressivamente sempre più piccoli. Gli alberi non sono terribilmente\nefficaci da soli, ma sono molto potenti se usati aggregato\nda modelli come random forests (ad esempio randomForest::randomForest()) o\ngradient boosting machines (ad esempio xgboost::xgboost).Alberi decisionali, per esempio rpart::rpart(), attaccano il problema un modo completamente diverso\nmodo completamente diverso dai modelli lineari. Si adattano ad un modello costante frammentario, dividendo \ndati pezzi progressivamente sempre più piccoli. Gli alberi non sono terribilmente\nefficaci da soli, ma sono molto potenti se usati aggregato\nda modelli come random forests (ad esempio randomForest::randomForest()) o\ngradient boosting machines (ad esempio xgboost::xgboost).Questi modelli funzionano tutti modo simile dal punto di vista della programmazione. Una volta che avete padroneggiato modelli lineari, dovreste trovare facile padroneggiare la meccanica di queste altre classi di modelli. Essere un abile modellatore è un misto di alcuni buoni principi generali e di avere una grande cassetta degli attrezzi di tecniche. Ora che avete imparato alcuni strumenti generali e una classe utile di modelli, potete andare avanti e imparare altre classi da altre fonti.","code":""},{"path":"costruire-modelli.html","id":"costruire-modelli","chapter":"24 Costruire modelli","heading":"24 Costruire modelli","text":"","code":""},{"path":"costruire-modelli.html","id":"introduzione-16","chapter":"24 Costruire modelli","heading":"24.1 Introduzione","text":"Nel capitolo precedente avete imparato come funzionano modelli lineari e avete appreso alcuni strumenti di base per capire cosa vi dice un modello sui vostri dati. Il capitolo precedente si è concentrato su serie di dati simulati. Questo capitolo si concentrerà su dati reali, mostrandovi come potete costruire progressivamente un modello per aiutare la vostra comprensione dei dati.Sfrutteremo il fatto che potete pensare ad un modello che partiziona vostri dati pattern e residui. Troveremo modelli con la visualizzazione, poi li renderemo concreti e precisi con un modello. Poi ripeteremo il processo, ma sostituendo la vecchia variabile di risposta con residui del modello. L’obiettivo è quello di passare dalla conoscenza implicita nei dati e nella tua testa alla conoscenza esplicita un modello quantitativo. Questo la rende più facile da applicare nuovi domini, e più facile da usare per gli altri.Per serie di dati molto grandi e complesse questo sarà un sacco di lavoro. Ci sono certamente approcci alternativi - un approccio più da machine learning è semplicemente concentrarsi sulla capacità predittiva del modello. Questi approcci tendono produrre scatole nere: il modello fa un ottimo lavoro nel generare previsioni, ma non si sa perché. Questo è un approccio del tutto ragionevole, ma rende difficile applicare la vostra conoscenza del mondo reale al modello. Questo, sua volta, rende difficile valutare se il modello continuerà funzionare lungo termine, quando fondamentali cambieranno. Per la maggior parte dei modelli reali, mi aspetto che usiate una combinazione di questo approccio e un approccio automatico più classico.È una sfida sapere quando fermarsi. Devi capire quando il tuo modello è abbastanza buono e quando è improbabile che un ulteriore investimento paghi. Mi piace particolarmente questa citazione dall’utente di reddit Broseidon241:Molto tempo fa, al corso d’arte, il mio insegnante mi disse: “Un artista deve sapere\nquando un pezzo è finito. Non puoi ritoccare qualcosa fino alla perfezione - incartapecorisce.\nSe non ti piace, rifallo. Altrimenti inizia qualcosa di nuovo”. Più tardi\nnella vita, ho sentito: “Una povera sarta fa molti errori. Una buona sarta\nlavora duramente per correggere quegli errori. Una grande sarta non ha paura di\nbuttare l’indumento e ricominciare da capo”.– Broseidon241, https://www.reddit.com/r/datascience/comments/4irajq","code":""},{"path":"costruire-modelli.html","id":"prerequisiti-16","chapter":"24 Costruire modelli","heading":"24.1.1 Prerequisiti","text":"Useremo gli stessi strumenti del capitolo precedente, ma aggiungeremo alcuni set di dati reali: diamonds da ggplot2, e flights da nycflights13. Avremo anche bisogno di lubridate per lavorare con la data/ora flights.","code":"\nlibrary(tidyverse)\nlibrary(modelr)\noptions(na.action = na.warn)\n\nlibrary(nycflights13)\nlibrary(lubridate)"},{"path":"costruire-modelli.html","id":"diamond-prices","chapter":"24 Costruire modelli","heading":"24.2 Perché i diamanti di bassa qualità sono più cari?","text":"Nei capitoli precedenti abbiamo visto una relazione sorprendente tra la qualità dei diamanti e il loro prezzo: diamanti di bassa qualità (tagli poveri, colori scadenti e purezza inferiore) hanno prezzi più alti.Si noti che il peggior colore del diamante è J (leggermente giallo), e la peggiore purezza è I1 (inclusioni visibili occhio nudo).","code":"\nggplot(diamonds, aes(cut, price)) + geom_boxplot()\nggplot(diamonds, aes(color, price)) + geom_boxplot()\nggplot(diamonds, aes(clarity, price)) + geom_boxplot()"},{"path":"costruire-modelli.html","id":"prezzo-e-caratura","chapter":"24 Costruire modelli","heading":"24.2.1 Prezzo e caratura","text":"Sembra che diamanti di qualità inferiore abbiano prezzi più alti perché c’è un’importante variabile di confusione: il peso (carat) del diamante. Il peso del diamante è il singolo fattore più importante per determinare il prezzo del diamante, e diamanti di qualità inferiore tendono ad essere più grandi.Possiamo rendere più facile vedere come gli altri attributi di un diamante influenzano il suo price (prezzo) relativo adattando un modello per separare l’effetto della carat(caratura). Ma prima, facciamo un paio di modifiche al dataset dei diamanti per renderlo più facile da lavorare:Concentrarsi sui diamanti più piccoli di 2,5 carati (99,7% dei dati) 1. 2. Log-transformare le variabili carati e prezzo.Insieme, questi cambiamenti rendono più facile vedere la relazione tra carat e price:La trasformazione logaritmica è particolarmente utile qui perché rende il modello lineare, e modelli lineari sono più facili da lavorare. Facciamo il passo successivo e rimuoviamo questo forte modello lineare. Per prima cosa rendiamo il modello esplicito adattando un modello:Poi guardiamo cosa ci dice il modello sui dati. Notate che ho ritrasformato le previsioni, annullando la trasformazione logaritmica, modo da poter sovrapporre le previsioni ai dati grezzi:Questo ci dice qualcosa di interessante sui nostri dati. Se crediamo al nostro modello, allora grandi diamanti sono molto più economici del previsto. Questo probabilmente perché nessun diamante questo set di dati costa più di 19.000 dollari.Ora possiamo guardare residui, il che verifica che abbiamo rimosso con successo il forte modello lineare:È importante che ora possiamo rifare nostri grafici motivanti usando questi residui invece di price.Ora vediamo la relazione che ci aspettiamo: man mano che la qualità del diamante aumenta, aumenta anche il suo prezzo relativo. Per interpretare l’asse y, dobbiamo pensare cosa ci dicono residui e su quale scala si trovano. Un residuo di -1 indica che lprice è stato 1 unità più basso di una previsione basata solo sul suo peso. \\(2^{-1}\\) è 1/2, punti con un valore di -1 sono la metà del prezzo previsto, e residui con valore 1 sono il doppio del prezzo previsto.","code":"\nggplot(diamonds, aes(carat, price)) + \n  geom_hex(bins = 50)\ndiamonds2 <- diamonds %>% \n  filter(carat <= 2.5) %>% \n  mutate(lprice = log2(price), lcarat = log2(carat))\nggplot(diamonds2, aes(lcarat, lprice)) + \n  geom_hex(bins = 50)\nmod_diamond <- lm(lprice ~ lcarat, data = diamonds2)\ngrid <- diamonds2 %>% \n  data_grid(carat = seq_range(carat, 20)) %>% \n  mutate(lcarat = log2(carat)) %>% \n  add_predictions(mod_diamond, \"lprice\") %>% \n  mutate(price = 2 ^ lprice)\n\nggplot(diamonds2, aes(carat, price)) + \n  geom_hex(bins = 50) + \n  geom_line(data = grid, colour = \"red\", size = 1)\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead.\ndiamonds2 <- diamonds2 %>% \n  add_residuals(mod_diamond, \"lresid\")\n\nggplot(diamonds2, aes(lcarat, lresid)) + \n  geom_hex(bins = 50)\nggplot(diamonds2, aes(cut, lresid)) + geom_boxplot()\nggplot(diamonds2, aes(color, lresid)) + geom_boxplot()\nggplot(diamonds2, aes(clarity, lresid)) + geom_boxplot()"},{"path":"costruire-modelli.html","id":"un-modello-più-complicato","chapter":"24 Costruire modelli","heading":"24.2.2 Un modello più complicato","text":"Se volessimo, potremmo continuare costruire il nostro modello, spostando gli effetti che abbiamo osservato nel modello per renderli espliciti. Per esempio, potremmo includere “color”, “cut” e “clarity” nel modello modo da rendere esplicito anche l’effetto di queste tre variabili categoriche:Questo modello ora include quattro predittori, quindi sta diventando più difficile da visualizzare. Fortunatamente, attualmente sono tutti indipendenti, il che significa che possiamo tracciarli individualmente quattro grafici. Per rendere il processo un po’ più semplice, useremo l’argomento .model data_grid:Se il modello ha bisogno di variabili che non sono state esplicitamente fornite, data_grid() le riempirà automaticamente con il valore “tipico”. Per le variabili continue, usa la mediana, e per le variabili categoriche usa il valore più comune (o valori, se c’è un pareggio).Questo grafico indica che ci sono alcuni diamanti con residui abbastanza grandi - ricorda che un residuo di 2 indica che il diamante è 4 volte il prezzo che ci aspettavamo. Spesso è utile guardare valori insoliti singolarmente:Non c’è niente che mi salti ’occhio, ma probabilmente vale la pena spendere del tempo per considerare se questo indica un problema con il nostro modello, o se ci sono errori nei dati. Se ci sono errori nei dati, questa potrebbe essere un’opportunità per comprare diamanti che sono stati valutati male.","code":"\nmod_diamond2 <- lm(lprice ~ lcarat + color + cut + clarity, data = diamonds2)\ngrid <- diamonds2 %>% \n  data_grid(cut, .model = mod_diamond2) %>% \n  add_predictions(mod_diamond2)\ngrid\n#> # A tibble: 5 × 5\n#>   cut       lcarat color clarity  pred\n#>   <ord>      <dbl> <chr> <chr>   <dbl>\n#> 1 Fair      -0.515 G     VS2      11.2\n#> 2 Good      -0.515 G     VS2      11.3\n#> 3 Very Good -0.515 G     VS2      11.4\n#> 4 Premium   -0.515 G     VS2      11.4\n#> 5 Ideal     -0.515 G     VS2      11.4\n\nggplot(grid, aes(cut, pred)) + \n  geom_point()\ndiamonds2 <- diamonds2 %>% \n  add_residuals(mod_diamond2, \"lresid2\")\n\nggplot(diamonds2, aes(lcarat, lresid2)) + \n  geom_hex(bins = 50)\ndiamonds2 %>% \n  filter(abs(lresid2) > 1) %>% \n  add_predictions(mod_diamond2) %>% \n  mutate(pred = round(2 ^ pred)) %>% \n  select(price, pred, carat:table, x:z) %>% \n  arrange(price)\n#> # A tibble: 16 × 11\n#>   price  pred carat cut     color clarity depth table     x     y     z\n#>   <int> <dbl> <dbl> <ord>   <ord> <ord>   <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1  1013   264  0.25 Fair    F     SI2      54.4    64  4.3   4.23  2.32\n#> 2  1186   284  0.25 Premium G     SI2      59      60  5.33  5.28  3.12\n#> 3  1186   284  0.25 Premium G     SI2      58.8    60  5.33  5.28  3.12\n#> 4  1262  2644  1.03 Fair    E     I1       78.2    54  5.72  5.59  4.42\n#> 5  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66\n#> 6  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66\n#> # … with 10 more rows"},{"path":"costruire-modelli.html","id":"esercizi-66","chapter":"24 Costruire modelli","heading":"24.2.3 Esercizi","text":"Nel grafico di lcarat vs. lprice, ci sono alcune strisce verticali luminose. Cosa rappresentano?Nel grafico di lcarat vs. lprice, ci sono alcune strisce verticali luminose. Cosa rappresentano?Se log(price) = a_0 + a_1 * log(carat), cosa dice questo sulla relazione tra price e carat?Se log(price) = a_0 + a_1 * log(carat), cosa dice questo sulla relazione tra price e carat?Estrai diamanti che hanno residui molto alti e molto bassi.\nC’è qualcosa di insolito questi diamanti? Sono particolarmente cattivi o buoni, o pensate che si tratti di errori di prezzo?Estrai diamanti che hanno residui molto alti e molto bassi.\nC’è qualcosa di insolito questi diamanti? Sono particolarmente cattivi o buoni, o pensate che si tratti di errori di prezzo?Il modello finale, mod_diamond2, fa un buon lavoro di previsione dei prezzi dei diamanti? Vi fidereste di esso per dirvi quanto spendere se doveste comprare un diamante?Il modello finale, mod_diamond2, fa un buon lavoro di previsione dei prezzi dei diamanti? Vi fidereste di esso per dirvi quanto spendere se doveste comprare un diamante?","code":""},{"path":"costruire-modelli.html","id":"cosa-influenza-il-numero-di-voli-giornalieri","chapter":"24 Costruire modelli","heading":"24.3 Cosa influenza il numero di voli giornalieri?","text":"Lavoriamo attraverso un processo simile per un set di dati che sembra ancora più semplice prima vista: il numero di voli che lasciano NYC al giorno. Questo è un dataset davvero piccolo — solo 365 righe e 2 colonne — e non finiremo con un modello completamente realizzato, ma come vedrete, passi lungo il percorso ci aiuteranno capire meglio dati. Iniziamo contando il numero di voli al giorno e visualizzandolo con ggplot2.","code":"\ndaily <- flights %>% \n  mutate(date = make_date(year, month, day)) %>% \n  group_by(date) %>% \n  summarise(n = n())\ndaily\n#> # A tibble: 365 × 2\n#>   date           n\n#>   <date>     <int>\n#> 1 2013-01-01   842\n#> 2 2013-01-02   943\n#> 3 2013-01-03   914\n#> 4 2013-01-04   915\n#> 5 2013-01-05   720\n#> 6 2013-01-06   832\n#> # … with 359 more rows\n\nggplot(daily, aes(date, n)) + \n  geom_line()"},{"path":"costruire-modelli.html","id":"giorno-della-settimana","chapter":"24 Costruire modelli","heading":"24.3.1 Giorno della settimana","text":"Capire la tendenza lungo termine è difficile perché c’è un effetto giorno della settimana molto forte che domina modelli più sottili. Cominciamo guardare la distribuzione del numero di voli per giorno della settimana:Ci sono meno voli nei fine settimana perché la maggior parte dei viaggi è per affari. L’effetto è particolarmente pronunciato il sabato: si potrebbe volte partire la domenica per una riunione del lunedì mattina, ma è molto raro che si parta il sabato perché si preferisce stare casa con la propria famiglia.Un modo per rimuovere questo forte schema è usare un modello. Per prima cosa, adattiamo il modello e mostriamo le sue previsioni sovrapposte ai dati originali:Poi calcoliamo e visualizziamo residui:Il nostro modello sembra fallire partire da giugno: si può ancora vedere un forte modello regolare che il nostro modello non ha catturato. Disegnare un grafico con una linea per ogni giorno della settimana rende la causa più facile da vedere:\n\nggplot(daily, aes(date, resid, colour = wday)) + \n  geom_ref_line(h = 0) + \n  geom_line()\n\nIl nostro modello non riesce prevedere accuratamente il numero di voli del sabato: durante l’estate ci sono più voli di quanto ci aspettiamo, e durante l’autunno ce ne sono meno. Vedremo come possiamo fare meglio per catturare questo modello nella prossima sezione.Il nostro modello sembra fallire partire da giugno: si può ancora vedere un forte modello regolare che il nostro modello non ha catturato. Disegnare un grafico con una linea per ogni giorno della settimana rende la causa più facile da vedere:Il nostro modello non riesce prevedere accuratamente il numero di voli del sabato: durante l’estate ci sono più voli di quanto ci aspettiamo, e durante l’autunno ce ne sono meno. Vedremo come possiamo fare meglio per catturare questo modello nella prossima sezione.Ci sono alcuni giorni con molti meno voli del previsto:\n\ndaily %>% \n  filter(resid < -100)\n#> # tibble: 11 × 4\n#>   date           n wday  resid\n#>   <date>     <int> <ord> <dbl>\n#> 1 2013-01-01   842 Tue   -109.\n#> 2 2013-01-20   786 Sun   -105.\n#> 3 2013-05-26   729 Sun   -162.\n#> 4 2013-07-04   737 Thu   -229.\n#> 5 2013-07-05   822 Fri   -145.\n#> 6 2013-09-01   718 Sun   -173.\n#> # … 5 rows\nSe avete familiarità con le festività americane, potreste individuare il Capodanno\n4 luglio, il Ringraziamento e il Natale. Ce ne sono altri che non\nsembrano corrispondere ai giorni festivi. Lavorerai su quelle uno\ndegli esercizi.Ci sono alcuni giorni con molti meno voli del previsto:Se avete familiarità con le festività americane, potreste individuare il Capodanno\n4 luglio, il Ringraziamento e il Natale. Ce ne sono altri che non\nsembrano corrispondere ai giorni festivi. Lavorerai su quelle uno\ndegli esercizi.Sembra che ci sia una tendenza lungo termine più morbida nel corso di un anno.\nPossiamo evidenziare questa tendenza con geom_smooth():\n\ndaily %>% \n  ggplot(aes(date, resid)) + \n  geom_ref_line(h = 0) + \n  geom_line(colour = \"grey50\") + \n  geom_smooth(se = FALSE, span = 0.20)\n#> `geom_smooth()` using method = 'loess' formula = 'y ~ x'\n\nCi sono meno voli gennaio (e dicembre), e più estate\n(maggio-settembre). Non possiamo fare molto con questo modello quantitativamente, perché\nabbiamo solo un anno di dati. Ma possiamo usare la nostra conoscenza del dominio per\nper trovare delle potenziali spiegazioni.Sembra che ci sia una tendenza lungo termine più morbida nel corso di un anno.\nPossiamo evidenziare questa tendenza con geom_smooth():Ci sono meno voli gennaio (e dicembre), e più estate\n(maggio-settembre). Non possiamo fare molto con questo modello quantitativamente, perché\nabbiamo solo un anno di dati. Ma possiamo usare la nostra conoscenza del dominio per\nper trovare delle potenziali spiegazioni.","code":"\ndaily <- daily %>% \n  mutate(wday = wday(date, label = TRUE))\nggplot(daily, aes(wday, n)) + \n  geom_boxplot()\nmod <- lm(n ~ wday, data = daily)\n\ngrid <- daily %>% \n  data_grid(wday) %>% \n  add_predictions(mod, \"n\")\n\nggplot(daily, aes(wday, n)) + \n  geom_boxplot() +\n  geom_point(data = grid, colour = \"red\", size = 4)\ndaily <- daily %>% \n  add_residuals(mod)\ndaily %>% \n  ggplot(aes(date, resid)) + \n  geom_ref_line(h = 0) + \n  geom_line()Notate il cambiamento nell'asse y: ora stiamo vedendo la deviazione dal numero previsto di voli, dato il giorno della settimana. Questo grafico è utile perché ora che abbiamo rimosso gran parte del grande effetto del giorno della settimana, possiamo vedere alcuni dei modelli più sottili che rimangono:\nggplot(daily, aes(date, resid, colour = wday)) + \n  geom_ref_line(h = 0) + \n  geom_line()\ndaily %>% \n  filter(resid < -100)\n#> # A tibble: 11 × 4\n#>   date           n wday  resid\n#>   <date>     <int> <ord> <dbl>\n#> 1 2013-01-01   842 Tue   -109.\n#> 2 2013-01-20   786 Sun   -105.\n#> 3 2013-05-26   729 Sun   -162.\n#> 4 2013-07-04   737 Thu   -229.\n#> 5 2013-07-05   822 Fri   -145.\n#> 6 2013-09-01   718 Sun   -173.\n#> # … with 5 more rows\ndaily %>% \n  ggplot(aes(date, resid)) + \n  geom_ref_line(h = 0) + \n  geom_line(colour = \"grey50\") + \n  geom_smooth(se = FALSE, span = 0.20)\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"costruire-modelli.html","id":"effetto-stagionale-del-sabato","chapter":"24 Costruire modelli","heading":"24.3.2 Effetto stagionale del sabato","text":"Affrontiamo prima il nostro fallimento nel prevedere accuratamente il numero di voli di sabato. Un buon punto di partenza è tornare ai numeri grezzi, concentrandosi sul sabato:(Ho usato sia punti che linee per rendere più chiaro cosa sono dati e cosa l’interpolazione).Sospetto che questo modello sia causato dalle vacanze estive: molte persone vanno vacanza estate, e alla gente non dispiace viaggiare di sabato per le vacanze. Guardando questo grafico, potremmo indovinare che le vacanze estive vanno da inizio giugno fine agosto. Questo sembra allinearsi abbastanza bene con [termini scolastici dello stato] (http://schools.nyc.gov/Calendar/2013-2014+School+Year+Calendars.htm): la pausa estiva nel 2013 era 26 giugno - 9 settembre.Perché ci sono più voli di sabato primavera che autunno? Ho chiesto ad alcuni amici americani e mi hanno suggerito che è meno comune pianificare le vacanze famiglia durante l’autunno causa delle grandi vacanze del Ringraziamento e di Natale. Non abbiamo dati per saperlo con certezza, ma sembra un’ipotesi di lavoro plausibile.Creiamo una variabile “termine” che catturi approssimativamente tre termini scolastici, e controlliamo il nostro lavoro con un grafico:(Ho modificato manualmente le date per ottenere delle belle pause nel grafico. Usare una visualizzazione per aiutarvi capire cosa sta facendo la vostra funzione è una tecnica davvero potente e generale).È utile vedere come questa nuova variabile influenza gli altri giorni della settimana:Sembra che ci sia una variazione significativa tra termini, quindi è ragionevole inserire un effetto separato del giorno della settimana per ogni termine. Questo migliora il nostro modello, ma non così tanto come potremmo sperare:Possiamo vedere il problema sovrapponendo le previsioni del modello ai dati grezzi:Il nostro modello sta trovando l’effetto mean, ma abbiamo molti grandi outlier, quindi la media tende ad essere molto lontana dal valore tipico. Possiamo alleviare questo problema usando un modello che è robusto ’effetto degli outlier: MASS::rlm(). Questo riduce notevolmente l’impatto degli outlier sulle nostre stime e fornisce un modello che fa un buon lavoro per rimuovere il modello del giorno della settimana:Ora è molto più facile vedere la tendenza lungo termine e gli outlier positivi e negativi.","code":"\ndaily %>% \n  filter(wday == \"Sat\") %>% \n  ggplot(aes(date, n)) + \n    geom_point() + \n    geom_line() +\n    scale_x_date(NULL, date_breaks = \"1 month\", date_labels = \"%b\")\nterm <- function(date) {\n  cut(date, \n    breaks = ymd(20130101, 20130605, 20130825, 20140101),\n    labels = c(\"spring\", \"summer\", \"fall\") \n  )\n}\n\ndaily <- daily %>% \n  mutate(term = term(date)) \n\ndaily %>% \n  filter(wday == \"Sat\") %>% \n  ggplot(aes(date, n, colour = term)) +\n  geom_point(alpha = 1/3) + \n  geom_line() +\n  scale_x_date(NULL, date_breaks = \"1 month\", date_labels = \"%b\")\ndaily %>% \n  ggplot(aes(wday, n, colour = term)) +\n    geom_boxplot()\nmod1 <- lm(n ~ wday, data = daily)\nmod2 <- lm(n ~ wday * term, data = daily)\n\ndaily %>% \n  gather_residuals(without_term = mod1, with_term = mod2) %>% \n  ggplot(aes(date, resid, colour = model)) +\n    geom_line(alpha = 0.75)\ngrid <- daily %>% \n  data_grid(wday, term) %>% \n  add_predictions(mod2, \"n\")\n\nggplot(daily, aes(wday, n)) +\n  geom_boxplot() + \n  geom_point(data = grid, colour = \"red\") + \n  facet_wrap(~ term)\nmod3 <- MASS::rlm(n ~ wday * term, data = daily)\n\ndaily %>% \n  add_residuals(mod3, \"resid\") %>% \n  ggplot(aes(date, resid)) + \n  geom_hline(yintercept = 0, size = 2, colour = \"white\") + \n  geom_line()"},{"path":"costruire-modelli.html","id":"variabili-calcolate","chapter":"24 Costruire modelli","heading":"24.3.3 Variabili calcolate","text":"Se state sperimentando molti modelli e molte visualizzazioni, è una buona idea raggruppare la creazione delle variabili una funzione modo che non ci sia la possibilità di applicare accidentalmente una trasformazione diversa posti diversi. Per esempio, potremmo scrivereUn’altra opzione è quella di mettere le trasformazioni direttamente nella formula del modello:Entrambi gli approcci sono ragionevoli. Rendere esplicita la variabile trasformata è utile se vuoi controllare il tuo lavoro, o usarla una visualizzazione. Ma non si possono usare facilmente trasformazioni (come le spline) che restituiscono colonne multiple. Includere le trasformazioni nella funzione del modello rende la vita un po’ più facile quando si lavora con molti set di dati diversi, perché il modello è autonomo.","code":"\ncompute_vars <- function(data) {\n  data %>% \n    mutate(\n      term = term(date), \n      wday = wday(date, label = TRUE)\n    )\n}\nwday2 <- function(x) wday(x, label = TRUE)\nmod3 <- lm(n ~ wday2(date) * term(date), data = daily)"},{"path":"costruire-modelli.html","id":"tempo-dellanno-un-approccio-alternativo","chapter":"24 Costruire modelli","heading":"24.3.4 Tempo dell’anno: un approccio alternativo","text":"Nella sezione precedente abbiamo usato la nostra conoscenza del dominio (come il periodo scolastico negli Stati Uniti influenza viaggi) per migliorare il modello. Un’alternativa ’uso esplicito della nostra conoscenza nel modello è quella di dare ai dati più spazio per parlare. Potremmo usare un modello più flessibile e permettergli di catturare il modello che ci interessa. Una semplice tendenza lineare non è adeguata, quindi potremmo provare usare una spline naturale per adattare una curva liscia attraverso l’anno:Vediamo un forte schema nel numero di voli del sabato. Questo è rassicurante, perché abbiamo visto questo schema anche nei dati grezzi. È un buon segno quando si ottiene lo stesso segnale da approcci diversi.","code":"\nlibrary(splines)\nmod <- MASS::rlm(n ~ wday * ns(date, 5), data = daily)\n\ndaily %>% \n  data_grid(wday, date = seq_range(date, n = 13)) %>% \n  add_predictions(mod) %>% \n  ggplot(aes(date, pred, colour = wday)) + \n    geom_line() +\n    geom_point()"},{"path":"costruire-modelli.html","id":"esercizi-67","chapter":"24 Costruire modelli","heading":"24.3.5 Esercizi","text":"Usate le vostre abilità di investigazione su Google per capire perché ci sono stati meno voli del previsto il 20 gennaio, il 26 maggio e il 1° settembre. (Suggerimento: hanno tutti la stessa spiegazione.) Come si possono generalizzare questi giorni ad un altro anno?Usate le vostre abilità di investigazione su Google per capire perché ci sono stati meno voli del previsto il 20 gennaio, il 26 maggio e il 1° settembre. (Suggerimento: hanno tutti la stessa spiegazione.) Come si possono generalizzare questi giorni ad un altro anno?Cosa rappresentano tre giorni con alti residui positivi? Come si possono generalizzare questi giorni ad un altro anno?\n\ndaily %>% \n  slice_max(n = 3, resid)\n#> # tibble: 3 × 5\n#>   date           n wday  resid term \n#>   <date>     <int> <ord> <dbl> <fct>\n#> 1 2013-11-30   857 Sat   112.  fall \n#> 2 2013-12-01   987 Sun    95.5 fall \n#> 3 2013-12-28   814 Sat    69.4 fallCosa rappresentano tre giorni con alti residui positivi? Come si possono generalizzare questi giorni ad un altro anno?Creare una nuova variabile che divide la variabile wday termini, ma solo\nper sabati, cioè dovrebbe avere Thurs, Fri, ma Sat-summer,\nSat-spring, Sat-fall. Come si confronta questo modello con il modello con\nogni combinazione di wday e term?Creare una nuova variabile che divide la variabile wday termini, ma solo\nper sabati, cioè dovrebbe avere Thurs, Fri, ma Sat-summer,\nSat-spring, Sat-fall. Come si confronta questo modello con il modello con\nogni combinazione di wday e term?Crea una nuova variabile wday che combina il giorno della settimana, il termine\n(per il sabato) e giorni festivi. Come appaiono residui di\nquesto modello?Crea una nuova variabile wday che combina il giorno della settimana, il termine\n(per il sabato) e giorni festivi. Come appaiono residui di\nquesto modello?Cosa succede se inserite un effetto del giorno della settimana che varia base al mese\n(cioè n ~ wday * month)? Perché questo non è molto utile?Cosa succede se inserite un effetto del giorno della settimana che varia base al mese\n(cioè n ~ wday * month)? Perché questo non è molto utile?Come vi aspettate che sia il modello n ~ wday + ns(date, 5)?\nSapendo quello che sai sui dati, perché ti aspetteresti che non sia\nnon particolarmente efficace?Come vi aspettate che sia il modello n ~ wday + ns(date, 5)?\nSapendo quello che sai sui dati, perché ti aspetteresti che non sia\nnon particolarmente efficace?Abbiamo ipotizzato che le persone che partono di domenica hanno più probabilità di essere\nviaggiatori d’affari che devono essere da qualche parte il lunedì. Esplora questa\nipotesi vedendo come si scompone base alla distanza e al tempo: se\nè vero, ci si aspetterebbe di vedere più voli di domenica sera verso luoghi che\nsono lontani.Abbiamo ipotizzato che le persone che partono di domenica hanno più probabilità di essere\nviaggiatori d’affari che devono essere da qualche parte il lunedì. Esplora questa\nipotesi vedendo come si scompone base alla distanza e al tempo: se\nè vero, ci si aspetterebbe di vedere più voli di domenica sera verso luoghi che\nsono lontani.È un po’ frustrante che la domenica e il sabato siano su estremità separate\ndel grafico. Scrivete una piccola funzione per impostare livelli del\nfattore modo che la settimana inizi il lunedì.È un po’ frustrante che la domenica e il sabato siano su estremità separate\ndel grafico. Scrivete una piccola funzione per impostare livelli del\nfattore modo che la settimana inizi il lunedì.","code":"\ndaily %>% \n  slice_max(n = 3, resid)\n#> # A tibble: 3 × 5\n#>   date           n wday  resid term \n#>   <date>     <int> <ord> <dbl> <fct>\n#> 1 2013-11-30   857 Sat   112.  fall \n#> 2 2013-12-01   987 Sun    95.5 fall \n#> 3 2013-12-28   814 Sat    69.4 fall"},{"path":"costruire-modelli.html","id":"imparare-di-più-sui-modelli","chapter":"24 Costruire modelli","heading":"24.4 Imparare di più sui modelli","text":"Abbiamo solo scalfito la superficie assoluta della modellazione, ma speriamo che abbiate acquisito alcuni strumenti semplici, ma di uso generale, che potete usare per migliorare le vostre analisi dei dati. Va bene iniziare modo semplice! Come avete visto, anche modelli molto semplici possono fare una grande differenza nella vostra capacità di individuare le interazioni tra le variabili.Questi capitoli sulla modellazione sono ancora più ricchi di opinioni rispetto al resto del libro. Mi avvicino alla modellazione da una prospettiva un po’ diversa dalla maggior parte degli altri, e c’è relativamente poco spazio dedicato ad essa. La modellazione merita davvero un libro sé, quindi vi consiglio vivamente di leggere almeno uno di questi tre libri:Statistical Modeling: Fresh Approach di Danny Kaplan,\nhttp://project-mosaic-books.com/?page_id=13. Questo libro fornisce\nun’introduzione gentile alla modellazione, dove si costruisce la propria intuizione,\nstrumenti matematici e competenze R parallelo. Il libro sostituisce un tradizionale\ncorso di “introduzione alla statistica”, fornendo un curriculum che è aggiornato\ne rilevante per la scienza dei dati.Introduction Statistical Learning di Gareth James, Daniela Witten,\nTrevor Hastie, e Robert Tibshirani, http://www-bcf.usc.edu/~gareth/ISL/\n(disponibile online gratuitamente). Questo libro presenta una famiglia di moderne tecniche di modellazione\ntecniche di modellazione note collettivamente come apprendimento statistico. Per una comprensione ancora più profonda\ncomprensione della matematica dietro modelli, leggete il classico\nElements Statistical Learning di Trevor Hastie, Robert Tibshirani, e\nJerome Friedman, https://web.stanford.edu/~hastie/Papers/ESLII.pdf (disponibile anche\ndisponibile online gratuitamente).Applied Predictive Modeling di Max Kuhn e Kjell Johnson,\nhttp://appliedpredictivemodeling.com. Questo libro è un compagno del pacchetto\ncaret e fornisce strumenti pratici per affrontare la vita reale\nreali di modellazione predittiva.","code":""},{"path":"molti-modelli.html","id":"molti-modelli","chapter":"25 Molti modelli","heading":"25 Molti modelli","text":"","code":""},{"path":"molti-modelli.html","id":"introduzione-17","chapter":"25 Molti modelli","heading":"25.1 Introduzione","text":"questo capitolo imparerete tre potenti idee che vi aiuteranno lavorare con un gran numero di modelli con facilità:Usare molti modelli semplici per capire meglio insiemi di dati complessi.Usare molti modelli semplici per capire meglio insiemi di dati complessi.Usare liste-colonne per memorizzare strutture di dati arbitrarie un frame di dati.\nPer esempio, questo vi permetterà di avere una colonna che contiene modelli\nmodelli lineari.Usare liste-colonne per memorizzare strutture di dati arbitrarie un frame di dati.\nPer esempio, questo vi permetterà di avere una colonna che contiene modelli\nmodelli lineari.Usare il pacchetto broom, di David Robinson, per trasformare modelli dati\ndati ordinati. Questa è una tecnica potente per lavorare con un gran numero di modelli\nperché una volta che avete dati ordinati, potete applicare tutte le tecniche che\navete imparato precedenza nel libro.Usare il pacchetto broom, di David Robinson, per trasformare modelli dati\ndati ordinati. Questa è una tecnica potente per lavorare con un gran numero di modelli\nperché una volta che avete dati ordinati, potete applicare tutte le tecniche che\navete imparato precedenza nel libro.Inizieremo con un esempio motivante utilizzando dati sull’aspettativa di vita nel mondo. Si tratta di un piccolo set di dati, ma illustra quanto sia importante la modellazione per migliorare le vostre visualizzazioni. Useremo un gran numero di modelli semplici per separare alcuni dei segnali più forti modo da poter vedere segnali più sottili che rimangono. Vedremo anche come le sintesi dei modelli possono aiutarci individuare valori anomali e le tendenze insolite.Le sezioni seguenti si immergeranno maggiori dettagli sulle singole tecniche:list-columns, imparerai di più sulla struttura dati list-columns (‘colonne-elenco’),\ne perché ha senso mettere le liste nei frame di dati.list-columns, imparerai di più sulla struttura dati list-columns (‘colonne-elenco’),\ne perché ha senso mettere le liste nei frame di dati.[creare list-columns], imparerai tre modi principali cui\ncreare liste-colonne.[creare list-columns], imparerai tre modi principali cui\ncreare liste-colonne.semplificare le list-columns imparerai come convertire le list-columns\nvettori atomici regolari (o insiemi di vettori atomici) modo da poter lavorare\ncon loro più facilmente.semplificare le list-columns imparerai come convertire le list-columns\nvettori atomici regolari (o insiemi di vettori atomici) modo da poter lavorare\ncon loro più facilmente.rendere ordinati dati con broom, imparerai conoscere il set completo di strumenti\nforniti da broom e vedrai come possono essere applicati ad altri tipi di\nstrutture dati.rendere ordinati dati con broom, imparerai conoscere il set completo di strumenti\nforniti da broom e vedrai come possono essere applicati ad altri tipi di\nstrutture dati.Questo capitolo è qualche modo aspirazionale: se questo libro è la vostra prima introduzione R, questo capitolo sarà probabilmente una lotta. Richiede che abbiate idee profondamente interiorizzate su modellazione, strutture di dati e iterazione. Quindi non preoccupatevi se non lo capite — mettete da parte questo capitolo per qualche mese, e tornate quando vorrete ampliare il vostro cervello.","code":""},{"path":"molti-modelli.html","id":"prerequisiti-17","chapter":"25 Molti modelli","heading":"25.1.1 Prerequisiti","text":"Lavorare con molti modelli richiede molti dei pacchetti del tidyverse (per l’esplorazione dei dati, il wrangling e la programmazione) e modelr per facilitare la modellazione.","code":"\nlibrary(modelr)\nlibrary(tidyverse)"},{"path":"molti-modelli.html","id":"gapminder","chapter":"25 Molti modelli","heading":"25.2 gapminder","text":"Per motivare la potenza di molti modelli semplici, esamineremo dati “gapminder”. Questi dati sono stati resi popolari da Hans Rosling, un medico e statistico svedese. Se non avete mai sentito parlare di lui, smettete subito di leggere questo capitolo e andate guardare uno dei suoi video! È un fantastico presentatore di dati e illustra come è possibile utilizzare dati per presentare una storia convincente. Un buon punto di partenza è questo breve video girato insieme alla BBC: https://www.youtube.com/watch?v=jbkSRLYSojo.dati di gapminder riassumono la progressione dei paesi nel tempo, guardando statistiche come l’aspettativa di vita e il PIL. dati sono facilmente accessibili R, grazie Jenny Bryan che ha creato il pacchetto gapminder:questo caso di studio, ci concentreremo solo su tre variabili per rispondere alla domanda “Come cambia l’aspettativa di vita (lifeExp) nel tempo (year) per ogni paese (country)? Un buon punto di partenza è un grafico:Questo è un piccolo dataset: ha solo ~1.700 osservazioni e 3 variabili. Ma è ancora difficile vedere cosa sta succedendo! Nel complesso, sembra che l’aspettativa di vita sia migliorata costantemente. Tuttavia, se si guarda da vicino, si possono notare alcuni paesi che non seguono questo schema. Come possiamo rendere questi paesi più facili da vedere?Un modo è usare lo stesso approccio dell’ultimo capitolo: c’è un segnale forte (la crescita lineare complessiva) che rende difficile vedere tendenze più sottili. Distingueremo questi fattori adattando un modello con una tendenza lineare. Il modello cattura la crescita costante nel tempo, e residui mostreranno ciò che rimane.Sapete già come farlo se avessimo un singolo paese:Come possiamo facilmente adattare questo modello ad ogni paese?","code":"\nlibrary(gapminder)\ngapminder\n#> # A tibble: 1,704 × 6\n#>   country     continent  year lifeExp      pop gdpPercap\n#>   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#> 1 Afghanistan Asia       1952    28.8  8425333      779.\n#> 2 Afghanistan Asia       1957    30.3  9240934      821.\n#> 3 Afghanistan Asia       1962    32.0 10267083      853.\n#> 4 Afghanistan Asia       1967    34.0 11537966      836.\n#> 5 Afghanistan Asia       1972    36.1 13079460      740.\n#> 6 Afghanistan Asia       1977    38.4 14880372      786.\n#> # … with 1,698 more rows\ngapminder %>% \n  ggplot(aes(year, lifeExp, group = country)) +\n    geom_line(alpha = 1/3)\nnz <- filter(gapminder, country == \"New Zealand\")\nnz %>% \n  ggplot(aes(year, lifeExp)) + \n  geom_line() + \n  ggtitle(\"Full data = \")\n\nnz_mod <- lm(lifeExp ~ year, data = nz)\nnz %>% \n  add_predictions(nz_mod) %>%\n  ggplot(aes(year, pred)) + \n  geom_line() + \n  ggtitle(\"Linear trend + \")\n\nnz %>% \n  add_residuals(nz_mod) %>% \n  ggplot(aes(year, resid)) + \n  geom_hline(yintercept = 0, colour = \"white\", size = 3) + \n  geom_line() + \n  ggtitle(\"Remaining pattern\")\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead."},{"path":"molti-modelli.html","id":"dati-annidati","chapter":"25 Molti modelli","heading":"25.2.1 Dati annidati","text":"Potresti immaginare di copiare e incollare quel codice più volte; ma hai già imparato un modo migliore! Estrai il codice comune con una funzione e ripeti usando una funzione di mappa da purrr. Questo problema è strutturato un po’ diversamente da quello che hai visto prima. Invece di ripetere un’azione per ogni variabile, vogliamo ripetere un’azione per ogni paese, un sottoinsieme di righe. Per farlo, abbiamo bisogno di una nuova struttura di dati: il data frame annidato (nested data frame). Per creare un data frame annidato, iniziamo con un data frame raggruppato e lo annidiamo:(Sto imbrogliando un po’ raggruppando sia il continent che il country. Dato il country, il continente è fisso, quindi questo non aggiunge altri gruppi, ma è un modo semplice per portare con sé una variabile extra).Questo crea un frame di dati che ha una riga per gruppo (per paese) e una colonna piuttosto insolita: data. data è una lista di data frame (o tibbie, per essere precisi). Sembra un’idea folle: abbiamo un data frame con una colonna che è una lista di altri data frame! Spiegherò brevemente perché penso che sia una buona idea.La colonna data è un po’ difficile da guardare perché è una lista moderatamente complicata, e stiamo ancora lavorando su buoni strumenti per esplorare questi oggetti. Sfortunatamente l’uso di str() non è raccomandato perché spesso produce un output molto lungo. Ma se si estrae un singolo elemento dalla colonna data si vedrà che contiene tutti dati per quel paese (questo caso, Afghanistan).Notate la differenza tra un data frame standard raggruppato e un data frame annidato: un data frame raggruppato, ogni riga è un’osservazione; un data frame annidato, ogni riga è un gruppo. Un altro modo di pensare un dataset annidato è che ora abbiamo una meta-osservazione: una riga che rappresenta l’intero corso del tempo per un paese, piuttosto che un singolo punto nel tempo.","code":"\nby_country <- gapminder %>% \n  group_by(country, continent) %>% \n  nest()\n\nby_country\n#> # A tibble: 142 × 3\n#> # Groups:   country, continent [142]\n#>   country     continent data             \n#>   <fct>       <fct>     <list>           \n#> 1 Afghanistan Asia      <tibble [12 × 4]>\n#> 2 Albania     Europe    <tibble [12 × 4]>\n#> 3 Algeria     Africa    <tibble [12 × 4]>\n#> 4 Angola      Africa    <tibble [12 × 4]>\n#> 5 Argentina   Americas  <tibble [12 × 4]>\n#> 6 Australia   Oceania   <tibble [12 × 4]>\n#> # … with 136 more rows\nby_country$data[[1]]\n#> # A tibble: 12 × 4\n#>    year lifeExp      pop gdpPercap\n#>   <int>   <dbl>    <int>     <dbl>\n#> 1  1952    28.8  8425333      779.\n#> 2  1957    30.3  9240934      821.\n#> 3  1962    32.0 10267083      853.\n#> 4  1967    34.0 11537966      836.\n#> 5  1972    36.1 13079460      740.\n#> 6  1977    38.4 14880372      786.\n#> # … with 6 more rows"},{"path":"molti-modelli.html","id":"list-columns","chapter":"25 Molti modelli","heading":"25.2.2 List-columns","text":"Ora che abbiamo il nostro dataset annidato, siamo una buona posizione per adattare alcuni modelli. Abbiamo una funzione di adattamento del modello:E vogliamo applicarlo ad ogni frame di dati. frame di dati sono una lista, quindi possiamo usare purrr::map() per applicare country_model ad ogni elemento:Tuttavia, piuttosto che lasciare l’elenco dei modelli come un oggetto fluttuante, penso che sia meglio memorizzarlo come una colonna nel frame di dati by_country. Memorizzare oggetti correlati colonne è una parte fondamentale del valore dei data frame, e il motivo per cui penso che le colonne-elenco siano una buona idea. Nel corso del lavoro con questi paesi, avremo molte liste dove abbiamo un elemento per paese. Quindi perché non memorizzarli tutti insieme un unico frame di dati?altre parole, invece di creare un nuovo oggetto nell’ambiente globale, creeremo una nuova variabile nel data frame by_country. Questo è un lavoro per dplyr::mutate():Questo ha un grande vantaggio: poiché tutti gli oggetti correlati sono memorizzati insieme, non è necessario mantenerli manualmente sincronizzati quando si filtra o si organizza. La semantica del data frame se ne occupa per voi:Se la vostra lista di data frame e la lista di modelli fossero oggetti separati, dovete ricordarvi che ogni volta che riordinate o sotto-ordinate un vettore, dovete ri-ordinare o sotto-ordinare tutti gli altri per tenerli sincronizzati. Se lo dimenticate, il vostro codice continuerà funzionare, ma darà la risposta sbagliata!","code":"\ncountry_model <- function(df) {\n  lm(lifeExp ~ year, data = df)\n}\nmodels <- map(by_country$data, country_model)\nby_country <- by_country %>% \n  mutate(model = map(data, country_model))\nby_country\n#> # A tibble: 142 × 4\n#> # Groups:   country, continent [142]\n#>   country     continent data              model \n#>   <fct>       <fct>     <list>            <list>\n#> 1 Afghanistan Asia      <tibble [12 × 4]> <lm>  \n#> 2 Albania     Europe    <tibble [12 × 4]> <lm>  \n#> 3 Algeria     Africa    <tibble [12 × 4]> <lm>  \n#> 4 Angola      Africa    <tibble [12 × 4]> <lm>  \n#> 5 Argentina   Americas  <tibble [12 × 4]> <lm>  \n#> 6 Australia   Oceania   <tibble [12 × 4]> <lm>  \n#> # … with 136 more rows\nby_country %>% \n  filter(continent == \"Europe\")\n#> # A tibble: 30 × 4\n#> # Groups:   country, continent [30]\n#>   country                continent data              model \n#>   <fct>                  <fct>     <list>            <list>\n#> 1 Albania                Europe    <tibble [12 × 4]> <lm>  \n#> 2 Austria                Europe    <tibble [12 × 4]> <lm>  \n#> 3 Belgium                Europe    <tibble [12 × 4]> <lm>  \n#> 4 Bosnia and Herzegovina Europe    <tibble [12 × 4]> <lm>  \n#> 5 Bulgaria               Europe    <tibble [12 × 4]> <lm>  \n#> 6 Croatia                Europe    <tibble [12 × 4]> <lm>  \n#> # … with 24 more rows\nby_country %>% \n  arrange(continent, country)\n#> # A tibble: 142 × 4\n#> # Groups:   country, continent [142]\n#>   country      continent data              model \n#>   <fct>        <fct>     <list>            <list>\n#> 1 Algeria      Africa    <tibble [12 × 4]> <lm>  \n#> 2 Angola       Africa    <tibble [12 × 4]> <lm>  \n#> 3 Benin        Africa    <tibble [12 × 4]> <lm>  \n#> 4 Botswana     Africa    <tibble [12 × 4]> <lm>  \n#> 5 Burkina Faso Africa    <tibble [12 × 4]> <lm>  \n#> 6 Burundi      Africa    <tibble [12 × 4]> <lm>  \n#> # … with 136 more rows"},{"path":"molti-modelli.html","id":"disannidare-unnesting","chapter":"25 Molti modelli","heading":"25.2.3 Disannidare (unnesting)","text":"precedenza abbiamo calcolato residui di un singolo modello con un singolo set di dati. Ora abbiamo 142 frame di dati e 142 modelli. Per calcolare residui, dobbiamo chiamare add_residuals() con ogni coppia modello-dati:Ma come si può tracciare una lista di frame di dati? Invece di lottare per rispondere questa domanda, trasformiamo di nuovo la lista di data frame un normale data frame. precedenza abbiamo usato nest() per trasformare un data frame regolare un data frame annidato, e ora facciamo il contrario con unnest():Si noti che ogni colonna regolare è ripetuta una volta per ogni riga della tibla annidata.Ora che abbiamo una struttura di dati regolare, possiamo tracciare residui:La sfaccettatura per continente è particolarmente rivelatrice:Sembra che ci siamo persi alcuni schemi leggeri. C’è anche qualcosa di interessante Africa: vediamo alcuni residui molto grandi che suggeriscono che il nostro modello non si adatta così bene lì. Esploreremo meglio questo aspetto nella prossima sezione, attaccandolo da un’angolazione leggermente diversa.","code":"\nby_country <- by_country %>% \n  mutate(\n    resids = map2(data, model, add_residuals)\n  )\nby_country\n#> # A tibble: 142 × 5\n#> # Groups:   country, continent [142]\n#>   country     continent data              model  resids           \n#>   <fct>       <fct>     <list>            <list> <list>           \n#> 1 Afghanistan Asia      <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> 2 Albania     Europe    <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> 3 Algeria     Africa    <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> 4 Angola      Africa    <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> 5 Argentina   Americas  <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> 6 Australia   Oceania   <tibble [12 × 4]> <lm>   <tibble [12 × 5]>\n#> # … with 136 more rows\nresids <- unnest(by_country, resids)\nresids\n#> # A tibble: 1,704 × 9\n#> # Groups:   country, continent [142]\n#>   country     continent data     model   year lifeExp      pop gdpPercap   resid\n#>   <fct>       <fct>     <list>   <list> <int>   <dbl>    <int>     <dbl>   <dbl>\n#> 1 Afghanistan Asia      <tibble> <lm>    1952    28.8  8425333      779. -1.11  \n#> 2 Afghanistan Asia      <tibble> <lm>    1957    30.3  9240934      821. -0.952 \n#> 3 Afghanistan Asia      <tibble> <lm>    1962    32.0 10267083      853. -0.664 \n#> 4 Afghanistan Asia      <tibble> <lm>    1967    34.0 11537966      836. -0.0172\n#> 5 Afghanistan Asia      <tibble> <lm>    1972    36.1 13079460      740.  0.674 \n#> 6 Afghanistan Asia      <tibble> <lm>    1977    38.4 14880372      786.  1.65  \n#> # … with 1,698 more rows\nresids %>% \n  ggplot(aes(year, resid)) +\n    geom_line(aes(group = country), alpha = 1 / 3) + \n    geom_smooth(se = FALSE)\n#> `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\nresids %>% \n  ggplot(aes(year, resid, group = country)) +\n    geom_line(alpha = 1 / 3) + \n    facet_wrap(~continent)"},{"path":"molti-modelli.html","id":"qualità-del-modello","chapter":"25 Molti modelli","heading":"25.2.4 Qualità del modello","text":"Invece di guardare residui del modello, potremmo guardare alcune misure generali della qualità del modello. Avete imparato come calcolare alcune misure specifiche nel capitolo precedente. Qui mostreremo un approccio diverso usando il pacchetto broom. Il pacchetto broom fornisce un insieme generale di funzioni per trasformare modelli dati ordinati. Qui useremo broom::glance() per estrarre alcune metriche di qualità del modello. Se lo applichiamo un modello, otteniamo un frame di dati con una sola riga:Possiamo usare mutate() e unnest() per creare un frame di dati con una riga per ogni paese:Questo non è esattamente l’output che vogliamo, perché include ancora tutte le colonne della lista. Questo è il comportamento predefinito quando unnest() lavora su frame di dati riga singola. Per sopprimere queste colonne usiamo .drop = TRUE:(Fate attenzione alle variabili che non sono stampate: c’è un sacco di roba utile lì).Con questo quadro di dati mano, possiamo iniziare cercare modelli che non si adattano bene:modelli peggiori sembrano essere tutti Africa. Ricontrolliamo questo con un grafico. Qui abbiamo un numero relativamente piccolo di osservazioni e una variabile discreta, quindi geom_jitter() è efficace:Potremmo estrarre paesi con \\(R^2\\) particolarmente cattivi e tracciare dati:Qui vediamo due effetti principali: le tragedie dell’epidemia di HIV/AIDS e il genocidio del Ruanda.","code":"\nbroom::glance(nz_mod)\n#> # A tibble: 1 × 12\n#>   r.squ…¹ adj.r…² sigma stati…³ p.value    df logLik   AIC   BIC devia…⁴ df.re…⁵\n#>     <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>  <dbl> <dbl> <dbl>   <dbl>   <int>\n#> 1   0.954   0.949 0.804    205. 5.41e-8     1  -13.3  32.6  34.1    6.47      10\n#> # … with 1 more variable: nobs <int>, and abbreviated variable names\n#> #   ¹​r.squared, ²​adj.r.squared, ³​statistic, ⁴​deviance, ⁵​df.residual\nby_country %>% \n  mutate(glance = map(model, broom::glance)) %>% \n  unnest(glance)\n#> # A tibble: 142 × 17\n#> # Groups:   country, continent [142]\n#>   country conti…¹ data     model resids   r.squ…² adj.r…³ sigma stati…⁴  p.value\n#>   <fct>   <fct>   <list>   <lis> <list>     <dbl>   <dbl> <dbl>   <dbl>    <dbl>\n#> 1 Afghan… Asia    <tibble> <lm>  <tibble>   0.948   0.942 1.22    181.  9.84e- 8\n#> 2 Albania Europe  <tibble> <lm>  <tibble>   0.911   0.902 1.98    102.  1.46e- 6\n#> 3 Algeria Africa  <tibble> <lm>  <tibble>   0.985   0.984 1.32    662.  1.81e-10\n#> 4 Angola  Africa  <tibble> <lm>  <tibble>   0.888   0.877 1.41     79.1 4.59e- 6\n#> 5 Argent… Americ… <tibble> <lm>  <tibble>   0.996   0.995 0.292  2246.  4.22e-13\n#> 6 Austra… Oceania <tibble> <lm>  <tibble>   0.980   0.978 0.621   481.  8.67e-10\n#> # … with 136 more rows, 7 more variables: df <dbl>, logLik <dbl>, AIC <dbl>,\n#> #   BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>, and abbreviated\n#> #   variable names ¹​continent, ²​r.squared, ³​adj.r.squared, ⁴​statistic\nglance <- by_country %>% \n  mutate(glance = map(model, broom::glance)) %>% \n  unnest(glance, .drop = TRUE)\n#> Warning: The `.drop` argument of `unnest()` is deprecated as of tidyr 1.0.0.\n#> ℹ All list-columns are now preserved.\nglance\n#> # A tibble: 142 × 17\n#> # Groups:   country, continent [142]\n#>   country conti…¹ data     model resids   r.squ…² adj.r…³ sigma stati…⁴  p.value\n#>   <fct>   <fct>   <list>   <lis> <list>     <dbl>   <dbl> <dbl>   <dbl>    <dbl>\n#> 1 Afghan… Asia    <tibble> <lm>  <tibble>   0.948   0.942 1.22    181.  9.84e- 8\n#> 2 Albania Europe  <tibble> <lm>  <tibble>   0.911   0.902 1.98    102.  1.46e- 6\n#> 3 Algeria Africa  <tibble> <lm>  <tibble>   0.985   0.984 1.32    662.  1.81e-10\n#> 4 Angola  Africa  <tibble> <lm>  <tibble>   0.888   0.877 1.41     79.1 4.59e- 6\n#> 5 Argent… Americ… <tibble> <lm>  <tibble>   0.996   0.995 0.292  2246.  4.22e-13\n#> 6 Austra… Oceania <tibble> <lm>  <tibble>   0.980   0.978 0.621   481.  8.67e-10\n#> # … with 136 more rows, 7 more variables: df <dbl>, logLik <dbl>, AIC <dbl>,\n#> #   BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>, and abbreviated\n#> #   variable names ¹​continent, ²​r.squared, ³​adj.r.squared, ⁴​statistic\nglance %>% \n  arrange(r.squared)\n#> # A tibble: 142 × 17\n#> # Groups:   country, continent [142]\n#>   country conti…¹ data     model resids   r.squ…² adj.r.…³ sigma stati…⁴ p.value\n#>   <fct>   <fct>   <list>   <lis> <list>     <dbl>    <dbl> <dbl>   <dbl>   <dbl>\n#> 1 Rwanda  Africa  <tibble> <lm>  <tibble>  0.0172 -0.0811   6.56   0.175   0.685\n#> 2 Botswa… Africa  <tibble> <lm>  <tibble>  0.0340 -0.0626   6.11   0.352   0.566\n#> 3 Zimbab… Africa  <tibble> <lm>  <tibble>  0.0562 -0.0381   7.21   0.596   0.458\n#> 4 Zambia  Africa  <tibble> <lm>  <tibble>  0.0598 -0.0342   4.53   0.636   0.444\n#> 5 Swazil… Africa  <tibble> <lm>  <tibble>  0.0682 -0.0250   6.64   0.732   0.412\n#> 6 Lesotho Africa  <tibble> <lm>  <tibble>  0.0849 -0.00666  5.93   0.927   0.358\n#> # … with 136 more rows, 7 more variables: df <dbl>, logLik <dbl>, AIC <dbl>,\n#> #   BIC <dbl>, deviance <dbl>, df.residual <int>, nobs <int>, and abbreviated\n#> #   variable names ¹​continent, ²​r.squared, ³​adj.r.squared, ⁴​statistic\nglance %>% \n  ggplot(aes(continent, r.squared)) + \n    geom_jitter(width = 0.5)\nbad_fit <- filter(glance, r.squared < 0.25)\n\ngapminder %>% \n  semi_join(bad_fit, by = \"country\") %>% \n  ggplot(aes(year, lifeExp, colour = country)) +\n    geom_line()"},{"path":"molti-modelli.html","id":"esercizi-68","chapter":"25 Molti modelli","heading":"25.2.5 Esercizi","text":"Una tendenza lineare sembra essere un po’ troppo semplice per la tendenza generale.\nPuoi fare meglio con un polinomio quadratico? Come potete interpretare\ncoefficienti della quadratica? (Suggerimento: potreste voler trasformare\nanno` modo che abbia media zero).Una tendenza lineare sembra essere un po’ troppo semplice per la tendenza generale.\nPuoi fare meglio con un polinomio quadratico? Come potete interpretare\ncoefficienti della quadratica? (Suggerimento: potreste voler trasformare\nanno` modo che abbia media zero).Esplorate altri metodi per visualizzare la distribuzione di \\(R^2\\) per\ncontinente. Potreste provare il pacchetto ggbeeswarm, che fornisce\nmetodi simili per evitare sovrapposizioni come il jitter, ma usa metodi deterministici\ndeterministici.Esplorate altri metodi per visualizzare la distribuzione di \\(R^2\\) per\ncontinente. Potreste provare il pacchetto ggbeeswarm, che fornisce\nmetodi simili per evitare sovrapposizioni come il jitter, ma usa metodi deterministici\ndeterministici.Per creare l’ultimo grafico (che mostra dati per paesi con il\npeggiori modelli di adattamento), abbiamo avuto bisogno di due passaggi: abbiamo creato un frame di dati con\nuna riga per paese e poi lo abbiamo semi-unito al dataset originale.\nÈ possibile evitare questa unione se usiamo unnest() invece di\nunnest(.drop = TRUE). Come?Per creare l’ultimo grafico (che mostra dati per paesi con il\npeggiori modelli di adattamento), abbiamo avuto bisogno di due passaggi: abbiamo creato un frame di dati con\nuna riga per paese e poi lo abbiamo semi-unito al dataset originale.\nÈ possibile evitare questa unione se usiamo unnest() invece di\nunnest(.drop = TRUE). Come?","code":""},{"path":"molti-modelli.html","id":"list-columns-1","chapter":"25 Molti modelli","heading":"25.3 List-columns","text":"Ora che avete visto un flusso di lavoro di base per la gestione di molti modelli, rituffiamoci alcuni dettagli. questa sezione, esploreremo la struttura dati delle liste-colonne un po’ più dettaglio. È solo di recente che ho veramente apprezzato l’idea della colonna-elenco. Le liste-colonne sono implicite nella definizione del data frame: un data frame è una lista nominata di vettori di uguale lunghezza. Una lista è un vettore, quindi è sempre stato legittimo usare una lista come colonna di un data frame. Tuttavia, R di base non rende facile la creazione di liste-colonne, e data.frame() tratta una lista come una lista di colonne:.Potete evitare che data.frame() faccia questo con (), ma il risultato non viene stampato particolarmente bene:Tibble allevia questo problema essendo più pigro (tibble() non modifica suoi input) e fornendo un metodo di stampa migliore:È ancora più facile con tribble() quanto può capire automaticamente che avete bisogno di una lista:Le colonne-elenco sono spesso molto utili come struttura dati intermedia. Sono difficili da lavorare direttamente, perché la maggior parte delle funzioni di R lavora con vettori atomici o frame di dati, ma il vantaggio di tenere insieme elementi correlati un frame di dati vale un po’ di fastidio.Generalmente ci sono tre parti di una efficace pipeline lista-colonna:Si crea la lista-colonna usando uno dei metodi nest(), summarise() + list(),\no mutate() + una funzione di mappa, come descritto [Creare liste-colonne].Si crea la lista-colonna usando uno dei metodi nest(), summarise() + list(),\no mutate() + una funzione di mappa, come descritto [Creare liste-colonne].Si creano altre colonne-elenco intermedie trasformando le colonne-elenco esistenti con\ncolonne della lista con map(), map2() o pmap(). Per esempio,\nnel caso di studio precedente, abbiamo creato una lista-colonna di modelli trasformando\nuna colonna-elenco di frame di dati.Si creano altre colonne-elenco intermedie trasformando le colonne-elenco esistenti con\ncolonne della lista con map(), map2() o pmap(). Per esempio,\nnel caso di studio precedente, abbiamo creato una lista-colonna di modelli trasformando\nuna colonna-elenco di frame di dati.Si semplifica la lista-colonna riducendola un data frame o un vettore atomico,\ncome descritto [Simplifying list-columns].Si semplifica la lista-colonna riducendola un data frame o un vettore atomico,\ncome descritto [Simplifying list-columns].","code":"\ndata.frame(x = list(1:3, 3:5))\n#>   x.1.3 x.3.5\n#> 1     1     3\n#> 2     2     4\n#> 3     3     5\ndata.frame(\n  x = I(list(1:3, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#>         x       y\n#> 1 1, 2, 3    1, 2\n#> 2 3, 4, 5 3, 4, 5\ntibble(\n  x = list(1:3, 3:5), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#> # A tibble: 2 × 2\n#>   x         y      \n#>   <list>    <chr>  \n#> 1 <int [3]> 1, 2   \n#> 2 <int [3]> 3, 4, 5\ntribble(\n   ~x, ~y,\n  1:3, \"1, 2\",\n  3:5, \"3, 4, 5\"\n)\n#> # A tibble: 2 × 2\n#>   x         y      \n#>   <list>    <chr>  \n#> 1 <int [3]> 1, 2   \n#> 2 <int [3]> 3, 4, 5"},{"path":"molti-modelli.html","id":"creazione-di-list-columns","chapter":"25 Molti modelli","heading":"25.4 Creazione di list-columns","text":"Tipicamente, non si creano colonne-elenco con tibble(). Invece, le creerai da colonne regolari, usando uno dei tre metodi:Con tidyr::nest() per convertire un data frame raggruppato un data frame annidato\nun frame di dati annidato cui si ha una lista-colonna di frame di dati.Con tidyr::nest() per convertire un data frame raggruppato un data frame annidato\nun frame di dati annidato cui si ha una lista-colonna di frame di dati.Con mutate() e funzioni vettoriali che restituiscono una lista.\nCon mutate() e funzioni vettoriali che restituiscono una lista.Con summarise() e le funzioni di riepilogo che restituiscono più risultati.Con summarise() e le funzioni di riepilogo che restituiscono più risultati.alternativa, potreste crearli da una lista nominata, usando tibble::enframe().Generalmente, quando si creano colonne di liste, ci si dovrebbe assicurare che siano omogenee: ogni elemento dovrebbe contenere lo stesso tipo di cose. Non ci sono controlli per assicurarsi che questo sia vero, ma se usate purrr e ricordate ciò che avete imparato sulle funzioni type-stable, dovreste scoprire che ciò avviene naturalmente.","code":""},{"path":"molti-modelli.html","id":"con-lannidamento","chapter":"25 Molti modelli","heading":"25.4.1 Con l’annidamento","text":"nest() crea un data frame annidato, che è un data frame con una lista-colonna di data frame. un data frame annidato ogni riga è una meta-osservazione: le altre colonne danno le variabili che definiscono l’osservazione (come il paese e il continente sopra), e la lista-colonna di data frame dà le singole osservazioni che compongono la meta-osservazione.Ci sono due modi per usare nest(). Finora avete visto come usarlo con un frame di dati raggruppato. Quando viene applicato ad un frame di dati raggruppati, nest() mantiene le colonne di raggruppamento così come sono, e raggruppa tutto il resto nella lista-colonna:Potete anche usarlo su un frame di dati non raggruppato, specificando quali colonne volete annidare:","code":"\ngapminder %>% \n  group_by(country, continent) %>% \n  nest()\n#> # A tibble: 142 × 3\n#> # Groups:   country, continent [142]\n#>   country     continent data             \n#>   <fct>       <fct>     <list>           \n#> 1 Afghanistan Asia      <tibble [12 × 4]>\n#> 2 Albania     Europe    <tibble [12 × 4]>\n#> 3 Algeria     Africa    <tibble [12 × 4]>\n#> 4 Angola      Africa    <tibble [12 × 4]>\n#> 5 Argentina   Americas  <tibble [12 × 4]>\n#> 6 Australia   Oceania   <tibble [12 × 4]>\n#> # … with 136 more rows\ngapminder %>% \n  nest(data = c(year:gdpPercap))\n#> # A tibble: 142 × 3\n#>   country     continent data             \n#>   <fct>       <fct>     <list>           \n#> 1 Afghanistan Asia      <tibble [12 × 4]>\n#> 2 Albania     Europe    <tibble [12 × 4]>\n#> 3 Algeria     Africa    <tibble [12 × 4]>\n#> 4 Angola      Africa    <tibble [12 × 4]>\n#> 5 Argentina   Americas  <tibble [12 × 4]>\n#> 6 Australia   Oceania   <tibble [12 × 4]>\n#> # … with 136 more rows"},{"path":"molti-modelli.html","id":"dalle-funzioni-vettoriali","chapter":"25 Molti modelli","heading":"25.4.2 Dalle funzioni vettoriali","text":"Alcune funzioni utili prendono un vettore atomico e restituiscono una lista. Per esempio, [strings] avete imparato conoscere stringr::str_split() che prende un vettore di caratteri e restituisce una lista di vettori di caratteri. Se lo usi dentro mutate, otterrai una lista-colonna:unnest() sa come gestire queste liste di vettori:(Se vi trovate ad usare spesso questo schema, assicuratevi di controllare tidyr::separate_rows() che è un wrapper intorno questo schema comune).Un altro esempio di questo pattern è l’uso di map(), map2(), pmap() da purrr. Per esempio, potremmo prendere l’esempio finale da [Invoking different functions] e riscriverlo per usare mutate():Notate che tecnicamente sim non è omogeneo perché contiene sia vettori doppi che interi. Tuttavia, è improbabile che questo causi molti problemi, dato che interi e doppi sono entrambi vettori numerici.","code":"\ndf <- tribble(\n  ~x1,\n  \"a,b,c\", \n  \"d,e,f,g\"\n) \n\ndf %>% \n  mutate(x2 = stringr::str_split(x1, \",\"))\n#> # A tibble: 2 × 2\n#>   x1      x2       \n#>   <chr>   <list>   \n#> 1 a,b,c   <chr [3]>\n#> 2 d,e,f,g <chr [4]>\ndf %>% \n  mutate(x2 = stringr::str_split(x1, \",\")) %>% \n  unnest(x2)\n#> # A tibble: 7 × 2\n#>   x1      x2   \n#>   <chr>   <chr>\n#> 1 a,b,c   a    \n#> 2 a,b,c   b    \n#> 3 a,b,c   c    \n#> 4 d,e,f,g d    \n#> 5 d,e,f,g e    \n#> 6 d,e,f,g f    \n#> # … with 1 more row\nsim <- tribble(\n  ~f,      ~params,\n  \"runif\", list(min = -1, max = 1),\n  \"rnorm\", list(sd = 5),\n  \"rpois\", list(lambda = 10)\n)\n\nsim %>%\n  mutate(sims = invoke_map(f, params, n = 10))\n#> Warning: There was 1 warning in `mutate()`.\n#> ℹ In argument: `sims = invoke_map(f, params, n = 10)`.\n#> Caused by warning:\n#> ! `invoke_map()` was deprecated in purrr 1.0.0.\n#> ℹ Please use map() + exec() instead.\n#> # A tibble: 3 × 3\n#>   f     params           sims      \n#>   <chr> <list>           <list>    \n#> 1 runif <named list [2]> <dbl [10]>\n#> 2 rnorm <named list [1]> <dbl [10]>\n#> 3 rpois <named list [1]> <int [10]>"},{"path":"molti-modelli.html","id":"dai-sommari-multivalutati","chapter":"25 Molti modelli","heading":"25.4.3 Dai sommari multivalutati","text":"Una restrizione di summarise() è che funziona solo con funzioni di riepilogo che restituiscono un singolo valore. Ciò significa che non potete usarla con funzioni come quantile() che restituiscono un vettore di lunghezza arbitraria:Potete però avvolgere il risultato una lista! Questo obbedisce al contratto di summarise(), perché ogni sommario è ora una lista (un vettore) di lunghezza 1.Per ottenere risultati utili con unnest, dovrete anche catturare le probabilità:","code":"\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = quantile(mpg))\n#> Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\n#> dplyr 1.1.0.\n#> ℹ Please use `reframe()` instead.\n#> ℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n#>   always returns an ungrouped data frame and adjust accordingly.\n#> `summarise()` has grouped output by 'cyl'. You can override using the `.groups`\n#> argument.\n#> # A tibble: 15 × 2\n#> # Groups:   cyl [3]\n#>     cyl     q\n#>   <dbl> <dbl>\n#> 1     4  21.4\n#> 2     4  22.8\n#> 3     4  26  \n#> 4     4  30.4\n#> 5     4  33.9\n#> 6     6  17.8\n#> # … with 9 more rows\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = list(quantile(mpg)))\n#> # A tibble: 3 × 2\n#>     cyl q        \n#>   <dbl> <list>   \n#> 1     4 <dbl [5]>\n#> 2     6 <dbl [5]>\n#> 3     8 <dbl [5]>\nprobs <- c(0.01, 0.25, 0.5, 0.75, 0.99)\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(p = list(probs), q = list(quantile(mpg, probs))) %>% \n  unnest(c(p, q))\n#> # A tibble: 15 × 3\n#>     cyl     p     q\n#>   <dbl> <dbl> <dbl>\n#> 1     4  0.01  21.4\n#> 2     4  0.25  22.8\n#> 3     4  0.5   26  \n#> 4     4  0.75  30.4\n#> 5     4  0.99  33.8\n#> 6     6  0.01  17.8\n#> # … with 9 more rows"},{"path":"molti-modelli.html","id":"da-un-elenco-con-nome","chapter":"25 Molti modelli","heading":"25.4.4 Da un elenco con nome","text":"data frame con colonne di liste forniscono una soluzione ad un problema comune: cosa fare se si vuole iterare sia il contenuto di una lista che suoi elementi? Invece di cercare di incastrare tutto un solo oggetto, è spesso più facile fare un data frame: una colonna può contenere gli elementi, e una colonna può contenere la lista. Un modo semplice per creare un tale data frame da una lista è tibble::enframe().Il vantaggio di questa struttura è che si generalizza modo diretto - nomi sono utili se avete un vettore di metadati carattere, ma non aiutano se avete altri tipi di dati, o vettori multipli.Ora, se volete iterare su nomi e valori parallelo, potete usare map2():","code":"\nx <- list(\n  a = 1:5,\n  b = 3:4, \n  c = 5:6\n) \n\ndf <- enframe(x)\ndf\n#> # A tibble: 3 × 2\n#>   name  value    \n#>   <chr> <list>   \n#> 1 a     <int [5]>\n#> 2 b     <int [2]>\n#> 3 c     <int [2]>\ndf %>% \n  mutate(\n    smry = map2_chr(name, value, ~ stringr::str_c(.x, \": \", .y[1]))\n  )\n#> # A tibble: 3 × 3\n#>   name  value     smry \n#>   <chr> <list>    <chr>\n#> 1 a     <int [5]> a: 1 \n#> 2 b     <int [2]> b: 3 \n#> 3 c     <int [2]> c: 5"},{"path":"molti-modelli.html","id":"esercizi-69","chapter":"25 Molti modelli","heading":"25.4.5 Esercizi","text":"Elenca tutte le funzioni che ti vengono mente che prendono un vettore atomico e\nrestituire una lista.Elenca tutte le funzioni che ti vengono mente che prendono un vettore atomico e\nrestituire una lista.Inventa utili funzioni di riepilogo che, come la quantile(), restituiscono\nvalori multipli.Inventa utili funzioni di riepilogo che, come la quantile(), restituiscono\nvalori multipli.Cosa manca nel seguente data frame? Come fa la funzione quantile() restituire\nquel pezzo mancante? Perché non è utile questo caso?\n\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = list(quantile(mpg))) %>% \n  unnest(q)\n#> # tibble: 15 × 2\n#>     cyl     q\n#>   <dbl> <dbl>\n#> 1     4  21.4\n#> 2     4  22.8\n#> 3     4  26  \n#> 4     4  30.4\n#> 5     4  33.9\n#> 6     6  17.8\n#> # … 9 rowsCosa manca nel seguente data frame? Come fa la funzione quantile() restituire\nquel pezzo mancante? Perché non è utile questo caso?Cosa fa questo codice? Perché potrebbe essere utile?\n\nmtcars %>% \n  group_by(cyl) %>% \n  summarise_all(list(list))Cosa fa questo codice? Perché potrebbe essere utile?","code":"\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = list(quantile(mpg))) %>% \n  unnest(q)\n#> # A tibble: 15 × 2\n#>     cyl     q\n#>   <dbl> <dbl>\n#> 1     4  21.4\n#> 2     4  22.8\n#> 3     4  26  \n#> 4     4  30.4\n#> 5     4  33.9\n#> 6     6  17.8\n#> # … with 9 more rows\nmtcars %>% \n  group_by(cyl) %>% \n  summarise_all(list(list))"},{"path":"molti-modelli.html","id":"semplificare-le-list-columns","chapter":"25 Molti modelli","heading":"25.5 Semplificare le list-columns","text":"Per applicare le tecniche di manipolazione e visualizzazione dei dati che hai imparato questo libro, avrai bisogno di semplificare la lista-colonna una colonna regolare (un vettore atomico), o un insieme di colonne. La tecnica che userete per ridurla ad una struttura più semplice dipende dal fatto che vogliate un singolo valore per elemento o più valori:Se volete un singolo valore, usate mutate() con map_lgl(),\nmap_int(), map_dbl(), e map_chr() per creare un vettore atomico.Se volete un singolo valore, usate mutate() con map_lgl(),\nmap_int(), map_dbl(), e map_chr() per creare un vettore atomico.Se volete molti valori, usate unnest() per convertire le colonne della lista\ncolonne regolari, ripetendo le righe tante volte quanto necessario.Se volete molti valori, usate unnest() per convertire le colonne della lista\ncolonne regolari, ripetendo le righe tante volte quanto necessario.Questi sono descritti più dettaglio qui di seguito.","code":""},{"path":"molti-modelli.html","id":"da-lista-a-vettore","chapter":"25 Molti modelli","heading":"25.5.1 Da lista a vettore","text":"Se si può ridurre la colonna della lista ad un vettore atomico, allora sarà una colonna regolare. Per esempio, potete sempre riassumere un oggetto con il suo tipo e la sua lunghezza, quindi questo codice funzionerà indipendentemente dal tipo di colonna elenco che avete:Queste sono le stesse informazioni di base che si ottengono dal metodo di stampa predefinito di tbl, ma ora si possono usare per filtrare. Questa è una tecnica utile se avete una lista eterogenea e volete filtrare le parti che non funzionano.Non dimenticate le scorciatoie map_*() - potete usare map_chr(x, \"apple\") per estrarre la stringa memorizzata apple per ogni elemento di x. Questo è utile per estrarre liste annidate colonne regolari. Usate l’argomento .null per fornire un valore da usare se l’elemento manca (invece di restituire NULL):","code":"\ndf <- tribble(\n  ~x,\n  letters[1:5],\n  1:3,\n  runif(5)\n)\n  \ndf %>% mutate(\n  type = map_chr(x, typeof),\n  length = map_int(x, length)\n)\n#> # A tibble: 3 × 3\n#>   x         type      length\n#>   <list>    <chr>      <int>\n#> 1 <chr [5]> character      5\n#> 2 <int [3]> integer        3\n#> 3 <dbl [5]> double         5\ndf <- tribble(\n  ~x,\n  list(a = 1, b = 2),\n  list(a = 2, c = 4)\n)\ndf %>% mutate(\n  a = map_dbl(x, \"a\"),\n  b = map_dbl(x, \"b\", .null = NA_real_)\n)\n#> # A tibble: 2 × 3\n#>   x                    a     b\n#>   <list>           <dbl> <dbl>\n#> 1 <named list [2]>     1     2\n#> 2 <named list [2]>     2    NA"},{"path":"molti-modelli.html","id":"unnesting","chapter":"25 Molti modelli","heading":"25.5.2 Unnesting","text":"unnest() funziona ripetendo le colonne regolari una volta per ogni elemento della lista-colonna. Per esempio, nel seguente esempio molto semplice ripetiamo la prima riga 4 volte (perché lì il primo elemento di y ha lunghezza quattro), e la seconda riga una volta:Questo significa che non si può contemporaneamente snidare due colonne che contengono un numero diverso di elementi:Lo stesso principio si applica quando si unnestano le colonne dell’elenco dei frame di dati. Potete unnestare più colonne-elenco finché tutti frame di dati ogni riga hanno lo stesso numero di righe.","code":"\ntibble(x = 1:2, y = list(1:4, 1)) %>% unnest(y)\n#> # A tibble: 5 × 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     1\n#> 2     1     2\n#> 3     1     3\n#> 4     1     4\n#> 5     2     1\n# Ok, perché y e z hanno lo stesso numero di elementi in \n# ogni riga\ndf1 <- tribble(\n  ~x, ~y,           ~z,\n   1, c(\"a\", \"b\"), 1:2,\n   2, \"c\",           3\n)\ndf1\n#> # A tibble: 2 × 3\n#>       x y         z        \n#>   <dbl> <list>    <list>   \n#> 1     1 <chr [2]> <int [2]>\n#> 2     2 <chr [1]> <dbl [1]>\ndf1 %>% unnest(c(y, z))\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 a         1\n#> 2     1 b         2\n#> 3     2 c         3\n\n# Non funziona perché y e z hanno un numero diverso di elementi\ndf2 <- tribble(\n  ~x, ~y,           ~z,\n   1, \"a\",         1:2,  \n   2, c(\"b\", \"c\"),   3\n)\ndf2\n#> # A tibble: 2 × 3\n#>       x y         z        \n#>   <dbl> <list>    <list>   \n#> 1     1 <chr [1]> <int [2]>\n#> 2     2 <chr [2]> <dbl [1]>\ndf2 %>% unnest(c(y, z))\n#> # A tibble: 4 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 a         1\n#> 2     1 a         2\n#> 3     2 b         3\n#> 4     2 c         3"},{"path":"molti-modelli.html","id":"esercizi-70","chapter":"25 Molti modelli","heading":"25.5.3 Esercizi","text":"Perché la funzione lengths() potrebbe essere utile per creare colonne\ncolonne vettoriali da colonne-elenco?Perché la funzione lengths() potrebbe essere utile per creare colonne\ncolonne vettoriali da colonne-elenco?Elencare tipi più comuni di vettore che si trovano un data frame. Cosa rende\ndiverse le liste?Elencare tipi più comuni di vettore che si trovano un data frame. Cosa rende\ndiverse le liste?","code":""},{"path":"molti-modelli.html","id":"rendere-ordinati-i-dati-con-broom","chapter":"25 Molti modelli","heading":"25.6 Rendere ordinati i dati con broom","text":"Il pacchetto broom fornisce tre strumenti generali per trasformare modelli frame di dati ordinati:broom::glance(model) restituisce una riga per ogni modello. Ogni colonna fornisce un\nriepilogo del modello: o una misura della qualità del modello, o della complessità, o una\ncombinazione dei due.broom::glance(model) restituisce una riga per ogni modello. Ogni colonna fornisce un\nriepilogo del modello: o una misura della qualità del modello, o della complessità, o una\ncombinazione dei due.broom::tidy(model) restituisce una riga per ogni coefficiente nel modello. Ogni\ncolonna fornisce informazioni sulla stima o sulla sua variabilità.\nbroom::tidy(model) restituisce una riga per ogni coefficiente nel modello. Ogni\ncolonna fornisce informazioni sulla stima o sulla sua variabilità.broom::augment(model, data) restituisce una riga per ogni riga data, aggiungendo\nvalori extra come residui e le statistiche di influenza.\nbroom::augment(model, data) restituisce una riga per ogni riga data, aggiungendo\nvalori extra come residui e le statistiche di influenza.","code":""},{"path":"communicate-intro.html","id":"communicate-intro","chapter":"26 Introduzione","heading":"26 Introduzione","text":"Finora avete imparato gli strumenti per portare vostri dati R, ordinarli una forma conveniente per l’analisi, e poi capire vostri dati attraverso la trasformazione, la visualizzazione e la modellazione. Tuttavia, non importa quanto grande sia la vostra analisi se non potete spiegarla agli altri: dovete comunicare vostri risultati.La comunicazione è il tema dei quattro capitoli seguenti:R Markdown, imparerete conoscere R Markdown, uno strumento per integrare\nprosa, codice e risultati. È possibile utilizzare R Markdown modalità notebook per la\ncomunicazione da analista ad analista e modalità report per\nper la comunicazione tra analisti e decisori. Grazie alla potenza dei formati R Markdown\nè possibile utilizzare lo stesso documento per entrambi gli scopi.R Markdown, imparerete conoscere R Markdown, uno strumento per integrare\nprosa, codice e risultati. È possibile utilizzare R Markdown modalità notebook per la\ncomunicazione da analista ad analista e modalità report per\nper la comunicazione tra analisti e decisori. Grazie alla potenza dei formati R Markdown\nè possibile utilizzare lo stesso documento per entrambi gli scopi.Grafici per la comunicazione, imparerete prendere vostri grafici esplorativi e trasformarli grafici espositivi.\nesplorativi e trasformarli grafici espositivi, che aiutino il nuovo arrivato capire\nche aiutino il nuovo arrivato capire cosa sta succedendo il più rapidamente e\npiù rapidamente e facilmente possibile.Grafici per la comunicazione, imparerete prendere vostri grafici esplorativi e trasformarli grafici espositivi.\nesplorativi e trasformarli grafici espositivi, che aiutino il nuovo arrivato capire\nche aiutino il nuovo arrivato capire cosa sta succedendo il più rapidamente e\npiù rapidamente e facilmente possibile.Formati di R Markdown, imparerete conoscere le molte altre varietà di output che potete produrre utilizzando R Markdown.\ndi output che si possono produrre utilizzando R Markdown, tra cui dashboard, siti web e libri,\ne libri.Formati di R Markdown, imparerete conoscere le molte altre varietà di output che potete produrre utilizzando R Markdown.\ndi output che si possono produrre utilizzando R Markdown, tra cui dashboard, siti web e libri,\ne libri.Concluderemo con R Markdown workflow, dove imparerete conoscere il “taccuino di analisi” e come sistemare dati.\n“taccuino di analisi” e su come registrare sistematicamente vostri successi e vostri\nfallimenti modo da poter imparare da essi.Concluderemo con R Markdown workflow, dove imparerete conoscere il “taccuino di analisi” e come sistemare dati.\n“taccuino di analisi” e su come registrare sistematicamente vostri successi e vostri\nfallimenti modo da poter imparare da essi.Sfortunatamente, questi capitoli si concentrano soprattutto sui meccanismi tecnici della comunicazione, non sui problemi davvero difficili della comunicazione dei propri pensieri ad altri esseri umani. Tuttavia, ci sono molti altri ottimi libri sulla comunicazione, che vi indicheremo alla fine di ogni capitolo.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"27 R Markdown","heading":"27 R Markdown","text":"","code":""},{"path":"r-markdown.html","id":"introduzione-18","chapter":"27 R Markdown","heading":"27.1 Introduzione","text":"R Markdown fornisce un framework di authoring unificato per la scienza dei dati, che combina il codice, risultati e commenti prosa. documenti R Markdown sono completamente riproducibili e supportano decine di formati di output, come PDF, file Word, presentazioni e altro ancora.file R Markdown sono progettati per essere utilizzati tre modi:Per comunicare ai decisori, che vogliono concentrarsi sulle conclusioni,\nnon sul codice che sta dietro l’analisi.Per comunicare ai decisori, che vogliono concentrarsi sulle conclusioni,\nnon sul codice che sta dietro l’analisi.Per collaborare con altri data scientist (compreso il futuro te stesso!), che sono interessati sia alle vostre conclusioni che al modo cui le avete elaborate.\nche sono interessati sia alle vostre conclusioni che al modo cui le avete raggiunte (cioè il codice).\nil codice).Per collaborare con altri data scientist (compreso il futuro te stesso!), che sono interessati sia alle vostre conclusioni che al modo cui le avete elaborate.\nche sono interessati sia alle vostre conclusioni che al modo cui le avete raggiunte (cioè il codice).\nil codice).Come ambiente cui “fare” scienza dei dati, come un moderno taccuino di laboratorio\ndi laboratorio dove è possibile registrare non solo ciò che si è fatto, ma anche ciò che si è pensato.\npensiero.Come ambiente cui “fare” scienza dei dati, come un moderno taccuino di laboratorio\ndi laboratorio dove è possibile registrare non solo ciò che si è fatto, ma anche ciò che si è pensato.\npensiero.R Markdown integra una serie di pacchetti R e di strumenti esterni. Ciò significa che l’aiuto non è genere disponibile attraverso ?. Invece, mentre lavorate questo capitolo e utilizzate R Markdown futuro, tenete portata di mano queste risorse:R Markdown Cheat Sheet: Help > Cheatsheets > R Markdown Cheat Sheet,R Markdown Cheat Sheet: Help > Cheatsheets > R Markdown Cheat Sheet,Guida di riferimento R Markdown: Help > Cheatsheets > R Markdown Reference Guide.\nGuida_.Guida di riferimento R Markdown: Help > Cheatsheets > R Markdown Reference Guide.\nGuida_.Entrambi fogli informativi sono disponibili anche ’indirizzo https://rstudio.com/resources/cheatsheets/.","code":""},{"path":"r-markdown.html","id":"prerequisiti-18","chapter":"27 R Markdown","heading":"27.1.1 Prerequisiti","text":"È necessario il pacchetto rmarkdown, ma non è necessario installarlo o caricarlo esplicitamente, poiché RStudio fa automaticamente entrambe le cose quando necessario.","code":""},{"path":"r-markdown.html","id":"nozioni-di-base-di-r-markdown","chapter":"27 R Markdown","heading":"27.2 Nozioni di base di R Markdown","text":"Questo è un file R Markdown, un file di testo semplice con estensione .Rmd:Contiene tre importanti tipi di contenuti:Un’intestazione (opzionale) __YAML circondata da ---s.Chunks di codice R circondati da ```.Testo mescolato con una semplice formattazione del testo come # heading e _italics_.Quando si apre un `.Rmd’, si ottiene un’interfaccia di blocco note cui il codice e l’output sono interlacciati. È possibile eseguire ciascun pezzo di codice facendo clic sull’icona Esegui (simile un pulsante di riproduzione nella parte superiore del pezzo) o premendo Cmd/Ctrl + Maiusc + Invio. RStudio esegue il codice e visualizza risultati linea con il codice:Per produrre un rapporto completo contenente tutto il testo, il codice e risultati, fare clic su “Knit” o premere Cmd/Ctrl + Shift + K. È possibile farlo anche modo programmatico con rmarkdown::render(\"1-example.Rmd\"). questo modo si visualizza il rapporto nel riquadro del visualizzatore e si crea un file HTML autonomo che si può condividere con altri.Quando si knit il documento, R Markdown invia il file .Rmd knitr, http://yihui.name/knitr/, che esegue tutti pezzi di codice e crea un nuovo documento markdown (.md) che include il codice e il suo output. Il file markdown generato da knitr viene poi elaborato da pandoc, http://pandoc.org/, che è responsabile della creazione del file finito. Il vantaggio di questo flusso di lavoro due fasi è che si può creare un’ampia gamma di formati di output, come si vedrà Formati di R markdown.Per iniziare creare il proprio file `.Rmd’, selezionare File > New File > R Markdown… nella barra dei menu. RStudio lancerà una procedura guidata che potrete utilizzare per pre-popolare il vostro file con contenuti utili che vi ricorderanno come funzionano le caratteristiche principali di R Markdown.Le sezioni seguenti approfondiscono tre componenti di un documento R Markdown: il testo markdown, pezzi di codice e l’intestazione YAML.","code":"---\ntitle: \"Diamond sizes\"\ndate: 2016-08-25\noutput: html_document\n---\n\n```{r setup, include = FALSE}\nlibrary(ggplot2)\nlibrary(dplyr)\n\nsmaller <- diamonds %>% \n  filter(carat <= 2.5)\n```\n\nWe have data about `r nrow(diamonds)` diamonds. Only \n`r nrow(diamonds) - nrow(smaller)` are larger than\n2.5 carats. The distribution of the remainder is shown\nbelow:\n\n```{r, echo = FALSE}\nsmaller %>% \n  ggplot(aes(carat)) + \n  geom_freqpoly(binwidth = 0.01)\n```"},{"path":"r-markdown.html","id":"esercizi-71","chapter":"27 R Markdown","heading":"27.2.1 Esercizi","text":"Creare un nuovo blocco note utilizzando File > New File > R Notebook. Leggere le\nistruzioni. Esercitatevi eseguire pezzi. Verificare che sia possibile modificare\nil codice, eseguirlo nuovamente e vedere l’output modificato.Creare un nuovo blocco note utilizzando File > New File > R Notebook. Leggere le\nistruzioni. Esercitatevi eseguire pezzi. Verificare che sia possibile modificare\nil codice, eseguirlo nuovamente e vedere l’output modificato.Create un nuovo documento R Markdown con File > New File > R Markdown….\nLavorare maglia facendo clic sul pulsante appropriato. Lavorare con la scorciatoia da tastiera appropriata.\ntastiera appropriata. Verificare che sia possibile modificare l’input\ne vedere l’aggiornamento dell’output.Create un nuovo documento R Markdown con File > New File > R Markdown….\nLavorare maglia facendo clic sul pulsante appropriato. Lavorare con la scorciatoia da tastiera appropriata.\ntastiera appropriata. Verificare che sia possibile modificare l’input\ne vedere l’aggiornamento dell’output.Confrontate e confrontate file R notebook e R markdown creati precedenza.\nsopra. che modo gli output sono simili? che modo sono diversi? Come sono\ngli input sono simili? che modo sono diversi? Cosa succede se\ncopiare l’intestazione YAML da uno ’altro?Confrontate e confrontate file R notebook e R markdown creati precedenza.\nsopra. che modo gli output sono simili? che modo sono diversi? Come sono\ngli input sono simili? che modo sono diversi? Cosa succede se\ncopiare l’intestazione YAML da uno ’altro?Creare un nuovo documento R Markdown per ognuno dei tre formati incorporati\nformati incorporati: HTML, PDF e Word. Lavorate maglia ciascuno dei tre documenti.\nche modo l’output differisce? cosa differisce l’input? (Potrebbe essere necessario\ninstallare LaTeX per creare l’output PDF — RStudio vi chiederà se è necessario).\nvi chiederà se ciò è necessario).Creare un nuovo documento R Markdown per ognuno dei tre formati incorporati\nformati incorporati: HTML, PDF e Word. Lavorate maglia ciascuno dei tre documenti.\nche modo l’output differisce? cosa differisce l’input? (Potrebbe essere necessario\ninstallare LaTeX per creare l’output PDF — RStudio vi chiederà se è necessario).\nvi chiederà se ciò è necessario).","code":""},{"path":"r-markdown.html","id":"formattazione-del-testo-con-markdown","chapter":"27 R Markdown","heading":"27.3 Formattazione del testo con Markdown","text":"La prosa nei file .Rmd è scritta Markdown, un insieme leggero di convenzioni per la formattazione dei file di testo. Markdown è stato progettato per essere facile da leggere e da scrivere. È anche molto facile da imparare. La guida che segue mostra come utilizzare il Markdown di Pandoc, una versione leggermente estesa di Markdown che R Markdown comprende.Il modo migliore per impararle è semplicemente provarle. Ci vorrà qualche giorno, ma presto diventeranno una seconda natura e non sarà più necessario pensarci. caso di dimenticanza, è possibile accedere un pratico foglio di riferimento con Help > Markdown Quick Reference.","code":"Text formatting \n------------------------------------------------------------\n\n*italic*  or _italic_\n**bold**   __bold__\n`code`\nsuperscript^2^ and subscript~2~\n\nHeadings\n------------------------------------------------------------\n\n# 1st Level Header\n\n## 2nd Level Header\n\n### 3rd Level Header\n\nLists\n------------------------------------------------------------\n\n*   Bulleted list item 1\n\n*   Item 2\n\n    * Item 2a\n\n    * Item 2b\n\n1.  Numbered list item 1\n\n1.  Item 2. The numbers are incremented automatically in the output.\n\nLinks and images\n------------------------------------------------------------\n\n<http://example.com>\n\n[linked phrase](http://example.com)\n\n![optional caption text](path/to/img.png)\n\nTables \n------------------------------------------------------------\n\nFirst Header  | Second Header\n------------- | -------------\nContent Cell  | Content Cell\nContent Cell  | Content Cell"},{"path":"r-markdown.html","id":"esercizi-72","chapter":"27 R Markdown","heading":"27.3.1 Esercizi","text":"Mettete pratica quanto appreso creando un breve curriculum vitae. Il titolo dovrebbe essere\nil vostro nome, e dovreste includere titoli per (almeno) l’istruzione o l’impiego.\noccupazione. Ciascuna delle sezioni deve includere un elenco puntato di\nlavori/diplomi. Evidenziate l’anno grassetto.Mettete pratica quanto appreso creando un breve curriculum vitae. Il titolo dovrebbe essere\nil vostro nome, e dovreste includere titoli per (almeno) l’istruzione o l’impiego.\noccupazione. Ciascuna delle sezioni deve includere un elenco puntato di\nlavori/diplomi. Evidenziate l’anno grassetto.Utilizzando la guida rapida di R Markdown, capire come fare:\nAggiungere una nota piè di pagina.\nAggiungere una regola orizzontale.\nAggiungere una citazione blocchi.\nUtilizzando la guida rapida di R Markdown, capire come fare:Aggiungere una nota piè di pagina.Aggiungere una regola orizzontale.Aggiungere una citazione blocchi.Copiare e incollare il contenuto di diamond-sizes.Rmd da\nhttps://github.com/hadley/r4ds/tree/master/rmarkdown un documento\nR un documento markdown locale. Verificate che sia possibile eseguirlo, quindi aggiungete del testo dopo il\npoligono di frequenza che descrive le sue caratteristiche più evidenti.Copiare e incollare il contenuto di diamond-sizes.Rmd da\nhttps://github.com/hadley/r4ds/tree/master/rmarkdown un documento\nR un documento markdown locale. Verificate che sia possibile eseguirlo, quindi aggiungete del testo dopo il\npoligono di frequenza che descrive le sue caratteristiche più evidenti.","code":""},{"path":"r-markdown.html","id":"pezzi-di-codice","chapter":"27 R Markdown","heading":"27.4 Pezzi di codice","text":"Per eseguire del codice ’interno di un documento R Markdown, è necessario inserire un chunk. Ci sono tre modi per farlo:La scorciatoia da tastiera Cmd/Ctrl + Alt + ILa scorciatoia da tastiera Cmd/Ctrl + Alt + IL’icona del pulsante “Inserisci” nella barra degli strumenti dell’editor.L’icona del pulsante “Inserisci” nella barra degli strumenti dell’editor.Digitando manualmente delimitatori di pezzi ```{r} e ```.Digitando manualmente delimitatori di pezzi ```{r} e ```.Ovviamente, vi consiglio di imparare la scorciatoia da tastiera. Vi farà risparmiare molto tempo nel lungo periodo!Potete continuare eseguire il codice utilizzando la scorciatoia da tastiera che ormai (spero!) conoscete e amate: Cmd/Ctrl + Invio. Tuttavia, chunk hanno una nuova scorciatoia da tastiera: Cmd/Ctrl + Shift + Invio, che esegue tutto il codice contenuto nel gruppo. Pensate un gruppo come una funzione. Un chunk dovrebbe essere relativamente autonomo e focalizzato su un singolo compito.Le sezioni seguenti descrivono l’intestazione del chunk, che consiste ```{r, seguito da un nome opzionale del chunk, seguito da opzioni separate da virgole, seguite da }. Segue il codice R e la fine del chunk è indicata da un ultimo ```.","code":""},{"path":"r-markdown.html","id":"nome-del-chunk","chapter":"27 R Markdown","heading":"27.4.1 Nome del chunk","text":"Ai chunk può essere dato un nome opzionale: ```{r -name}. Questo ha tre vantaggi:Si può navigare più facilmente verso specifici chunk usando il navigatore di codice discesa basso sinistra.\nnavigatore di codice basso sinistra nell’editor di script:\nSi può navigare più facilmente verso specifici chunk usando il navigatore di codice discesa basso sinistra.\nnavigatore di codice basso sinistra nell’editor di script:grafici prodotti dai chunks avranno nomi utili che li renderanno\npiù facili da usare altrove. Maggiori informazioni altre opzioni importanti.grafici prodotti dai chunks avranno nomi utili che li renderanno\npiù facili da usare altrove. Maggiori informazioni altre opzioni importanti.È possibile impostare reti di pezzi memorizzati nella cache per evitare di rieseguire costose\ncalcoli costosi ogni esecuzione. Per saperne di più, si veda più avanti.È possibile impostare reti di pezzi memorizzati nella cache per evitare di rieseguire costose\ncalcoli costosi ogni esecuzione. Per saperne di più, si veda più avanti.C’è un nome di chunk che implica un comportamento speciale: setup. Quando si è modalità notebook, il chunk chiamato setup viene eseguito automaticamente una volta, prima che venga eseguito qualsiasi altro codice.","code":""},{"path":"r-markdown.html","id":"opzioni-dei-chunk","chapter":"27 R Markdown","heading":"27.4.2 Opzioni dei chunk","text":"L’output dei chunk può essere personalizzato con le opzioni, argomenti forniti ’intestazione dei chunk. Knitr fornisce quasi 60 opzioni che possono essere utilizzate per personalizzare chunk di codice. questa sede tratteremo le opzioni più importanti, che verranno utilizzate di frequente. L’elenco completo è disponibile ’indirizzo http://yihui.name/knitr/options/.L’insieme più importante di opzioni controlla se il blocco di codice viene eseguito e quali risultati vengono inseriti nel report finito:eval = FALSE impedisce che il codice venga valutato. (E ovviamente se il codice\ncodice non viene eseguito, non verrà generato alcun risultato). Questo è utile per\nvisualizzare un esempio di codice, o per disabilitare un grande blocco di codice senza\ncommentare ogni riga.eval = FALSE impedisce che il codice venga valutato. (E ovviamente se il codice\ncodice non viene eseguito, non verrà generato alcun risultato). Questo è utile per\nvisualizzare un esempio di codice, o per disabilitare un grande blocco di codice senza\ncommentare ogni riga.include = FALSE esegue il codice, ma non mostra il codice o risultati nel documento finale.\nnel documento finale. Usare questa opzione per il codice di configurazione che non si vuole\ningombrare il rapporto.include = FALSE esegue il codice, ma non mostra il codice o risultati nel documento finale.\nnel documento finale. Usare questa opzione per il codice di configurazione che non si vuole\ningombrare il rapporto.echo = FALSE impedisce al codice, ma non ai risultati, di apparire nel file finale.\nfile finito. Usare questa opzione quando si scrivono rapporti destinati persone che non vogliono\nnon vogliono vedere il codice R sottostante.echo = FALSE impedisce al codice, ma non ai risultati, di apparire nel file finale.\nfile finito. Usare questa opzione quando si scrivono rapporti destinati persone che non vogliono\nnon vogliono vedere il codice R sottostante.messaggio = FALSE o avvertimento = FALSE impedisce che messaggi o gli avvertimenti\ndi apparire nel file finito.messaggio = FALSE o avvertimento = FALSE impedisce che messaggi o gli avvertimenti\ndi apparire nel file finito.risultati = 'hide' nasconde l’output stampato; fig.show = 'hide' nasconde \ntrame.risultati = 'hide' nasconde l’output stampato; fig.show = 'hide' nasconde \ntrame.error = TRUE fa sì che il rendering continui anche se il codice restituisce un errore.\nQuesto è raramente qualcosa che si vuole includere nella versione finale del report.\ndel report, ma può essere molto utile se si ha la necessità di eseguire il debug di ciò che\ncosa sta succedendo ’interno di .Rmd. È anche utile se si sta insegnando R\ne si vuole includere deliberatamente un errore. L’impostazione predefinita, errore = FALSO, fa sì che\nfa sì che il knitting fallisca se c’è un singolo errore nel documento.error = TRUE fa sì che il rendering continui anche se il codice restituisce un errore.\nQuesto è raramente qualcosa che si vuole includere nella versione finale del report.\ndel report, ma può essere molto utile se si ha la necessità di eseguire il debug di ciò che\ncosa sta succedendo ’interno di .Rmd. È anche utile se si sta insegnando R\ne si vuole includere deliberatamente un errore. L’impostazione predefinita, errore = FALSO, fa sì che\nfa sì che il knitting fallisca se c’è un singolo errore nel documento.La tabella seguente riassume tipi di output che ciascuna opzione sopprime:","code":""},{"path":"r-markdown.html","id":"tabelle","chapter":"27 R Markdown","heading":"27.4.3 Tabelle","text":"Per impostazione predefinita, R Markdown stampa frame e matrici di dati come li vedreste nella console:Se si preferisce che dati siano visualizzati con una formattazione aggiuntiva, si può usare la funzione knitr::kable. Il codice seguente genera la tabella 27.1.Table 27.1: knitr kable.Si legga la documentazione di ?knitr::kable per vedere gli altri modi cui si può personalizzare la tabella. Per una personalizzazione ancora più profonda, considerate pacchetti xtable, stargazer, pander, tables e ascii. Ognuno di essi fornisce una serie di strumenti per restituire tabelle formattate da codice R.Esiste anche una ricca serie di opzioni per controllare il modo cui le figure vengono incorporate. Queste opzioni sono illustrate [salvare le trame].","code":"\nmtcars[1:5, ]\n#>                    mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n#> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n#> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n#> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nknitr::kable(\n  mtcars[1:5, ], \n  caption = \"A knitr kable.\"\n)"},{"path":"r-markdown.html","id":"caching","chapter":"27 R Markdown","heading":"27.4.4 Caching","text":"Normalmente, ogni maglia di un documento parte da una base completamente pulita. Questo è ottimo per la riproducibilità, perché assicura che ogni calcolo importante sia stato catturato nel codice. Tuttavia, può essere doloroso se si hanno alcuni calcoli che richiedono molto tempo. La soluzione è cache = TRUE. Se impostata, questa opzione salva l’output del chunk un file su disco con un nome speciale. Nelle esecuzioni successive, knitr controllerà se il codice è cambiato e, caso contrario, riutilizzerà risultati cache.Il sistema di cache deve essere usato con attenzione, perché per impostazione predefinita si basa solo sul codice, non sulle sue dipendenze. Per esempio, qui il chunk processed_data dipende dal chunk raw_data:Mettere cache il chunk processed_data significa che verrà rieseguito se la pipeline di dplyr viene modificata, ma non verrà rieseguito se la chiamata read_csv() cambia. È possibile evitare questo problema con l’opzione chunk dependson:dependson deve contenere un vettore di caratteri di ogni chunk da cui il chunk cache dipende. Knitr aggiornerà risultati del chunk cache ogni volta che rileverà che una delle sue dipendenze è cambiata.Si noti che chunk non verranno aggiornati se a_very_large_file.csv cambia, perché la cache di Knitr tiene traccia solo dei cambiamenti ’interno del file .Rmd. Se si vuole tenere traccia anche delle modifiche quel file, si può usare l’opzione cache.extra. Si tratta di un’espressione R arbitraria che invalida la cache ogni volta che viene modificata. Una buona funzione da usare è file.info(): restituisce una serie di informazioni sul file, compresa l’ultima modifica. Quindi si può scrivere:Quando le strategie di cache diventano progressivamente più complicate, è una buona idea svuotare regolarmente tutte le cache con knitr::clean_cache().Ho usato il consiglio di David Robinson per dare un nome questi chunk: ogni chunk ha il nome dell’oggetto primario che crea. Questo rende più facile la comprensione della specifica dependson.","code":"```{r raw_data}\nrawdata <- readr::read_csv(\"a_very_large_file.csv\")\n```\n\n```{r processed_data, cache = TRUE}\nprocessed_data <- rawdata %>% \n  filter(!is.na(import_var)) %>% \n  mutate(new_variable = complicated_transformation(x, y, z))\n``````{r processed_data, cache = TRUE, dependson = \"raw_data\"}\nprocessed_data <- rawdata %>% \n  filter(!is.na(import_var)) %>% \n  mutate(new_variable = complicated_transformation(x, y, z))\n``````{r raw_data, cache.extra = file.info(\"a_very_large_file.csv\")}\nrawdata <- readr::read_csv(\"a_very_large_file.csv\")\n```"},{"path":"r-markdown.html","id":"opzioni-globali","chapter":"27 R Markdown","heading":"27.4.5 Opzioni globali","text":"Lavorando di più con knitr, si scoprirà che alcune delle opzioni predefinite dei chunk non sono adatte alle proprie esigenze e si vorrà cambiarle. È possibile farlo chiamando knitr::opts_chunk$set() un pezzo di codice. Per esempio, quando scrivo libri e tutorial, imposto:Questo utilizza la formattazione dei commenti che preferisco e garantisce che il codice e l’output siano strettamente legati. D’altra parte, se si stesse preparando una relazione, si potrebbe impostare:Questo nasconderà il codice per impostazione predefinita, mostrando solo le parti che si sceglie deliberatamente di mostrare (con echo = TRUE). Si potrebbe pensare di impostare message = FALSE e warning = FALSE, ma questo renderebbe più difficile il debug dei problemi, perché non si vedrebbe alcun messaggio nel documento finale.","code":"\nknitr::opts_chunk$set(\n  comment = \"#>\",\n  collapse = TRUE\n)\nknitr::opts_chunk$set(\n  echo = FALSE\n)"},{"path":"r-markdown.html","id":"codice-in-linea","chapter":"27 R Markdown","heading":"27.4.6 Codice in linea","text":"Esiste un altro modo per incorporare codice R un documento R Markdown: direttamente nel testo, con: `r `. Questo può essere molto utile se si citano le proprietà dei dati nel testo. Per esempio, nel documento di esempio che ho usato ’inizio del capitolo, avevo:Abbiamo dati sui diamanti di `r nrow(diamonds)`.\nSolo `r nrow(diamonds) - nrow(smaller)` sono più grandi di\ndi 2,5 carati. La distribuzione dei rimanenti è mostrata di seguito:Quando il report viene lavorato maglia, risultati di questi calcoli vengono inseriti nel testo:Abbiamo dati su 53940 diamanti. Solo 126 sono più grandi di\n2,5 carati. La distribuzione dei rimanenti è mostrata di seguito:Quando si inseriscono numeri nel testo, format() è un amico. Permette di impostare il numero di cifre', modo da non stampare con una precisione ridicola, e unbig.mark’ per rendere numeri più facili da leggere. Spesso le combino una funzione di aiuto:","code":"\ncomma <- function(x) format(x, digits = 2, big.mark = \",\")\ncomma(3452345)\n#> [1] \"3,452,345\"\ncomma(.12358124331)\n#> [1] \"0.12\""},{"path":"r-markdown.html","id":"esercizi-73","chapter":"27 R Markdown","heading":"27.4.7 Esercizi","text":"Aggiungere una sezione che esplori come le dimensioni dei diamanti variano base al taglio, al colore e alla purezza,\ne chiarezza. Si supponga di scrivere una relazione per qualcuno che non conosce R.\nR, e invece di impostare echo = FALSE su ogni pezzo, impostate un’opzione globale.\nglobale.Aggiungere una sezione che esplori come le dimensioni dei diamanti variano base al taglio, al colore e alla purezza,\ne chiarezza. Si supponga di scrivere una relazione per qualcuno che non conosce R.\nR, e invece di impostare echo = FALSE su ogni pezzo, impostate un’opzione globale.\nglobale.Scaricare diamond-sizes.Rmd da\nhttps://github.com/hadley/r4ds/tree/master/rmarkdown. Aggiungete una sezione\nche descriva 20 diamanti più grandi, inclusa una tabella che mostri loro\ngli attributi più importanti.Scaricare diamond-sizes.Rmd da\nhttps://github.com/hadley/r4ds/tree/master/rmarkdown. Aggiungete una sezione\nche descriva 20 diamanti più grandi, inclusa una tabella che mostri loro\ngli attributi più importanti.Modificare diamonds-sizes.Rmd per utilizzare comma() per produrre un output ben\nformattato. Includere anche la percentuale di diamanti\npiù grandi di 2,5 carati.Modificare diamonds-sizes.Rmd per utilizzare comma() per produrre un output ben\nformattato. Includere anche la percentuale di diamanti\npiù grandi di 2,5 carati.Impostare una rete di pezzi dove d dipende da c e b, e\nsia b che c dipendono da . Fate modo che ogni chunk stampi lubridate::now(),\nimpostare cache = TRUE, quindi verificare la comprensione della cache.Impostare una rete di pezzi dove d dipende da c e b, e\nsia b che c dipendono da . Fate modo che ogni chunk stampi lubridate::now(),\nimpostare cache = TRUE, quindi verificare la comprensione della cache.","code":""},{"path":"r-markdown.html","id":"risoluzione-dei-problemi","chapter":"27 R Markdown","heading":"27.5 Risoluzione dei problemi","text":"La risoluzione dei problemi dei documenti R Markdown può essere impegnativa, perché non ci si trova più un ambiente R interattivo, e sarà necessario imparare alcuni nuovi trucchi. La prima cosa da fare è ricreare il problema una sessione interattiva. Riavviate R, quindi “Esegui tutti pezzi” (dal menu Codice, sotto la voce Esegui regione) o con la scorciatoia da tastiera Ctrl + Alt + R. Se siete fortunati, questo ricreerà il problema e potrete capire cosa sta succedendo modo interattivo.Se questo non aiuta, deve esserci qualcosa di diverso tra l’ambiente interattivo e l’ambiente markdown di R. È necessario sistemare l’ambiente interattivo e l’ambiente markdown. È necessario esplorare sistematicamente le opzioni. La differenza più comune è la directory di lavoro: la directory di lavoro di un markdown R è la directory cui risiede. Verificate che la directory di lavoro sia quella che vi aspettate includendo getwd() un chunk.Successivamente, si deve fare un brainstorming di tutte le cose che potrebbero causare il bug. È necessario verificare sistematicamente che siano gli stessi nella sessione R e nella sessione R markdown. Il modo più semplice per farlo è impostare error = TRUE sul pezzo che causa il problema, quindi usare print() e str() per verificare che le impostazioni siano quelle previste.","code":""},{"path":"r-markdown.html","id":"intestazione-yaml","chapter":"27 R Markdown","heading":"27.6 Intestazione YAML","text":"È possibile controllare molte altre impostazioni dell’intero documento modificando parametri dell’intestazione YAML. Ci si potrebbe chiedere cosa significhi YAML: è “un altro linguaggio di markup”, progettato per rappresentare dati gerarchici modo facile da leggere e scrivere per gli esseri umani. R Markdown lo usa per controllare molti dettagli dell’output. Qui ne discuteremo due: parametri del documento e le bibliografie.","code":""},{"path":"r-markdown.html","id":"parametri","chapter":"27 R Markdown","heading":"27.6.1 Parametri","text":"documenti R Markdown possono includere uno o più parametri cui valori possono essere impostati durante il rendering del report. parametri sono utili quando si vuole riproporre lo stesso report con valori diversi per vari input chiave. Ad esempio, si possono produrre rapporti di vendita per filiale, risultati di esami per studente o riepiloghi demografici per paese. Per dichiarare uno o più parametri, utilizzare il campo params.Questo esempio utilizza il parametro my_class per determinare la classe di auto da visualizzare:Come si può vedere, parametri sono disponibili ’interno dei pezzi di codice come un elenco di sola lettura chiamato params.È possibile scrivere vettori atomici direttamente nell’intestazione YAML. È anche possibile eseguire espressioni R arbitrarie, anteponendo al valore del parametro !r. Questo è un buon modo per specificare parametri di data/ora.RStudio, è possibile fare clic sull’opzione “Knit Parameters” nel menu discesa Knit per impostare parametri, eseguire il rendering e visualizzare l’anteprima del report un unico passaggio di facile utilizzo. È possibile personalizzare la finestra di dialogo impostando altre opzioni nell’intestazione. Per ulteriori dettagli, vedere http://rmarkdown.rstudio.com/developer_parameterized_reports.html#parameter_user_interfaces.alternativa, se è necessario produrre molti rapporti parametrati, si può chiamare rmarkdown::render() con un elenco di parametri:È particolarmente potente combinazione con purrr:pwalk(). L’esempio seguente crea un report per ogni valore di classe trovato mpg. Per prima cosa si crea un frame di dati con una riga per ogni classe, indicando il nome del file del report e parametri:Quindi si abbinano nomi delle colonne ai nomi degli argomenti di render() e si usa il metodo parallel di Purrr per chiamare render() una volta per ogni riga:","code":"---\noutput: html_document\nparams:\n  my_class: \"suv\"\n---\n\n```{r setup, include = FALSE}\nlibrary(ggplot2)\nlibrary(dplyr)\n\nclass <- mpg %>% filter(class == params$my_class)\n```\n\n# Fuel economy for `r params$my_class`s\n\n```{r, message = FALSE}\nggplot(class, aes(displ, hwy)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\n```params:\n  start: !r lubridate::ymd(\"2015-01-01\")\n  snapshot: !r lubridate::ymd_hms(\"2015-01-01 12:30:00\")\nrmarkdown::render(\"fuel-economy.Rmd\", params = list(my_class = \"suv\"))\nreports <- tibble(\n  class = unique(mpg$class),\n  filename = stringr::str_c(\"fuel-economy-\", class, \".html\"),\n  params = purrr::map(class, ~ list(my_class = .))\n)\nreports\n#> # A tibble: 7 × 3\n#>   class   filename                  params          \n#>   <chr>   <chr>                     <list>          \n#> 1 compact fuel-economy-compact.html <named list [1]>\n#> 2 midsize fuel-economy-midsize.html <named list [1]>\n#> 3 suv     fuel-economy-suv.html     <named list [1]>\n#> 4 2seater fuel-economy-2seater.html <named list [1]>\n#> 5 minivan fuel-economy-minivan.html <named list [1]>\n#> 6 pickup  fuel-economy-pickup.html  <named list [1]>\n#> # … with 1 more row\nreports %>% \n  select(output_file = filename, params) %>% \n  purrr::pwalk(rmarkdown::render, input = \"fuel-economy.Rmd\")"},{"path":"r-markdown.html","id":"bibliografie-e-citazioni","chapter":"27 R Markdown","heading":"27.6.2 Bibliografie e citazioni","text":"Pandoc può generare automaticamente citazioni e una bibliografia diversi stili. Per utilizzare questa funzione, specificare un file di bibliografia utilizzando il campo `bibliografia’ nell’intestazione del file. Il campo deve contenere un percorso dalla directory che contiene il file .Rmd al file che contiene la bibliografia:È possibile utilizzare molti formati di bibliografia comuni, tra cui BibLaTeX, BibTeX, endnote, medline.Per creare una citazione ’interno del file .Rmd, utilizzare una chiave composta da ‘@’ + l’identificatore della citazione dal file di bibliografia. Quindi inserire la citazione tra parentesi quadre. Ecco alcuni esempi:Quando R Markdown esegue il rendering del file, costruisce e aggiunge una bibliografia alla fine del documento. La bibliografia conterrà tutti riferimenti citati nel file di bibliografia, ma non conterrà un titolo di sezione. Di conseguenza, è prassi comune terminare il file con un’intestazione di sezione per la bibliografia, come # Riferimenti o # Bibliografia.È possibile modificare lo stile delle citazioni e della bibliografia facendo riferimento un file CSL (citation style language) nel campo csl:Come per il campo bibliografia, il file csl deve contenere il percorso del file. Qui assumo che il file csl si trovi nella stessa directory del file .Rmd. Un buon posto dove trovare file di stile CSL per gli stili di bibliografia più comuni è http://github.com/citation-style-language/styles.","code":"bibliografia: rmarkdown.bibSeparare più citazioni con un `;`: Blah blah [@smith04; @doe99].\n\nÈ possibile aggiungere commenti arbitrari all'interno delle parentesi quadre: \nBlah blah [cfr. @doe99, pp. 33-35; anche @smith04, cap. 1].\n\nRimuovere le parentesi quadre per creare una citazione nel testo: @smith04 \ndice bla, oppure @smith04 [p. 33] dice bla.\n\nAggiungere un `-` prima della citazione per sopprimere il nome dell'autore: \nSmith dice bla [-@smith04].bibliografia: rmarkdown.bib\nCSL: apa.csl"},{"path":"r-markdown.html","id":"per-saperne-di-più-2","chapter":"27 R Markdown","heading":"27.7 Per saperne di più","text":"R Markdown è ancora relativamente giovane e sta crescendo rapidamente. Il posto migliore per rimanere aggiornati sulle novità è il sito ufficiale di R Markdown: http://rmarkdown.rstudio.com.Ci sono due argomenti importanti che non sono stati trattati qui: la collaborazione e dettagli per comunicare accuratamente le proprie idee ad altri esseri umani. La collaborazione è una parte vitale della moderna scienza dei dati e potete semplificarvi la vita utilizzando strumenti di controllo delle versioni, come Git e GitHub. Vi consigliamo due risorse gratuite che vi insegneranno conoscere Git:“Happy Git R”: un’introduzione semplice Git e GitHub per gli utenti di R, cura di Jenny Bryan.\nutenti di R, di Jenny Bryan. Il libro è disponibile gratuitamente online:\nhttp://happygitwithr.com“Happy Git R”: un’introduzione semplice Git e GitHub per gli utenti di R, cura di Jenny Bryan.\nutenti di R, di Jenny Bryan. Il libro è disponibile gratuitamente online:\nhttp://happygitwithr.comIl capitolo “Git e GitHub” di R Packages, di Hadley. È anche possibile\nleggerlo gratuitamente online: http://r-pkgs..co.nz/git.html.Il capitolo “Git e GitHub” di R Packages, di Hadley. È anche possibile\nleggerlo gratuitamente online: http://r-pkgs..co.nz/git.html.Non ho nemmeno parlato di ciò che dovreste scrivere per comunicare chiaramente risultati della vostra analisi. Per migliorare la vostra scrittura, vi consiglio di leggere [Style: Lessons Clarity Grace] (https://amzn.com/0134080416) di Joseph M. Williams e Joseph Bizup, oppure [Sense Structure: Writing Reader’s Perspective] (https://amzn.com/0205296327) di George Gopen. Entrambi libri vi aiuteranno capire la struttura delle frasi e dei paragrafi e vi daranno gli strumenti per rendere più chiara la vostra scrittura. (Questi libri sono piuttosto costosi se acquistati nuovi, ma sono utilizzati da molti corsi di inglese, quindi si trovano molte copie di seconda mano buon mercato). George Gopen ha anche una serie di brevi articoli sulla scrittura ’indirizzo https://www.georgegopen.com/-litigation-articles.html. Sono rivolti agli avvocati, ma quasi tutto si applica anche agli scienziati dei dati.","code":""},{"path":"grafici-per-la-comunicazione.html","id":"grafici-per-la-comunicazione","chapter":"28 Grafici per la comunicazione","heading":"28 Grafici per la comunicazione","text":"","code":""},{"path":"grafici-per-la-comunicazione.html","id":"introduzione-19","chapter":"28 Grafici per la comunicazione","heading":"28.1 Introduzione","text":"analisi esplorativa, avete imparato ad usare grafici come strumenti di esplorazione. Quando fate dei grafici esplorativi, sapete - ancor prima di guardare - quali variabili il grafico visualizzerà. Avete fatto ogni grafico per uno scopo, potete guardarlo velocemente e poi passare al grafico successivo. Nel corso della maggior parte delle analisi, produrrete decine o centinaia di grafici, la maggior parte dei quali viene immediatamente gettata via.Ora che avete capito vostri dati, dovete comunicare la vostra comprensione agli altri. Il vostro pubblico probabilmente non condividerà le vostre conoscenze di base e non sarà profondamente investito dai dati. Per aiutare gli altri costruire rapidamente un buon modello mentale dei dati, dovrete investire notevoli sforzi per rendere vostri grafici il più possibile autoesplicativi. questo capitolo, imparerete alcuni degli strumenti che ggplot2 fornisce per farlo.Questo capitolo si concentra sugli strumenti necessari per creare buoni grafici. Presumo che sappiate cosa volete e che abbiate solo bisogno di sapere come farlo. Per questo motivo, consiglio vivamente di abbinare questo capitolo ad un buon libro di visualizzazione generale. Mi piace particolarmente Truthful Art, di Albert Cairo. Non insegna la meccanica della creazione di visualizzazioni, ma si concentra invece su ciò che è necessario pensare per creare una grafica efficace.","code":""},{"path":"grafici-per-la-comunicazione.html","id":"prerequisiti-19","chapter":"28 Grafici per la comunicazione","heading":"28.1.1 Prerequisiti","text":"questo capitolo, ci concentreremo ancora una volta su ggplot2. Useremo anche un po’ di dplyr per la manipolazione dei dati, e alcuni pacchetti di estensione di ggplot2, inclusi ggrepel e viridis. Piuttosto che caricare queste estensioni qui, faremo riferimento alle loro funzioni esplicitamente, usando la notazione ::. Questo aiuterà rendere chiaro quali funzioni sono integrate ggplot2 e quali provengono da altri pacchetti. Non dimenticare che dovrai installare quei pacchetti con install.packages() se non li hai già.","code":"\nlibrary(tidyverse)"},{"path":"grafici-per-la-comunicazione.html","id":"etichetta","chapter":"28 Grafici per la comunicazione","heading":"28.2 Etichetta","text":"Il punto di partenza più semplice per trasformare un grafico esplorativo un grafico espositivo è con delle buone etichette. Si aggiungono etichette con la funzione labs(). Questo esempio aggiunge un titolo al grafico:Lo scopo del titolo di un grafico è quello di riassumere il risultato principale. Evitare titoli che descrivono solo ciò che il grafico è, ad esempio “Un grafico dispersione della cilindrata del motore rispetto al risparmio di carburante”.Se hai bisogno di aggiungere altro testo, ci sono altre due utili etichette che puoi usare ggplot2 2.2.0 e superiori (che dovrebbero essere disponibili nel momento cui leggerai questo libro):subtitle aggiunge ulteriori dettagli un carattere più piccolo sotto il titolo.subtitle aggiunge ulteriori dettagli un carattere più piccolo sotto il titolo.caption aggiunge del testo basso destra del grafico, spesso usato per descrivere\nla fonte dei dati.caption aggiunge del testo basso destra del grafico, spesso usato per descrivere\nla fonte dei dati.Potete anche usare labs() per sostituire titoli degli assi e delle legende. Di solito è una buona idea sostituire nomi brevi delle variabili con descrizioni più dettagliate e includere le unità.È possibile usare equazioni matematiche invece di stringhe di testo. Basta sostituire \"\" con quote() e leggere le opzioni disponibili ?plotmath:","code":"\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(title = \"Fuel efficiency generally decreases with engine size\")\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  geom_smooth(se = FALSE) +\n  labs(\n    x = \"Engine displacement (L)\",\n    y = \"Highway fuel economy (mpg)\",\n    colour = \"Car type\"\n  )\ndf <- tibble(\n  x = runif(10),\n  y = runif(10)\n)\nggplot(df, aes(x, y)) +\n  geom_point() +\n  labs(\n    x = quote(sum(x[i] ^ 2, i == 1, n)),\n    y = quote(alpha + beta + frac(delta, theta))\n  )"},{"path":"grafici-per-la-comunicazione.html","id":"esercizi-74","chapter":"28 Grafici per la comunicazione","heading":"28.2.1 Esercizi","text":"Creare un grafico sui dati relativi al risparmio di carburante con un title personalizzato,\ntitle,subtitle, caption, x, y, e colore personalizzati.Creare un grafico sui dati relativi al risparmio di carburante con un title personalizzato,\ntitle,subtitle, caption, x, y, e colore personalizzati.Il risultato di geom_smooth() è qualche modo fuorviante perché il valore di hwy per \nper motori di grandi dimensioni è sbilanciato verso l’alto causa dell’inclusione di auto sportive leggere con\nauto sportive leggere con grandi motori. Utilizzare gli strumenti di modellazione per adattare e visualizzare\nun modello migliore.Il risultato di geom_smooth() è qualche modo fuorviante perché il valore di hwy per \nper motori di grandi dimensioni è sbilanciato verso l’alto causa dell’inclusione di auto sportive leggere con\nauto sportive leggere con grandi motori. Utilizzare gli strumenti di modellazione per adattare e visualizzare\nun modello migliore.Prendete un grafico esplorativo che avete creato nell’ultimo mese e aggiungete titoli informativi per facilitare la comprensione.\ntitoli informativi per renderlo più comprensibile agli altri.Prendete un grafico esplorativo che avete creato nell’ultimo mese e aggiungete titoli informativi per facilitare la comprensione.\ntitoli informativi per renderlo più comprensibile agli altri.","code":""},{"path":"grafici-per-la-comunicazione.html","id":"annotazioni","chapter":"28 Grafici per la comunicazione","heading":"28.3 Annotazioni","text":"Oltre etichettare principali componenti del grafico, è spesso utile etichettare singole osservazioni o gruppi di osservazioni. Il primo strumento disposizione è geom_text(). geom_text() è simile geom_point(), ma ha un’estetica aggiuntiva: label. Consente di aggiungere etichette testuali alle trame.Ci sono due possibili fonti di etichette. primo luogo, si può avere un tibble che fornisce le etichette. Il grafico qui sotto non è molto utile, ma illustra un approccio utile: estrarre l’auto più efficiente di ogni classe con dplyr e poi etichettarla sul grafico:Questo è difficile da leggere perché le etichette si sovrappongono tra loro e con punti. Possiamo migliorare un po’ le cose passando geom_label() che disegna un rettangolo dietro il testo. Usiamo anche il parametro nudge_y per spostare le etichette leggermente sopra punti corrispondenti:Questo aiuta un po’, ma se guardate attentamente nell’angolo alto sinistra, noterete che ci sono due etichette praticamente una sopra l’altra. Questo accade perché il chilometraggio autostradale e la cilindrata per le migliori auto delle categorie compatte e subcompatte sono esattamente gli stessi. Non c’è modo di sistemarle applicando la stessa trasformazione per ogni etichetta. Invece, possiamo usare il pacchetto ggrepel di Kamil Slowikowski. Questo utile pacchetto regolerà automaticamente le etichette modo che non si sovrappongano:Notate un’altra tecnica utile usata qui: Ho aggiunto un secondo strato di punti grandi e vuoti per evidenziare punti che ho etichettato.volte si può usare la stessa idea per sostituire la legenda con etichette poste direttamente sul grafico. Non è meraviglioso per questa trama, ma non è troppo male (theme(legend.position = \"none\") disattiva la leggenda — ne parleremo più avanti).alternativa, potreste voler solo aggiungere una singola etichetta al grafico, ma avrete comunque bisogno di creare un data frame. Spesso si vuole l’etichetta nell’angolo del grafico, quindi è conveniente creare un nuovo data frame usando summarise() per calcolare valori massimi di x e y.Se vuoi posizionare il testo esattamente sui bordi del grafico, puoi usare +Inf e -Inf. Dato che non stiamo più calcolando le posizioni da mpg, possiamo usare tibble() per creare il data frame:questi esempi, ho suddiviso manualmente l’etichetta righe usando \"\\n\". Un altro approccio è quello di usare stringr::str_wrap() per aggiungere automaticamente le interruzioni di riga, dato il numero di caratteri desiderato per riga:Si noti l’uso di hjust e vjust per controllare l’allineamento dell’etichetta. La figura 28.1 mostra tutte le nove combinazioni possibili.\nFigure 28.1: nine combinations hjust vjust.\nRicorda, oltre geom_text(), hai molti altri geom ggplot2 disponibili per aiutare ad annotare la tua trama. Alcune idee:Usa geom_hline() e geom_vline() per aggiungere linee di riferimento. Spesso le rendo\nspesse (size = 2) e bianche (colour = white), e le disegno\nsotto il livello primario dei dati. Questo le rende facili da vedere, senza\ndistogliere l’attenzione dai dati.Usa geom_hline() e geom_vline() per aggiungere linee di riferimento. Spesso le rendo\nspesse (size = 2) e bianche (colour = white), e le disegno\nsotto il livello primario dei dati. Questo le rende facili da vedere, senza\ndistogliere l’attenzione dai dati.Usa geom_rect() per disegnare un rettangolo intorno ai punti di interesse. \nconfini del rettangolo sono definiti dalle estetiche xmin, xmax,\nymin, ymax.Usa geom_rect() per disegnare un rettangolo intorno ai punti di interesse. \nconfini del rettangolo sono definiti dalle estetiche xmin, xmax,\nymin, ymax.Usa geom_segment() con l’argomento arrow per attirare l’attenzione\nsu un punto con una freccia. Usa gli estratti x e y per definire la\nposizione iniziale, e xend e yend per definire la posizione finale.Usa geom_segment() con l’argomento arrow per attirare l’attenzione\nsu un punto con una freccia. Usa gli estratti x e y per definire la\nposizione iniziale, e xend e yend per definire la posizione finale.L’unico limite è la tua immaginazione (e la tua pazienza nel posizionare le annotazioni modo che siano esteticamente piacevoli)!","code":"\nbest_in_class <- mpg %>%\n  group_by(class) %>%\n  filter(row_number(desc(hwy)) == 1)\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  geom_text(aes(label = model), data = best_in_class)\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  geom_label(aes(label = model), data = best_in_class, nudge_y = 2, alpha = 0.5)\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  geom_point(size = 3, shape = 1, data = best_in_class) +\n  ggrepel::geom_label_repel(aes(label = model), data = best_in_class)\nclass_avg <- mpg %>%\n  group_by(class) %>%\n  summarise(\n    displ = median(displ),\n    hwy = median(hwy)\n  )\n\nggplot(mpg, aes(displ, hwy, colour = class)) +\n  ggrepel::geom_label_repel(aes(label = class),\n    data = class_avg,\n    size = 6,\n    label.size = 0,\n    segment.color = NA\n  ) +\n  geom_point() +\n  theme(legend.position = \"none\")\nlabel <- mpg %>%\n  summarise(\n    displ = max(displ),\n    hwy = max(hwy),\n    label = \"Increasing engine size is \\nrelated to decreasing fuel economy.\"\n  )\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_text(aes(label = label), data = label, vjust = \"top\", hjust = \"right\")\nlabel <- tibble(\n  displ = Inf,\n  hwy = Inf,\n  label = \"L'aumento delle dimensioni del motore è \\ncorrelato alla diminuzione del risparmio di carburante.\"\n)\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  geom_text(aes(label = label), data = label, vjust = \"top\", hjust = \"right\")\n\"L'aumento delle dimensioni del motore è legato alla diminuzione del risparmio di carburante.\" %>%\n  stringr::str_wrap(width = 40) %>%\n  writeLines()\n#> L'aumento delle dimensioni del motore è\n#> legato alla diminuzione del risparmio di\n#> carburante."},{"path":"grafici-per-la-comunicazione.html","id":"esercizi-75","chapter":"28 Grafici per la comunicazione","heading":"28.3.1 Esercizi","text":"Usate geom_text() con posizioni infinite per posizionare il testo ai\nquattro angoli della trama.Usate geom_text() con posizioni infinite per posizionare il testo ai\nquattro angoli della trama.Leggete la documentazione di annotate(). Come potete usarlo per aggiungere un testo\nun’etichetta di testo ad un grafico senza dover creare una tibla?Leggete la documentazione di annotate(). Come potete usarlo per aggiungere un testo\nun’etichetta di testo ad un grafico senza dover creare una tibla?Come interagiscono le etichette con geom_text() con il faceting? Come potete\naggiungere un’etichetta ad una singola sfaccettatura? Come si può mettere un’etichetta diversa ogni sfaccettatura?\n(Suggerimento: pensate ai dati sottostanti).Come interagiscono le etichette con geom_text() con il faceting? Come potete\naggiungere un’etichetta ad una singola sfaccettatura? Come si può mettere un’etichetta diversa ogni sfaccettatura?\n(Suggerimento: pensate ai dati sottostanti).Quali argomenti di geom_label() controllano l’aspetto dello sfondo\nbox?Quali argomenti di geom_label() controllano l’aspetto dello sfondo\nbox?Quali sono quattro argomenti di arrow()? Come funzionano? Create una serie\ndi grafici che dimostrino le opzioni più importanti.Quali sono quattro argomenti di arrow()? Come funzionano? Create una serie\ndi grafici che dimostrino le opzioni più importanti.","code":""},{"path":"grafici-per-la-comunicazione.html","id":"scale","chapter":"28 Grafici per la comunicazione","heading":"28.4 Scale","text":"Il terzo modo cui puoi rendere il tuo grafico migliore per la comunicazione è regolare le scale. Le scale controllano la mappatura dai valori dei dati cose che si possono percepire. Normalmente, ggplot2 aggiunge automaticamente le scale per voi. Per esempio, quando digitate:ggplot2 aggiunge automaticamente delle scale predefinite dietro le quinte:Si noti lo schema di denominazione delle scale: scala_ seguita dal nome dell’estetica, poi _, quindi il nome della scala. Le scale predefinite sono denominate base al tipo di variabile cui si allineano: continua, discreta, datetime o data. Esistono molte scale non predefinite, che verranno descritte di seguito.Le scale predefinite sono state scelte con cura per svolgere un buon lavoro per un’ampia gamma di input. Ciononostante, si potrebbe voler sovrascrivere valori predefiniti per due motivi:Si possono modificare alcuni parametri della scala predefinita.\nquesto modo è possibile modificare, ad esempio, le interruzioni degli assi o le etichette dei tasti della legenda.\netichette dei tasti sulla legenda.Si possono modificare alcuni parametri della scala predefinita.\nquesto modo è possibile modificare, ad esempio, le interruzioni degli assi o le etichette dei tasti della legenda.\netichette dei tasti sulla legenda.Si potrebbe voler sostituire completamente la scala e utilizzare un algoritmo completamente diverso.\nalgoritmo diverso. Spesso si può fare meglio di quello predefinito perché si conoscono meglio dati.\nperché si conoscono meglio dati.Si potrebbe voler sostituire completamente la scala e utilizzare un algoritmo completamente diverso.\nalgoritmo diverso. Spesso si può fare meglio di quello predefinito perché si conoscono meglio dati.\nperché si conoscono meglio dati.","code":"\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class))\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  scale_x_continuous() +\n  scale_y_continuous() +\n  scale_colour_discrete()"},{"path":"grafici-per-la-comunicazione.html","id":"divisione-degli-assi-e-chiavi-della-legenda","chapter":"28 Grafici per la comunicazione","heading":"28.4.1 Divisione degli assi e chiavi della legenda","text":"Ci sono due argomenti principali che influenzano l’aspetto dei tick sugli assi e delle chiavi sulla legenda: breaks e labels. Le interruzioni controllano la posizione delle zecche o valori associati alle chiavi. Etichette controlla l’etichetta di testo associata ciascun segno di spunta/tasto. L’uso più comune di breaks è quello di sovrascrivere la scelta predefinita:Si può usare labels allo stesso modo (un vettore di caratteri della stessa lunghezza di breaks), ma si può anche impostare NULL per sopprimere del tutto le etichette. Questo è utile per le mappe o per la pubblicazione di grafici cui non è possibile condividere numeri assoluti.È inoltre possibile utilizzare breaks e labels per controllare l’aspetto delle legende. Collettivamente gli assi e le legende sono chiamati guide. Gli assi sono usati per l’estetica di x e y; le legende sono usate per tutto il resto.Un altro uso delle `brecce’ è quando si hanno relativamente pochi punti di dati e si vuole evidenziare esattamente il punto cui si verificano le osservazioni. Ad esempio, prendiamo questo grafico che mostra quando ogni presidente degli Stati Uniti ha iniziato e terminato il proprio mandato.Si noti che la specifica delle interruzioni e delle etichette per le scale date e datetime è leggermente diversa:date_labels accetta una specifica di formato, nella stessa forma di\nparse_datetime().date_labels accetta una specifica di formato, nella stessa forma di\nparse_datetime().date_breaks (non mostrato qui), accetta una stringa come “2 giorni” o “1 mese”.date_breaks (non mostrato qui), accetta una stringa come “2 giorni” o “1 mese”.","code":"\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  scale_y_continuous(breaks = seq(15, 40, by = 5))\nggplot(mpg, aes(displ, hwy)) +\n  geom_point() +\n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(labels = NULL)\npresidential %>%\n  mutate(id = 33 + row_number()) %>%\n  ggplot(aes(start, id)) +\n    geom_point() +\n    geom_segment(aes(xend = end, yend = id)) +\n    scale_x_date(NULL, breaks = presidential$start, date_labels = \"'%y\")"},{"path":"grafici-per-la-comunicazione.html","id":"disposizione-della-legenda","chapter":"28 Grafici per la comunicazione","heading":"28.4.2 Disposizione della legenda","text":"Il più delle volte si useranno breaks e labels per modificare gli assi. Sebbene entrambi funzionino anche per le legende, ci sono alcune altre tecniche che è più probabile utilizzare.Per controllare la posizione complessiva della legenda, è necessario utilizzare l’impostazione tema(). Torneremo sui temi alla fine del capitolo, ma breve essi controllano le parti non legate ai dati della trama. L’impostazione del tema legend.position controlla la posizione della legenda:Puoi anche usare legend.position = \"none\" per sopprimere del tutto la visualizzazione della legenda.Per controllare la visualizzazione delle singole legende, usa guide() insieme guide_legend() o guide_colourbar(). L’esempio seguente mostra due importanti impostazioni: controllare il numero di righe che la legenda utilizza con nrow, e sovrascrivere una delle estetiche per rendere punti più grandi. Questo è particolarmente utile se hai usato una bassa alpha per visualizzare molti punti su un grafico.","code":"\nbase <- ggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class))\n\nbase + theme(legend.position = \"left\")\nbase + theme(legend.position = \"top\")\nbase + theme(legend.position = \"bottom\")\nbase + theme(legend.position = \"right\") # il default\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(colour = class)) +\n  geom_smooth(se = FALSE) +\n  theme(legend.position = \"bottom\") +\n  guides(colour = guide_legend(nrow = 1, override.aes = list(size = 4)))\n#> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"grafici-per-la-comunicazione.html","id":"sostituzione-di-una-scala","chapter":"28 Grafici per la comunicazione","heading":"28.4.3 Sostituzione di una scala","text":"Invece di modificare un po’ dettagli, è possibile sostituire completamente la scala. Ci sono due tipi di scale che probabilmente vorrete sostituire: le scale di posizione continua e le scale di colore. Fortunatamente, gli stessi principi si applicano tutte le altre estetiche, per cui una volta acquisita la padronanza della posizione e del colore, sarete grado di sostituire rapidamente le altre scale.È molto utile tracciare le trasformazioni della variabile. Ad esempio, come abbiamo visto prezzi dei diamanti, è più facile vedere la relazione precisa tra carat e price se li trasformiamo log:Tuttavia, lo svantaggio di questa trasformazione è che gli assi sono ora etichettati con valori trasformati, rendendo difficile l’interpretazione del grafico. Invece di fare la trasformazione nella mappatura estetica, possiamo invece farla con la scala. Questo è visivamente identico, eccetto che gli assi sono etichettati con la scala originale dei dati.Un’altra scala che viene spesso personalizzata è quella dei colori. La scala categorica predefinita sceglie colori che sono uniformemente distanziati dalla ruota dei colori. Un’alternativa utile è rappresentata dalle scale ColorBrewer, che sono state messe punto mano per funzionare meglio per le persone con più comuni tipi di daltonismo. due grafici qui sotto sembrano simili, ma c’è una differenza sufficiente nelle tonalità del rosso e del verde, tanto che punti sulla destra possono essere distinti anche dalle persone affette da daltonismo rosso-verde.Non dimenticare le tecniche più semplici. Se ci sono solo pochi colori, potete aggiungere una mappatura ridondante delle forme. Questo aiuterà anche garantire che la tua trama sia interpretabile bianco e nero.Le scale di ColorBrewer sono documentate online ’indirizzo http://colorbrewer2.org/ e rese disponibili R tramite il pacchetto RColorBrewer, di Erich Neuwirth. La figura 28.2 mostra l’elenco completo di tutte le tavolozze. Le palette sequenziale (alto) e divergente (basso) sono particolarmente utili se valori categoriali sono ordinati o hanno una “via di mezzo”. Ciò si verifica spesso se si è usato cut() per trasformare una variabile continua una categorica.\nFigure 28.2: ColourBrewer scales.\nQuando si dispone di una mappatura predefinita tra valori e colori, si può usare scala_colore_manuale(). Ad esempio, se si mappa il partito presidenziale con il colore, si vuole utilizzare la mappatura standard di rosso per repubblicani e blu per democratici:Per il colore continuo, potete usare il built-scale_colour_gradient() o scale_fill_gradient(). Se avete una scala divergente, potete usare scale_colour_gradient2(). Questo ti permette di dare, per esempio, valori positivi e negativi di colori diversi. Questo volte è anche utile se vuoi distinguere punti sopra o sotto la media.Un’altra opzione è scale_colour_viridis() fornita dal pacchetto viridis. È un analogo continuo delle scale categoriche di ColorBrewer. progettisti, Nathaniel Smith e Stéfan van der Walt, hanno attentamente personalizzato uno schema di colori continuo che ha buone proprietà percettive. Ecco un esempio dalla vignetta di viridis.Si noti che tutte le scale di colore sono disponibili due varietà: scale_colour_x() e scale_fill_x() per l’estetica colour e fill rispettivamente (le scale di colore sono disponibili entrambe le grafie UK e US).","code":"\nggplot(diamonds, aes(carat, price)) +\n  geom_bin2d()\n\nggplot(diamonds, aes(log10(carat), log10(price))) +\n  geom_bin2d()\nggplot(diamonds, aes(carat, price)) +\n  geom_bin2d() + \n  scale_x_log10() + \n  scale_y_log10()\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = drv))\n\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = drv)) +\n  scale_colour_brewer(palette = \"Set1\")\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = drv, shape = drv)) +\n  scale_colour_brewer(palette = \"Set1\")\npresidential %>%\n  mutate(id = 33 + row_number()) %>%\n  ggplot(aes(start, id, colour = party)) +\n    geom_point() +\n    geom_segment(aes(xend = end, yend = id)) +\n    scale_colour_manual(values = c(Republican = \"red\", Democratic = \"blue\"))\ndf <- tibble(\n  x = rnorm(10000),\n  y = rnorm(10000)\n)\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  coord_fixed()\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  viridis::scale_fill_viridis() +\n  coord_fixed()"},{"path":"grafici-per-la-comunicazione.html","id":"esercizi-76","chapter":"28 Grafici per la comunicazione","heading":"28.4.4 Esercizi","text":"Perché il seguente codice non sovrascrive la scala di default?\n\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  scale_colour_gradient(low = \"white\", high = \"red\") +\n  coord_fixed()Perché il seguente codice non sovrascrive la scala di default?Qual è il primo argomento di ogni scala? Come si confronta con labs()?Qual è il primo argomento di ogni scala? Come si confronta con labs()?Cambiate la visualizzazione dei termini presidenziali con:\nCombinando le due varianti mostrate sopra.\nMigliorando la visualizzazione dell’asse y.\nEtichettare ogni termine con il nome del presidente.\nAggiungere etichette informative al grafico.\nMettere delle pause ogni 4 anni (questo è più complicato di quanto sembri!).\nCambiate la visualizzazione dei termini presidenziali con:Combinando le due varianti mostrate sopra.Migliorando la visualizzazione dell’asse y.Etichettare ogni termine con il nome del presidente.Aggiungere etichette informative al grafico.Mettere delle pause ogni 4 anni (questo è più complicato di quanto sembri!).Usare override.aes per rendere la legenda del seguente grafico più facile da vedere.\n\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(colour = cut), alpha = 1/20)\nUsare override.aes per rendere la legenda del seguente grafico più facile da vedere.","code":"\nggplot(df, aes(x, y)) +\n  geom_hex() +\n  scale_colour_gradient(low = \"white\", high = \"red\") +\n  coord_fixed()\nggplot(diamonds, aes(carat, price)) +\n  geom_point(aes(colour = cut), alpha = 1/20)"},{"path":"grafici-per-la-comunicazione.html","id":"zoom","chapter":"28 Grafici per la comunicazione","heading":"28.5 Zoom","text":"Ci sono tre modi per controllare limiti della trama:Regolare quali dati vengono tracciatiImpostare limiti ogni scalaImpostando xlim e ylim coord_cartesian()Per ingrandire una regione del grafico, è generalmente meglio usare coord_cartesian(). Confronta seguenti due grafici:Puoi anche impostare limits sulle singole scale. Ridurre limiti è fondamentalmente equivalente al sottoinsieme dei dati. È generalmente più utile se volete espandere limiti, per esempio, per far corrispondere le scale diversi plot. Per esempio, se estraiamo due classi di automobili e le tracciamo separatamente, è difficile confrontare grafici perché tutte e tre le scale (l’asse x, l’asse y e il colore estetico) hanno range diversi.Un modo per superare questo problema è quello di condividere le scale tra più trame, formando le scale con “limiti” dei dati completi.questo caso particolare, si sarebbe potuto usare semplicemente il faceting, ma questa tecnica è utile più generale, se ad esempio si vogliono distribuire le trame su più pagine di un report.","code":"\nggplot(mpg, mapping = aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth() +\n  coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))\n\nmpg %>%\n  filter(displ >= 5, displ <= 7, hwy >= 10, hwy <= 30) %>%\n  ggplot(aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth()\nsuv <- mpg %>% filter(class == \"suv\")\ncompact <- mpg %>% filter(class == \"compact\")\n\nggplot(suv, aes(displ, hwy, colour = drv)) +\n  geom_point()\n\nggplot(compact, aes(displ, hwy, colour = drv)) +\n  geom_point()\nx_scale <- scale_x_continuous(limits = range(mpg$displ))\ny_scale <- scale_y_continuous(limits = range(mpg$hwy))\ncol_scale <- scale_colour_discrete(limits = unique(mpg$drv))\n\nggplot(suv, aes(displ, hwy, colour = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale\n\nggplot(compact, aes(displ, hwy, colour = drv)) +\n  geom_point() +\n  x_scale +\n  y_scale +\n  col_scale"},{"path":"grafici-per-la-comunicazione.html","id":"temi","chapter":"28 Grafici per la comunicazione","heading":"28.6 Temi","text":"Infine, è possibile personalizzare gli elementi non dati del grafico con un tema:ggplot2 include otto temi predefiniti, come mostrato Figura 28.3. Molti altri sono inclusi pacchetti aggiuntivi come ggthemes (https://github.com/jrnold/ggthemes), di Jeffrey Arnold.\nFigure 28.3: eight themes built-ggplot2.\nMolte persone si chiedono perché il tema di default ha uno sfondo grigio. Questa è stata una scelta deliberata perché mette evidenza dati mentre rende ancora visibili le linee della griglia. Le linee bianche della griglia sono visibili (il che è importante perché aiutano significativamente giudizi sulla posizione), ma hanno poco impatto visivo e possiamo facilmente ignorarle. Lo sfondo grigio dà alla trama un colore tipografico simile al testo, assicurando che la grafica si adatti al flusso di un documento senza saltare fuori con uno sfondo bianco brillante. Infine, lo sfondo grigio crea un campo di colore continuo che assicura che la trama sia percepita come una singola entità visiva.È anche possibile controllare singoli componenti di ogni tema, come la dimensione e il colore del carattere utilizzato per l’asse y. Sfortunatamente, questo livello di dettaglio è al di fuori dello scopo di questo libro, quindi avrete bisogno di leggere il libro ggplot2 per dettagli completi. È anche possibile creare propri temi, se si sta cercando di abbinare un particolare stile aziendale o di giornale.","code":"\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = FALSE) +\n  theme_bw()"},{"path":"grafici-per-la-comunicazione.html","id":"salvare-le-tue-trame","chapter":"28 Grafici per la comunicazione","heading":"28.7 Salvare le tue trame","text":"Ci sono due modi principali per portare vostri grafici fuori da R e nel vostro testo finale: ggsave() e knitr. ggsave() salverà la trama più recente sul disco:Se non si specificano la width e lheight, queste saranno prese dalle dimensioni del dispositivo di plottaggio corrente. Per un codice riproducibile, è meglio specificarle.generale, tuttavia, penso che dovreste assemblare vostri report finali usando R Markdown, quindi voglio concentrarmi sulle opzioni importanti per il codice che dovreste conoscere per grafici. Potete saperne di più su ggsave() nella documentazione.","code":"\nggplot(mpg, aes(displ, hwy)) + geom_point()\nggsave(\"my-plot.pdf\")\n#> Saving 7 x 4.32 in image"},{"path":"grafici-per-la-comunicazione.html","id":"dimensionamento-delle-figure","chapter":"28 Grafici per la comunicazione","heading":"28.7.1 Dimensionamento delle figure","text":"La sfida più grande della grafica R Markdown è quella di dare alle figure la giusta dimensione e forma. Ci sono cinque opzioni principali che controllano il dimensionamento delle figure: fig.width, fig.height, fig.asp, .width e .height. Il dimensionamento delle immagini è impegnativo perché ci sono due dimensioni (la dimensione della figura creata da R e la dimensione cui viene inserita nel documento di output) e più modi di specificare le dimensioni (cioè, altezza, larghezza e rapporto di aspetto: sceglietene due su tre).Io uso solo tre delle cinque opzioni:Trovo esteticamente più gradevole che le trame abbiano una larghezza coerente.\nlarghezza. Per imporlo, ho impostato fig.width = 6 (6”) e fig.asp = 0,618\n(il rapporto aureo) nelle impostazioni predefinite. Poi, nei singoli pezzi, aggiusto solo\nregolare fig.asp.Trovo esteticamente più gradevole che le trame abbiano una larghezza coerente.\nlarghezza. Per imporlo, ho impostato fig.width = 6 (6”) e fig.asp = 0,618\n(il rapporto aureo) nelle impostazioni predefinite. Poi, nei singoli pezzi, aggiusto solo\nregolare fig.asp.Controllo la dimensione dell’output con .width e la imposto ad una percentuale\ndella larghezza della linea. Il mio default è .width = \"70%\"\ne fig.align = \"center\". Questo dà alle trame spazio per respirare, senza occupare\ntroppo spazio.Controllo la dimensione dell’output con .width e la imposto ad una percentuale\ndella larghezza della linea. Il mio default è .width = \"70%\"\ne fig.align = \"center\". Questo dà alle trame spazio per respirare, senza occupare\ntroppo spazio.Per mettere più trame una singola riga ho impostato la .width \n50% per due trame, 33% per 3 trame, o 25% per 4 trame, e impostare\nfig.align = \"default\". seconda di ciò che sto cercando di illustrare (ad es.\nmostrare dati o mostrare le variazioni dei grafici), modificherò anche fig.width, come\ndiscusso sotto.Per mettere più trame una singola riga ho impostato la .width \n50% per due trame, 33% per 3 trame, o 25% per 4 trame, e impostare\nfig.align = \"default\". seconda di ciò che sto cercando di illustrare (ad es.\nmostrare dati o mostrare le variazioni dei grafici), modificherò anche fig.width, come\ndiscusso sotto.Se trovi che devi strizzare gli occhi per leggere il testo nel tuo grafico, devi modificare fig.width. Se fig.width è più grande della dimensione cui la figura è resa nel documento finale, il testo sarà troppo piccolo; se fig.width è più piccolo, il testo sarà troppo grande. Avrai spesso bisogno di fare un po’ di esperimenti per capire il giusto rapporto tra la fig.width e la larghezza finale nel tuo documento. Per illustrare il principio, seguenti tre grafici hanno fig.width rispettivamente di 4, 6 e 8:Per assicurarsi che la dimensione dei caratteri sia coerente tutte le figure, ogni volta che si imposta .width, è necessario regolare anche fig.width per mantenere lo stesso rapporto con la .width predefinita. Per esempio, se la larghezza predefinita di fig.width è 6 e quella di .width è 0,7, quando si imposta .width = \"50%\" si dovrà impostare fig.width 4,3 (6 * 0,5 / 0,7).","code":""},{"path":"grafici-per-la-comunicazione.html","id":"altre-opzioni-importanti","chapter":"28 Grafici per la comunicazione","heading":"28.7.2 Altre opzioni importanti","text":"Quando si mescolano codice e testo, come faccio io questo libro, raccomando di impostare fig.show = \"hold\" modo che grafici vengano mostrati dopo il codice. Questo ha il piacevole effetto collaterale di costringere suddividere grandi blocchi di codice con le relative spiegazioni.Per aggiungere una didascalia al grafico, usare fig.cap. R Markdown questo cambia la figura da inline “floating”.Se si produce un output PDF, il tipo di grafica predefinito è PDF. Si tratta di una buona impostazione predefinita, perché PDF sono grafici vettoriali di alta qualità. Tuttavia, possono produrre grafici molto grandi e lenti se si visualizzano migliaia di punti. questo caso, impostare dev = \"png\" per forzare l’uso dei PNG. La loro qualità è leggermente inferiore, ma sono molto più compatti.È una buona idea dare un nome ai pezzi di codice che producono figure, anche se non si etichettano abitualmente altri pezzi. L’etichetta del chunk viene usata per generare il nome del file del grafico su disco, quindi dare un nome ai chunk rende molto più facile individuare le trame e riutilizzarle altre circostanze (ad esempio, se si vuole inserire rapidamente una singola trama un’e-mail o un tweet).","code":""},{"path":"grafici-per-la-comunicazione.html","id":"per-saperne-di-più-3","chapter":"28 Grafici per la comunicazione","heading":"28.8 Per saperne di più","text":"Il posto migliore per saperne di più è il libro ggplot2: ggplot2: Elegant graphics data analysis. Approfondisce la teoria sottostante e contiene molti altri esempi di come combinare singoli elementi per risolvere problemi pratici. Purtroppo il libro non è disponibile gratuitamente online, anche se è possibile trovare il codice sorgente ’indirizzo https://github.com/hadley/ggplot2-book.Un’altra grande risorsa è la galleria delle estensioni di ggplot2 https://exts.ggplot2.tidyverse.org/gallery/. Questo sito elenca molti dei pacchetti che estendono ggplot2 con nuovi geomi e scale. È un ottimo punto di partenza se si sta cercando di fare qualcosa che sembra difficile con ggplot2.","code":""},{"path":"formati-di-r-markdown.html","id":"formati-di-r-markdown","chapter":"29 Formati di R Markdown","heading":"29 Formati di R Markdown","text":"","code":""},{"path":"formati-di-r-markdown.html","id":"introduzione-20","chapter":"29 Formati di R Markdown","heading":"29.1 Introduzione","text":"Finora abbiamo visto R Markdown utilizzato per produrre documenti HTML. Questo capitolo offre una breve panoramica di alcuni dei molti altri tipi di output che si possono produrre con R Markdown. Esistono due modi per impostare l’output di un documento:modo permanente, modificando l’intestazione YAML:\ntitle: \"Viridis Demo\"\noutput: html_documentIn modo permanente, modificando l’intestazione YAML:modo transitorio, chiamando manualmente rmarkdown::render():\n\nrmarkdown::render(\"diamond-sizes.Rmd\", output_format = \"word_document\")\nQuesto è utile se si desidera produrre programmaticamente più tipi di output.modo transitorio, chiamando manualmente rmarkdown::render():Questo è utile se si desidera produrre programmaticamente più tipi di output.Il pulsante knit di RStudio esegue il rendering di un file nel primo formato elencato nel campo output. È possibile eseguire il rendering altri formati facendo clic sul menu discesa accanto al pulsante knit.","code":"title: \"Viridis Demo\"\noutput: html_document\nrmarkdown::render(\"diamond-sizes.Rmd\", output_format = \"word_document\")"},{"path":"formati-di-r-markdown.html","id":"opzioni-di-output","chapter":"29 Formati di R Markdown","heading":"29.2 Opzioni di output","text":"ogni formato di output è associata una funzione R. Si può scrivere foo o pkg::foo. Se si omette pkg, si assume come predefinito rmarkdown. È importante conoscere il nome della funzione che produce l’output, perché è da lì che si ottiene aiuto. Per esempio, per capire quali parametri si possono impostare con html_document, si può consultare ?rmarkdown::html_document.Per sovrascrivere valori predefiniti dei parametri, è necessario utilizzare un campo output espanso. Per esempio, se si volesse rendere un html_document con un indice fluttuante, si userebbe:È anche possibile eseguire il rendering su più output fornendo un elenco di formati:Si noti la sintassi speciale se non si vuole sovrascrivere nessuna delle opzioni predefinite.","code":"output:\n  html_document:\n    toc: true\n    toc_float: trueoutput:\n  html_document:\n    toc: true\n    toc_float: true\n  pdf_document: default"},{"path":"formati-di-r-markdown.html","id":"documenti","chapter":"29 Formati di R Markdown","heading":"29.3 Documenti","text":"Il capitolo precedente si è concentrato sull’output predefinito html_document. Esistono diverse variazioni di base su questo tema, che generano diversi tipi di documenti:pdf_document crea un PDF con LaTeX (un sistema di impaginazione di documenti open source), che è necessario installare.\nLaTeX (un sistema open source di impaginazione dei documenti), che è necessario installare. RStudio lo richiederà se\nnon l’avete già.pdf_document crea un PDF con LaTeX (un sistema di impaginazione di documenti open source), che è necessario installare.\nLaTeX (un sistema open source di impaginazione dei documenti), che è necessario installare. RStudio lo richiederà se\nnon l’avete già.word_document per documenti Microsoft Word (.docx).word_document per documenti Microsoft Word (.docx).odt_document per documenti OpenDocument Text (.odt).odt_document per documenti OpenDocument Text (.odt).rtf_document per documenti Rich Text Format (.rtf).rtf_document per documenti Rich Text Format (.rtf).md_document per un documento Markdown. genere non è utile di per sé, ma\ndi per sé, ma si potrebbe usare se, per esempio, il CMS aziendale o il wiki del laboratorio\nwiki del laboratorio utilizza markdown.md_document per un documento Markdown. genere non è utile di per sé, ma\ndi per sé, ma si potrebbe usare se, per esempio, il CMS aziendale o il wiki del laboratorio\nwiki del laboratorio utilizza markdown.github_document: si tratta di una versione adattata di md_document\npensata per la condivisione su GitHub.github_document: si tratta di una versione adattata di md_document\npensata per la condivisione su GitHub.Ricordate che quando si genera un documento da condividere con decisori, è possibile disattivare la visualizzazione predefinita del codice impostando le opzioni globali nel chunk di setup:Per gli html_document un’altra opzione è quella di rendere pezzi di codice nascosti per impostazione predefinita, ma visibili con un clic:","code":"\nknitr::opts_chunk$set(echo = FALSE)output:\n  html_document:\n    code_folding: hide"},{"path":"formati-di-r-markdown.html","id":"quaderni","chapter":"29 Formati di R Markdown","heading":"29.4 Quaderni","text":"Un quaderno, html_notebook, è una variante di un html_document. risultati resi sono molto simili, ma lo scopo è diverso. Un html_document è focalizzato sulla comunicazione con decisori, mentre un notebook è focalizzato sulla collaborazione con altri data scientist. Questi scopi diversi portano utilizzare l’output HTML modi diversi. Entrambi gli output HTML contengono l’output completamente renderizzato, ma il blocco note contiene anche il codice sorgente completo. Ciò significa che è possibile utilizzare il file .nb.html generato dal blocco note due modi:È possibile visualizzarlo un browser Web e vedere l’output renderizzato. differenza di\nhtml_document, questo rendering comprende sempre una copia incorporata del\ndel codice sorgente che lo ha generato.È possibile visualizzarlo un browser Web e vedere l’output renderizzato. differenza di\nhtml_document, questo rendering comprende sempre una copia incorporata del\ndel codice sorgente che lo ha generato.È possibile modificarlo RStudio. Quando si apre un file .nb.html, RStudio ricrea automaticamente il file .Rmd.\nricreerà automaticamente il file .Rmd che lo ha generato. futuro, sarà possibile\nfuturo sarà possibile includere anche file di supporto (ad esempio file di dati .csv), che verranno estratti automaticamente quando necessario.\nsaranno estratti automaticamente quando necessario.È possibile modificarlo RStudio. Quando si apre un file .nb.html, RStudio ricrea automaticamente il file .Rmd.\nricreerà automaticamente il file .Rmd che lo ha generato. futuro, sarà possibile\nfuturo sarà possibile includere anche file di supporto (ad esempio file di dati .csv), che verranno estratti automaticamente quando necessario.\nsaranno estratti automaticamente quando necessario.L’invio di file .nb.html via e-mail è un modo semplice per condividere le analisi con colleghi. Ma le cose si faranno dolorose non appena vorranno apportare delle modifiche. Se ciò inizia verificarsi, è il momento di imparare Git e GitHub. Imparare Git e GitHub è sicuramente doloroso ’inizio, ma vantaggi della collaborazione sono enormi. Come accennato precedenza, Git e GitHub esulano dallo scopo del libro, ma c’è un suggerimento utile se li si sta già usando: utilizzare entrambi gli output html_notebook e github_document:html_notebook fornisce un’anteprima locale e un file da condividere via e-mail. github_document crea un file md minimo che può essere inserito git. Si può facilmente vedere come risultati dell’analisi (non solo il codice) cambiano nel tempo e GitHub li renderà online.","code":"output:\n  html_notebook: default\n  github_document: default"},{"path":"formati-di-r-markdown.html","id":"presentazioni","chapter":"29 Formati di R Markdown","heading":"29.5 Presentazioni","text":"È anche possibile utilizzare R Markdown per produrre presentazioni. Il controllo visivo è minore rispetto strumenti come Keynote o PowerPoint, ma l’inserimento automatico dei risultati del codice R una presentazione può far risparmiare moltissimo tempo. Le presentazioni funzionano dividendo il contenuto diapositive, con una nuova diapositiva che inizia ogni intestazione di primo (#) o secondo (##) livello. È anche possibile inserire una regola orizzontale (***) per creare una nuova diapositiva senza intestazione.R Markdown è dotato di tre formati di presentazione integrati:ioslides_presentation - Presentazione HTML con ioslidesioslides_presentation - Presentazione HTML con ioslidesslidy_presentation - presentazione HTML con W3C Slidyslidy_presentation - presentazione HTML con W3C Slidybeamer_presentation - Presentazione PDF con LaTeX Beamer.beamer_presentation - Presentazione PDF con LaTeX Beamer.Altri due formati popolari sono forniti da pacchetti:revealjs::revealjs_presentation - Presentazione HTML con reveal.js.\nRichiede il pacchetto revealjs.revealjs::revealjs_presentation - Presentazione HTML con reveal.js.\nRichiede il pacchetto revealjs.rmdshower, https://github.com/MangoTheCat/rmdshower, fornisce un\nwrapper attorno shower, https://github.com/shower/shower,\nmotore di presentazionermdshower, https://github.com/MangoTheCat/rmdshower, fornisce un\nwrapper attorno shower, https://github.com/shower/shower,\nmotore di presentazione","code":""},{"path":"formati-di-r-markdown.html","id":"cruscotti","chapter":"29 Formati di R Markdown","heading":"29.6 Cruscotti","text":"cruscotti sono un modo utile per comunicare grandi quantità di informazioni modo visivo e veloce. Flexdashboard rende particolarmente facile la creazione di cruscotti usando R Markdown e una convenzione per il modo cui le intestazioni influenzano il layout:Ogni intestazione di livello 1 (#) inizia una nuova pagina del dashboard.Ogni intestazione di livello 2 (##) inizia una nuova colonna.Ogni intestazione di livello 3 (###) inizia una nuova riga.Ad esempio, è possibile produrre questo dashboard:Utilizzando questo codice:Flexdashboard fornisce anche semplici strumenti per la creazione di barre laterali, tabset, caselle di valore e indicatori. Per saperne di più su flexdashboard visitate http://rmarkdown.rstudio.com/flexdashboard/.","code":"---\ntitle: \"Diamonds distribution dashboard\"\noutput: flexdashboard::flex_dashboard\n---\n\n```{r setup, include = FALSE}\nlibrary(ggplot2)\nlibrary(dplyr)\nknitr::opts_chunk$set(fig.width = 5, fig.asp = 1/3)\n```\n\n## Column 1\n\n### Carat\n\n```{r}\nggplot(diamonds, aes(carat)) + geom_histogram(binwidth = 0.1)\n```\n\n### Cut\n\n```{r}\nggplot(diamonds, aes(cut)) + geom_bar()\n```\n\n### Colour\n\n```{r}\nggplot(diamonds, aes(color)) + geom_bar()\n```\n\n## Column 2\n\n### The largest diamonds\n\n```{r}\ndiamonds %>% \n  arrange(desc(carat)) %>% \n  head(100) %>% \n  select(carat, cut, color, price) %>% \n  DT::datatable()\n```"},{"path":"formati-di-r-markdown.html","id":"interattività","chapter":"29 Formati di R Markdown","heading":"29.7 Interattività","text":"Qualsiasi formato HTML (documento, blocco note, presentazione o dashboard) può contenere componenti interattivi.","code":""},{"path":"formati-di-r-markdown.html","id":"htmlwidgets","chapter":"29 Formati di R Markdown","heading":"29.7.1 htmlwidgets","text":"L’HTML è un formato interattivo e si può sfruttare questa interattività con htmlwidgets, funzioni di R che producono visualizzazioni HTML interattive. Per esempio, prendete la mappa leaflet qui sotto. Se state visualizzando questa pagina sul web, potete trascinare la mappa, ingrandirla e rimpicciolirla, ecc. Ovviamente non è possibile farlo un libro, quindi rmarkdown inserisce automaticamente una schermata statica.Il bello di htmlwidgets è che non è necessario conoscere nulla di HTML o JavaScript per utilizzarli. Tutti dettagli sono racchiusi ’interno del pacchetto, quindi non c’è bisogno di preoccuparsi.Esistono molti pacchetti che forniscono htmlwidget, tra cui:dygraphs, http://rstudio.github.io/dygraphs/, per la visualizzazione interattiva di serie temporali.\nserie temporali interattive.dygraphs, http://rstudio.github.io/dygraphs/, per la visualizzazione interattiva di serie temporali.\nserie temporali interattive.DT, http://rstudio.github.io/DT/, per tabelle interattive.DT, http://rstudio.github.io/DT/, per tabelle interattive.threejs, https://github.com/bwlewis/rthreejs, per grafici 3d interattivi.threejs, https://github.com/bwlewis/rthreejs, per grafici 3d interattivi.DiagrammeR, http://rich-iannone.github.io/DiagrammeR/ per diagrammi (come diagrammi di flusso e semplici diagrammi nodi).\n(come diagrammi di flusso e semplici diagrammi di collegamento tra nodi).DiagrammeR, http://rich-iannone.github.io/DiagrammeR/ per diagrammi (come diagrammi di flusso e semplici diagrammi nodi).\n(come diagrammi di flusso e semplici diagrammi di collegamento tra nodi).Per saperne di più sugli htmlwidget e per vedere un elenco più completo dei pacchetti che li forniscono, visitate http://www.htmlwidgets.org/.","code":"\nlibrary(leaflet)\nleaflet() %>%\n  setView(174.764, -36.877, zoom = 16) %>% \n  addTiles() %>%\n  addMarkers(174.764, -36.877, popup = \"Maungawhau\") "},{"path":"formati-di-r-markdown.html","id":"shiny","chapter":"29 Formati di R Markdown","heading":"29.7.2 Shiny","text":"Gli htmlwidget forniscono l’interattività client-side — tutta l’interattività avviene nel browser, indipendentemente da R. Da un lato, questo è ottimo perché si può distribuire il file HTML senza alcuna connessione R. Tuttavia, questo limita fondamentalmente ciò che si può fare alle cose che sono state implementate HTML e JavaScript. Un approccio alternativo è quello di utilizzare shiny, un pacchetto che consente di creare interattività utilizzando codice R, non JavaScript.Per richiamare il codice Shiny da un documento R Markdown, aggiungere runtime: shiny ’intestazione:Quindi è possibile utilizzare le funzioni di “input” per aggiungere componenti interattivi al documento:\nÈ quindi possibile fare riferimento ai valori con input$name e input$age, e il codice che li utilizza verrà automaticamente rieseguito ogni volta che cambiano.Non posso mostrarvi un’applicazione shiny dal vivo perché le interazioni di shiny avvengono sul lato server. Ciò significa che è possibile scrivere applicazioni interattive senza conoscere JavaScript, ma è necessario un server su cui eseguirle. Questo introduce un problema logistico: Le applicazioni Shiny hanno bisogno di un server Shiny per essere eseguite online. Quando si eseguono le app shiny sul proprio computer, shiny configura automaticamente un server shiny per l’utente, ma è necessario un server shiny pubblico se si vuole pubblicare questo tipo di interattività online. Questo è il compromesso fondamentale di shiny: un documento shiny si può fare tutto ciò che si può fare R, ma è necessario che qualcuno utilizzi R.Per saperne di più su Shiny, consultare http://shiny.rstudio.com/.","code":"title: \"Shiny Web App\"\noutput: html_document\nruntime: shiny\nlibrary(shiny)\n\ntextInput(\"name\", \"Come ti chiami?\")\nnumericInput(\"age\", \"Quanti anni hai?\", NA, min = 0, max = 150)"},{"path":"formati-di-r-markdown.html","id":"siti-web","chapter":"29 Formati di R Markdown","heading":"29.8 Siti web","text":"Con una piccola infrastruttura aggiuntiva è possibile utilizzare R Markdown per generare un sito web completo:Mettere file .Rmd una singola directory. index.Rmd diventerà la\nla pagina iniziale.Mettere file .Rmd una singola directory. index.Rmd diventerà la\nla pagina iniziale.Aggiungere un file YAML chiamato _site.yml che fornisca la navigazione del sito.\nPer esempio:\nname: \"-website\"\nnavbar:\n  title: \"Website\"\n  left:\n    - text: \"Home\"\n      href: index.html\n    - text: \"Viridis Colors\"\n      href: 1-example.html\n    - text: \"Terrain Colors\"\n      href: 3-inline.htmlAggiungere un file YAML chiamato _site.yml che fornisca la navigazione del sito.\nPer esempio:Eseguire rmarkdown::render_site() per costruire _site, una cartella di file pronta per essere distribuita come sito web statico autonomo, o se si usa un progetto RStudio per la cartella del sito web. RStudio aggiungerà una scheda Build ’IDE che si può usare per costruire e visualizzare anteprima il sito.Per saperne di più: http://rmarkdown.rstudio.com/rmarkdown_websites.html.","code":"name: \"my-website\"\nnavbar:\n  title: \"My Website\"\n  left:\n    - text: \"Home\"\n      href: index.html\n    - text: \"Viridis Colors\"\n      href: 1-example.html\n    - text: \"Terrain Colors\"\n      href: 3-inline.html"},{"path":"formati-di-r-markdown.html","id":"altri-formati","chapter":"29 Formati di R Markdown","heading":"29.9 Altri formati","text":"Altri pacchetti forniscono altri formati di output:Il pacchetto bookdown, https://github.com/rstudio/bookdown,\nsemplifica la scrittura di libri, come questo. Per saperne di più, leggere\nAuthoring Books R Markdown,\ndi Yihui Xie, che ovviamente è scritto bookdown. Visitate\nhttp://www.bookdown.org per vedere altri libri bookdown scritti dalla comunità\ncomunità di R.Il pacchetto bookdown, https://github.com/rstudio/bookdown,\nsemplifica la scrittura di libri, come questo. Per saperne di più, leggere\nAuthoring Books R Markdown,\ndi Yihui Xie, che ovviamente è scritto bookdown. Visitate\nhttp://www.bookdown.org per vedere altri libri bookdown scritti dalla comunità\ncomunità di R.Il pacchetto prettydoc, https://github.com/yixuan/prettydoc/,\nfornisce formati di documenti leggeri con una serie di\ntemi accattivanti.Il pacchetto prettydoc, https://github.com/yixuan/prettydoc/,\nfornisce formati di documenti leggeri con una serie di\ntemi accattivanti.Il pacchetto rticles, https://github.com/rstudio/rticles, compila una selezione di formati\nuna selezione di formati adatti specifiche riviste scientifiche.Il pacchetto rticles, https://github.com/rstudio/rticles, compila una selezione di formati\nuna selezione di formati adatti specifiche riviste scientifiche.Vedere http://rmarkdown.rstudio.com/formats.html per un elenco di altri formati. È anche possibile crearne uno proprio seguendo le istruzioni di http://rmarkdown.rstudio.com/developer_custom_formats.html.","code":""},{"path":"formati-di-r-markdown.html","id":"imparare-di-più-1","chapter":"29 Formati di R Markdown","heading":"29.10 Imparare di più","text":"Per saperne di più sulla comunicazione efficace questi diversi formati, vi consiglio le seguenti risorse:Per migliorare le vostre capacità di presentazione, vi consiglio\nPresentation Patterns, di Neal Ford,\nMatthew McCollough e Nathaniel Schutta. Fornisce una serie di modelli\nefficaci (sia di basso che di alto livello) da applicare per migliorare le vostre presentazioni.\npresentazioni.Per migliorare le vostre capacità di presentazione, vi consiglio\nPresentation Patterns, di Neal Ford,\nMatthew McCollough e Nathaniel Schutta. Fornisce una serie di modelli\nefficaci (sia di basso che di alto livello) da applicare per migliorare le vostre presentazioni.\npresentazioni.Se tenete conferenze accademiche, vi consiglio di leggere la Guida del gruppo Leek\ngiving talks.Se tenete conferenze accademiche, vi consiglio di leggere la Guida del gruppo Leek\ngiving talks.Non l’ho seguito personalmente, ma ho sentito parlare bene del corso online di Matt\nMcGarrity sul parlare pubblico:\nhttps://www.coursera.org/learn/public-speaking.Non l’ho seguito personalmente, ma ho sentito parlare bene del corso online di Matt\nMcGarrity sul parlare pubblico:\nhttps://www.coursera.org/learn/public-speaking.Se state creando molti cruscotti, assicuratevi di leggere Stephen ’s\nProgettazione di cruscotti informativi: La comunicazione visiva efficace dei dati\nData. Vi aiuterà creare cruscotti\nche siano veramente utili, non solo belli da vedere.Se state creando molti cruscotti, assicuratevi di leggere Stephen ’s\nProgettazione di cruscotti informativi: La comunicazione visiva efficace dei dati\nData. Vi aiuterà creare cruscotti\nche siano veramente utili, non solo belli da vedere.Comunicare modo efficace le proprie idee spesso si avvantaggia di qualche\nconoscenza del design grafico. Il libro Il design per non designer\nBook è un ottimo punto di partenza.Comunicare modo efficace le proprie idee spesso si avvantaggia di qualche\nconoscenza del design grafico. Il libro Il design per non designer\nBook è un ottimo punto di partenza.","code":""},{"path":"r-markdown-workflow.html","id":"r-markdown-workflow","chapter":"30 R Markdown workflow","heading":"30 R Markdown workflow","text":"precedenza, abbiamo discusso un flusso di lavoro di base per la cattura del codice R cui si lavora interattivamente nella console, quindi si cattura ciò che funziona nell’editor di script. R Markdown riunisce la console e l’editor di script, attenuando confini tra l’esplorazione interattiva e la cattura del codice lungo termine. È possibile iterare rapidamente ’interno di un pezzo, modificando e rieseguendo con Cmd/Ctrl + Maiusc + Invio. Quando si è soddisfatti, si passa un nuovo pezzo.R Markdown è importante anche perché integra strettamente prosa e codice. Questo lo rende un ottimo quaderno di analisi perché consente di sviluppare codice e registrare propri pensieri. Un quaderno di analisi condivide molti degli stessi obiettivi di un classico quaderno di laboratorio nelle scienze fisiche. Esso:Registra ciò che avete fatto e perché lo avete fatto. Indipendentemente da quanto sia grande la vostra\nmemoria, se non si registra quello che si fa, arriverà un momento cui\ndimenticarsi di dettagli importanti. Scriveteli per non dimenticarli!Registra ciò che avete fatto e perché lo avete fatto. Indipendentemente da quanto sia grande la vostra\nmemoria, se non si registra quello che si fa, arriverà un momento cui\ndimenticarsi di dettagli importanti. Scriveteli per non dimenticarli!Supporta il pensiero rigoroso. È più probabile che si arrivi un’analisi forte\nanalisi forte se si registrano propri pensieri e si continua riflettere su di essi.\nsu di essi. questo modo si risparmia tempo quando si scrive l’analisi per condividerla con gli altri.\nanalisi da condividere con gli altri.Supporta il pensiero rigoroso. È più probabile che si arrivi un’analisi forte\nanalisi forte se si registrano propri pensieri e si continua riflettere su di essi.\nsu di essi. questo modo si risparmia tempo quando si scrive l’analisi per condividerla con gli altri.\nanalisi da condividere con gli altri.Aiuta gli altri capire il vostro lavoro. È raro che l’analisi dei dati venga svolta da\nda soli e spesso si lavora gruppo. Un quaderno di laboratorio\naiuta condividere con colleghi o compagni di laboratorio non solo ciò che si è fatto, ma anche il motivo per cui lo si è fatto.\ncolleghi o compagni di laboratorio.Aiuta gli altri capire il vostro lavoro. È raro che l’analisi dei dati venga svolta da\nda soli e spesso si lavora gruppo. Un quaderno di laboratorio\naiuta condividere con colleghi o compagni di laboratorio non solo ciò che si è fatto, ma anche il motivo per cui lo si è fatto.\ncolleghi o compagni di laboratorio.Molti dei buoni consigli sull’uso efficace dei quaderni di laboratorio possono essere applicati anche ai quaderni di analisi. Ho attinto alle mie esperienze personali e ai consigli di Colin Purrington sui taccuini di laboratorio (http://colinpurrington.com/tips/lab-notebooks) per trovare seguenti suggerimenti:Assicurarsi che ogni quaderno abbia un titolo descrittivo, un nome di file evocativo e un\nun primo paragrafo che descriva brevemente gli obiettivi dell’analisi.Assicurarsi che ogni quaderno abbia un titolo descrittivo, un nome di file evocativo e un\nun primo paragrafo che descriva brevemente gli obiettivi dell’analisi.Usare il campo data dell’intestazione YAML per registrare la data cui si è cominciato lavorare sul\ntaccuino:\ndata: 2016-08-23\nUsare il formato ISO8601 YYYY-MM-DD per evitare ambiguità. Usarlo\nanche se normalmente non si scrivono le date questo modo!Usare il campo data dell’intestazione YAML per registrare la data cui si è cominciato lavorare sul\ntaccuino:Usare il formato ISO8601 YYYY-MM-DD per evitare ambiguità. Usarlo\nanche se normalmente non si scrivono le date questo modo!Se si dedica molto tempo un’idea di analisi e questa si rivela un vicolo cieco, non cancellarla.\nun vicolo cieco, non cancellatela! Scrivete una breve nota sul motivo del fallimento e lasciatela nel quaderno.\ne lasciatela nel quaderno. Questo vi aiuterà evitare di imboccare lo stesso\nvicolo cieco quando si tornerà ’analisi futuro.Se si dedica molto tempo un’idea di analisi e questa si rivela un vicolo cieco, non cancellarla.\nun vicolo cieco, non cancellatela! Scrivete una breve nota sul motivo del fallimento e lasciatela nel quaderno.\ne lasciatela nel quaderno. Questo vi aiuterà evitare di imboccare lo stesso\nvicolo cieco quando si tornerà ’analisi futuro.generale, è meglio fare l’inserimento dei dati al di fuori di R. Ma se si ha la necessità di registrare un piccolo frammento di dati.\ndi registrare un piccolo frammento di dati, è consigliabile definirlo modo chiaro usando\ntibble::tribble().generale, è meglio fare l’inserimento dei dati al di fuori di R. Ma se si ha la necessità di registrare un piccolo frammento di dati.\ndi registrare un piccolo frammento di dati, è consigliabile definirlo modo chiaro usando\ntibble::tribble().Se si scopre un errore un file di dati, non modificarlo mai direttamente, ma scrivere codice per correggere il valore.\ninvece scrivere del codice per correggere il valore. Spiegate perché avete fatto la correzione.Se si scopre un errore un file di dati, non modificarlo mai direttamente, ma scrivere codice per correggere il valore.\ninvece scrivere del codice per correggere il valore. Spiegate perché avete fatto la correzione.Prima di terminare la giornata, assicurarsi di poter collegare il blocco note\n(se si utilizza la cache, assicurarsi di cancellare la cache). questo modo\nQuesto vi permetterà di risolvere eventuali problemi mentre il codice è ancora fresco nella vostra mente.Prima di terminare la giornata, assicurarsi di poter collegare il blocco note\n(se si utilizza la cache, assicurarsi di cancellare la cache). questo modo\nQuesto vi permetterà di risolvere eventuali problemi mentre il codice è ancora fresco nella vostra mente.Se volete che il vostro codice sia riproducibile lungo termine (cioè modo da poter tornare eseguirlo il mese prossimo o il giorno dopo).\ntornare eseguirlo il mese prossimo o l’anno prossimo), è necessario tenere traccia delle versioni dei pacchetti\ndelle versioni dei pacchetti che il codice utilizza. Un approccio rigoroso è quello di usare\npackrat, http://rstudio.github.io/packrat/, che memorizza pacchetti\nnella cartella del progetto, oppure checkpoint,\nhttps://github.com/RevolutionAnalytics/checkpoint, che reinstallerà pacchetti\ndisponibili una data specifica. Un trucco veloce e sporco è quello di includere\nun pezzo che esegue sessionInfo() — che non permette di ricreare facilmente\npacchetti come sono oggi, ma almeno si saprà quali erano.Se volete che il vostro codice sia riproducibile lungo termine (cioè modo da poter tornare eseguirlo il mese prossimo o il giorno dopo).\ntornare eseguirlo il mese prossimo o l’anno prossimo), è necessario tenere traccia delle versioni dei pacchetti\ndelle versioni dei pacchetti che il codice utilizza. Un approccio rigoroso è quello di usare\npackrat, http://rstudio.github.io/packrat/, che memorizza pacchetti\nnella cartella del progetto, oppure checkpoint,\nhttps://github.com/RevolutionAnalytics/checkpoint, che reinstallerà pacchetti\ndisponibili una data specifica. Un trucco veloce e sporco è quello di includere\nun pezzo che esegue sessionInfo() — che non permette di ricreare facilmente\npacchetti come sono oggi, ma almeno si saprà quali erano.Nel corso della vostra carriera creerete molti, molti, molti quaderni di analisi.\ndella vostra carriera. Come li organizzerete per poterli ritrovare futuro?\nfuturo? Vi consiglio di archiviarli progetti individuali,\ne di trovare un buon schema di denominazione.Nel corso della vostra carriera creerete molti, molti, molti quaderni di analisi.\ndella vostra carriera. Come li organizzerete per poterli ritrovare futuro?\nfuturo? Vi consiglio di archiviarli progetti individuali,\ne di trovare un buon schema di denominazione.","code":"data: 2016-08-23"}]
